<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3613. æœ€å°åŒ–è¿é€šåˆ†é‡çš„æœ€å¤§æˆæœ¬ - LeetCode</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="top-bar">
        <button class="menu-button" onclick="history.back()" aria-label="è¿”å›">
            <div class="menu-icon">
                <span style="transform: rotate(-45deg) translateY(-2px);"></span>
                <span style="transform: rotate(45deg) translateY(2px);"></span>
            </div>
        </button>
        <div class="logo">
            <span class="logo-emoji">ğŸ“š</span>
            LeetCode æ¯æ—¥é¢˜ç›®
        </div>
        <div class="update-time">2026-02-26 04:00:00</div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content" style="margin-left: 0;">
        <div class="content-wrapper">
            <button class="back-button" onclick="history.back()">
                â† è¿”å›é¢˜ç›®åˆ—è¡¨
            </button>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-number">3613. æœ€å°åŒ–è¿é€šåˆ†é‡çš„æœ€å¤§æˆæœ¬</span>
                    <span class="difficulty-badge difficulty-medium">
                        ä¸­ç­‰
                    </span>
                    <a href="https://leetcode.cn/problems/minimize-maximum-component-cost/" target="_blank" class="question-link">åœ¨ LeetCode æ‰“å¼€</a>
                </div>
                <div class="markdown-content">
                    <h1 id="3613-æœ€å°åŒ–è¿é€šåˆ†é‡çš„æœ€å¤§æˆæœ¬">3613. æœ€å°åŒ–è¿é€šåˆ†é‡çš„æœ€å¤§æˆæœ¬</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: å¹¶æŸ¥é›†, å›¾, äºŒåˆ†æŸ¥æ‰¾, æ’åº</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/minimize-maximum-component-cost/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p data-end="331" data-start="85">ç»™ä½ ä¸€ä¸ªæ— å‘è¿é€šå›¾ï¼ŒåŒ…å« <code data-end="137" data-start="134">n</code> ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ç¼–å·ä» 0 åˆ° <code data-end="171" data-start="164">n - 1</code>ï¼Œä»¥åŠä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ <code data-end="202" data-start="195">edges</code>ï¼Œå…¶ä¸­ <code data-end="234" data-start="209">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> è¡¨ç¤ºä¸€æ¡è¿æ¥èŠ‚ç‚¹ <code data-end="279" data-start="275">u<sub>i</sub></code> å’ŒèŠ‚ç‚¹ <code data-end="293" data-start="289">v<sub>i</sub></code> çš„æ— å‘è¾¹ï¼Œè¾¹æƒä¸º <code data-end="310" data-start="306">w<sub>i</sub></code>ï¼Œå¦æœ‰ä¸€ä¸ªæ•´æ•° <code data-end="330" data-start="327">k</code>ã€‚</p>

<p data-end="461" data-start="333">ä½ å¯ä»¥ä»å›¾ä¸­ç§»é™¤ä»»æ„æ•°é‡çš„è¾¹ï¼Œä½¿å¾—æœ€ç»ˆçš„å›¾ä¸­&nbsp;<strong>æœ€å¤š&nbsp;</strong>åªåŒ…å« <code data-end="439" data-start="436">k</code> ä¸ªè¿é€šåˆ†é‡ã€‚</p>

<p data-end="589" data-start="463">è¿é€šåˆ†é‡çš„ <strong>æˆæœ¬&nbsp;</strong>å®šä¹‰ä¸ºè¯¥åˆ†é‡ä¸­è¾¹æƒçš„&nbsp;<strong>æœ€å¤§å€¼&nbsp;</strong>ã€‚å¦‚æœä¸€ä¸ªè¿é€šåˆ†é‡æ²¡æœ‰è¾¹ï¼Œåˆ™å…¶ä»£ä»·ä¸º 0ã€‚</p>

<p data-end="760" data-start="661">è¯·è¿”å›åœ¨ç§»é™¤è¿™äº›è¾¹ä¹‹åï¼Œåœ¨æ‰€æœ‰è¿é€šåˆ†é‡ä¹‹ä¸­çš„&nbsp;<strong>æœ€å¤§æˆæœ¬&nbsp;</strong>çš„&nbsp;<strong>æœ€å°å¯èƒ½å€¼&nbsp;</strong>ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<div class="example-block">
<p><strong>è¾“å…¥ï¼š</strong> <span class="example-io">n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2</span></p>

<p><strong>è¾“å‡ºï¼š</strong> <span class="example-io">4</span></p>

<p><strong>è§£é‡Šï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minimizemaximumm.jpg" style="width: 535px; height: 225px;" /></p>

<ul>
    <li data-end="1070" data-start="1021">ç§»é™¤èŠ‚ç‚¹ 3 å’ŒèŠ‚ç‚¹ 4 ä¹‹é—´çš„è¾¹ï¼ˆæƒå€¼ä¸º 6ï¼‰ã€‚</li>
    <li data-end="1141" data-start="1073">æœ€ç»ˆçš„è¿é€šåˆ†é‡æˆæœ¬åˆ†åˆ«ä¸º 0 å’Œ 4ï¼Œå› æ­¤æœ€å¤§ä»£ä»·ä¸º 4ã€‚</li>
</ul>
</div>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<div class="example-block">
<p><strong>è¾“å…¥ï¼š</strong> <span class="example-io">n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1</span></p>

<p><strong>è¾“å‡ºï¼š</strong> <span class="example-io">5</span></p>

<p><strong>è§£é‡Šï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minmax2.jpg" style="width: 315px; height: 55px;" /></p>

<ul>
    <li data-end="1315" data-start="1251">æ— æ³•ç§»é™¤ä»»ä½•è¾¹ï¼Œå› ä¸ºåªå…è®¸ä¸€ä¸ªè¿é€šåˆ†é‡ï¼ˆ<code>k = 1</code>ï¼‰ï¼Œå›¾å¿…é¡»ä¿æŒå®Œå…¨è¿é€šã€‚</li>
    <li data-end="1389" data-start="1318">è¯¥è¿é€šåˆ†é‡çš„æˆæœ¬ç­‰äºå…¶æœ€å¤§è¾¹æƒï¼Œå³ 5ã€‚</li>
</ul>
</div>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
    <li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
    <li><code>edges[i].length == 3</code></li>
    <li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
    <li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
    <li><code>1 &lt;= k &lt;= n</code></li>
    <li>è¾“å…¥å›¾æ˜¯è¿é€šå›¾ã€‚</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    int minCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public int minCost(int n, int[][] edges, int k) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def minCost(self, n: int, edges: List[List[int]], k: int) -&gt; int:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} k
 * @return {number}
 */
var minCost = function(n, edges, k) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func minCost(n int, edges [][]int, k int) int {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Sort the <code>edges</code> and do binary search on the candidate maximum weight</li>
<li>Use <code>DFS</code> or <code>DSU</code> to count the number of connected components when keeping only edges with weight &lt;= mid</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>5
[[0,1,4],[1,2,3],[1,3,2],[3,4,6]]
2
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ª<strong>æœ€å°åŒ–æœ€å¤§å€¼</strong>é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æœ€å¤šä¿ç•™ k ä¸ªè¿é€šåˆ†é‡çš„å‰æä¸‹ï¼Œé€šè¿‡åˆ é™¤è¾¹æ¥æœ€å°åŒ–æ‰€æœ‰è¿é€šåˆ†é‡ä¸­è¾¹æƒæœ€å¤§å€¼çš„æœ€å¤§å€¼ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
1. åˆå§‹å›¾æ˜¯è¿é€šçš„ï¼ˆn ä¸ªèŠ‚ç‚¹ï¼Œ1 ä¸ªè¿é€šåˆ†é‡ï¼‰
2. åˆ é™¤è¾¹ä¼šå¢åŠ è¿é€šåˆ†é‡æ•°é‡
3. æ¯ä¸ªè¿é€šåˆ†é‡çš„æˆæœ¬ = è¯¥åˆ†é‡ä¸­æ‰€æœ‰è¾¹çš„æœ€å¤§è¾¹æƒï¼ˆå¦‚æœæ²¡æœ‰è¾¹åˆ™ä¸º 0ï¼‰
4. æœ€ç»ˆè¿é€šåˆ†é‡æ•° â‰¤ k
5. ç›®æ ‡æ˜¯<strong>æœ€å°åŒ–æ‰€æœ‰è¿é€šåˆ†é‡æˆæœ¬çš„æœ€å¤§å€¼</strong></p>

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="æ ¸å¿ƒè§‚å¯Ÿ">æ ¸å¿ƒè§‚å¯Ÿ</h3>

<ul>
<li>å¦‚æœæˆ‘ä»¬è®¾å®šä¸€ä¸ªé˜ˆå€¼ <code>x</code>ï¼Œåªä¿ç•™è¾¹æƒ â‰¤ <code>x</code> çš„è¾¹ï¼Œé‚£ä¹ˆï¼š
<ul>
<li>æ¯ä¸ªè¿é€šåˆ†é‡çš„æˆæœ¬ â‰¤ <code>x</code></li>
<li>åˆ é™¤è¾¹æƒ &gt; <code>x</code> çš„è¾¹ä¼šå¢åŠ è¿é€šåˆ†é‡æ•°é‡</li>
</ul></li>
<li>é—®é¢˜è½¬åŒ–ä¸ºï¼šæ‰¾åˆ°æœ€å°çš„ <code>x</code>ï¼Œä½¿å¾—åˆ é™¤æ‰€æœ‰è¾¹æƒ &gt; <code>x</code> çš„è¾¹åï¼Œè¿é€šåˆ†é‡æ•° â‰¤ k</li>
</ul>

<h3 id="è½¬åŒ–ä¸ºåˆ¤å®šé—®é¢˜">è½¬åŒ–ä¸ºåˆ¤å®šé—®é¢˜</h3>

<p>å¯¹äºç»™å®šçš„ <code>x</code>ï¼š
1. åªè€ƒè™‘è¾¹æƒ â‰¤ <code>x</code> çš„è¾¹æ„å»ºå­å›¾
2. è®¡ç®—è¯¥å­å›¾çš„è¿é€šåˆ†é‡æ•° <code>cnt</code>
3. å¦‚æœ <code>cnt â‰¤ k</code>ï¼Œåˆ™ <code>x</code> å¯è¡Œï¼ˆå› ä¸ºå¯ä»¥è¿›ä¸€æ­¥åˆ é™¤è¾¹æ¥å¢åŠ åˆ†é‡ï¼Œä½†ä¸ä¼šå¢åŠ æˆæœ¬ï¼‰</p>

<h3 id="è§£æ³•é€‰æ‹©">è§£æ³•é€‰æ‹©</h3>

<ol>
<li><strong>äºŒåˆ†ç­”æ¡ˆ + å¹¶æŸ¥é›†</strong>ï¼ˆæœ€ä¼˜è§£ï¼‰</li>
<li><strong>Kruskal å˜ç§</strong>ï¼ˆç±»ä¼¼æœ€å°ç”Ÿæˆæ ‘æ€æƒ³ï¼‰</li>
<li><strong>DFS/BFS è®¡æ•°</strong>ï¼ˆé…åˆäºŒåˆ†ï¼‰</li>
</ol>

<h2 id="è§£æ³•ä¸€äºŒåˆ†ç­”æ¡ˆ-å¹¶æŸ¥é›†">è§£æ³•ä¸€ï¼šäºŒåˆ†ç­”æ¡ˆ + å¹¶æŸ¥é›†</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<ol>
<li>å¯¹è¾¹æƒè¿›è¡Œæ’åºï¼ˆç”¨äºäºŒåˆ†ï¼‰</li>
<li>äºŒåˆ†æŸ¥æ‰¾æœ€å°çš„ <code>x</code>ï¼Œä½¿å¾—åªä½¿ç”¨è¾¹æƒ â‰¤ <code>x</code> çš„è¾¹æ—¶ï¼Œè¿é€šåˆ†é‡æ•° â‰¤ k</li>
<li>ä½¿ç”¨å¹¶æŸ¥é›†å¿«é€Ÿè®¡ç®—è¿é€šåˆ†é‡æ•°</li>
</ol>

<h3 id="å¤æ‚åº¦">å¤æ‚åº¦</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO((E + n) log W)ï¼ŒW æ˜¯æœ€å¤§è¾¹æƒ</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(n)</li>
</ul>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>func minMaxCost(n int, edges [][]int, k int) int {
    // è¾¹æƒèŒƒå›´
    left, right := 0, 0
    for _, e := range edges {
        if e[2] &gt; right {
            right = e[2]
        }
    }

    // äºŒåˆ†ç­”æ¡ˆ
    ans := right
    for left &lt;= right {
        mid := left + (right-left)/2
        if check(n, edges, k, mid) {
            ans = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return ans
}

func check(n int, edges [][]int, k int, limit int) bool {
    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    parent := make([]int, n)
    for i := 0; i &lt; n; i++ {
        parent[i] = i
    }

    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    union := func(x, y int) {
        px, py := find(x), find(y)
        if px != py {
            parent[px] = py
        }
    }

    // åªè¿æ¥è¾¹æƒ &lt;= limit çš„è¾¹
    for _, e := range edges {
        if e[2] &lt;= limit {
            union(e[0], e[1])
        }
    }

    // è®¡ç®—è¿é€šåˆ†é‡æ•°
    components := 0
    for i := 0; i &lt; n; i++ {
        if find(i) == i {
            components++
        }
    }

    return components &lt;= k
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int minMaxCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k) {
        int left = 0, right = 0;
        for (auto&amp; e : edges) {
            right = max(right, e[2]);
        }

        int ans = right;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            if (check(n, edges, k, mid)) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

private:
    bool check(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k, int limit) {
        vector&lt;int&gt; parent(n);
        iota(parent.begin(), parent.end(), 0);

        function&lt;int(int)&gt; find = [&amp;](int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        };

        auto unionSet = [&amp;](int x, int y) {
            int px = find(x), py = find(y);
            if (px != py) {
                parent[px] = py;
            }
        };

        for (auto&amp; e : edges) {
            if (e[2] &lt;= limit) {
                unionSet(e[0], e[1]);
            }
        }

        int components = 0;
        for (int i = 0; i &lt; n; i++) {
            if (find(i) == i) {
                components++;
            }
        }

        return components &lt;= k;
    }
};
</code></pre>

<h2 id="è§£æ³•äºŒkruskal-å˜ç§è´ªå¿ƒ">è§£æ³•äºŒï¼šKruskal å˜ç§ï¼ˆè´ªå¿ƒï¼‰</h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<ol>
<li>å°†è¾¹æŒ‰æƒå€¼ä»å°åˆ°å¤§æ’åº</li>
<li>ä½¿ç”¨ Kruskal ç®—æ³•é€æ­¥æ·»åŠ è¾¹</li>
<li>å½“æ·»åŠ ä¸€æ¡è¾¹ä¼šå‡å°‘è¿é€šåˆ†é‡æ•°æ—¶ï¼Œè®°å½•å½“å‰è¿é€šåˆ†é‡æ•°</li>
<li>æ‰¾åˆ°æ»¡è¶³è¿é€šåˆ†é‡æ•° â‰¤ k çš„æœ€å°è¾¹æƒ</li>
</ol>

<h3 id="å¤æ‚åº¦-2">å¤æ‚åº¦</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO(E log E + E Î±(n))</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(n)</li>
</ul>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-2">Go å®ç°</h4>

<pre><code>func minMaxCost(n int, edges [][]int, k int) int {
    // æŒ‰è¾¹æƒæ’åº
    sort.Slice(edges, func(i, j int) bool {
        return edges[i][2] &lt; edges[j][2]
    })

    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    parent := make([]int, n)
    for i := 0; i &lt; n; i++ {
        parent[i] = i
    }

    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    union := func(x, y int) bool {
        px, py := find(x), find(y)
        if px == py {
            return false
        }
        parent[px] = py
        return true
    }

    // åˆå§‹è¿é€šåˆ†é‡æ•°
    components := n

    // ç‰¹æ®Šæƒ…å†µï¼šä¸éœ€è¦è¾¹
    if components &lt;= k {
        return 0
    }

    // é€æ­¥æ·»åŠ è¾¹
    for _, e := range edges {
        if union(e[0], e[1]) {
            components--
            if components &lt;= k {
                return e[2]
            }
        }
    }

    // å¦‚æœæ‰€æœ‰è¾¹éƒ½æ·»åŠ åä»ç„¶ &gt; kï¼Œè¿”å›æœ€å¤§è¾¹æƒ
    return edges[len(edges)-1][2]
}
</code></pre>

<h4 id="c-å®ç°-2">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int minMaxCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k) {
        // æŒ‰è¾¹æƒæ’åº
        sort(edges.begin(), edges.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
            return a[2] &lt; b[2];
        });

        vector&lt;int&gt; parent(n);
        iota(parent.begin(), parent.end(), 0);

        function&lt;int(int)&gt; find = [&amp;](int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        };

        auto unionSet = [&amp;](int x, int y) -&gt; bool {
            int px = find(x), py = find(y);
            if (px == py) return false;
            parent[px] = py;
            return true;
        };

        int components = n;

        // ç‰¹æ®Šæƒ…å†µ
        if (components &lt;= k) return 0;

        for (auto&amp; e : edges) {
            if (unionSet(e[0], e[1])) {
                components--;
                if (components &lt;= k) {
                    return e[2];
                }
            }
        }

        return edges.back()[2];
    }
};
</code></pre>

<h2 id="è§£æ³•ä¸‰äºŒåˆ†ç­”æ¡ˆ-dfsbfs">è§£æ³•ä¸‰ï¼šäºŒåˆ†ç­”æ¡ˆ + DFS/BFS</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<ol>
<li>äºŒåˆ†ç­”æ¡ˆ</li>
<li>å¯¹äºæ¯ä¸ª midï¼Œæ„å»ºåªåŒ…å«è¾¹æƒ â‰¤ mid çš„å›¾</li>
<li>ä½¿ç”¨ DFS/BFS è®¡ç®—è¿é€šåˆ†é‡æ•°</li>
</ol>

<h3 id="å¤æ‚åº¦-3">å¤æ‚åº¦</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO((E + n) log W)</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(E + n)</li>
</ul>

<h3 id="ä»£ç å®ç°go">ä»£ç å®ç°ï¼ˆGoï¼‰</h3>

<pre><code>func minMaxCost(n int, edges [][]int, k int) int {
    // æ„å»ºé‚»æ¥è¡¨ï¼ˆç”¨äºDFS/BFSï¼‰
    maxWeight := 0
    for _, e := range edges {
        if e[2] &gt; maxWeight {
            maxWeight = e[2]
        }
    }

    left, right := 0, maxWeight
    ans := right

    for left &lt;= right {
        mid := left + (right-left)/2

        // æ„å»ºé‚»æ¥è¡¨ï¼ˆåªåŒ…å«è¾¹æƒ &lt;= mid çš„è¾¹ï¼‰
        adj := make([][]int, n)
        for _, e := range edges {
            if e[2] &lt;= mid {
                adj[e[0]] = append(adj[e[0]], e[1])
                adj[e[1]] = append(adj[e[1]], e[0])
            }
        }

        // DFSè®¡ç®—è¿é€šåˆ†é‡æ•°
        visited := make([]bool, n)
        components := 0
        for i := 0; i &lt; n; i++ {
            if !visited[i] {
                components++
                dfs(i, adj, visited)
            }
        }

        if components &lt;= k {
            ans = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }

    return ans
}

func dfs(node int, adj [][]int, visited []bool) {
    visited[node] = true
    for _, neighbor := range adj[node] {
        if !visited[neighbor] {
            dfs(neighbor, adj, visited)
        }
    }
}
</code></pre>

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>ç‰¹æ€§</th>
  <th>äºŒåˆ†+å¹¶æŸ¥é›†</th>
  <th>Kruskalå˜ç§</th>
  <th>äºŒåˆ†+DFS/BFS</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æ—¶é—´å¤æ‚åº¦</td>
  <td>O((E+n)logW)</td>
  <td>O(ElogE + EÎ±(n))</td>
  <td>O((E+n)logW)</td>
</tr>
<tr>
  <td>ç©ºé—´å¤æ‚åº¦</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>O(E+n)</td>
</tr>
<tr>
  <td>å®ç°éš¾åº¦</td>
  <td>ç®€å•</td>
  <td>ç®€å•</td>
  <td>ä¸­ç­‰</td>
</tr>
<tr>
  <td>é€‚ç”¨åœºæ™¯</td>
  <td>é€šç”¨</td>
  <td>è¾¹å·²æ’åºæˆ–éœ€è¦æ’åº</td>
  <td>éœ€è¦æ˜¾å¼å›¾ç»“æ„</td>
</tr>
<tr>
  <td>ä¼˜ç‚¹</td>
  <td>ç¨³å®šé«˜æ•ˆ</td>
  <td>ç›´è§‚ï¼Œä¸€æ¬¡éå†</td>
  <td>ä¸éœ€è¦å¹¶æŸ¥é›†</td>
</tr>
<tr>
  <td>ç¼ºç‚¹</td>
  <td>éœ€è¦äºŒåˆ†</td>
  <td>å¿…é¡»æ’åºæ‰€æœ‰è¾¹</td>
  <td>éœ€è¦æ„å»ºå›¾ï¼Œç©ºé—´å¤§</td>
</tr>
</tbody>
</table>

<h2 id="æ¨èè§£æ³•">æ¨èè§£æ³•</h2>

<p><strong>è§£æ³•ä¸€ï¼ˆäºŒåˆ†+å¹¶æŸ¥é›†ï¼‰æ˜¯æœ€æ¨èçš„</strong>ï¼Œå› ä¸ºï¼š
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜
2. ç©ºé—´å¤æ‚åº¦ä½
3. å®ç°ç®€å•ç›´è§‚
4. é€‚ç”¨äºå„ç§è§„æ¨¡çš„è¾“å…¥</p>

<p><strong>è§£æ³•äºŒï¼ˆKruskalå˜ç§ï¼‰</strong> ä¹Ÿå¾ˆä¼˜ç§€ï¼Œç‰¹åˆ«æ˜¯å½“è¾¹å·²ç»æ’åºæˆ–éœ€è¦æ’åºæ—¶ï¼Œå®ƒæ›´ç›´è§‚ã€‚</p>

<p><strong>è§£æ³•ä¸‰</strong> åœ¨éœ€è¦æ˜¾å¼å›¾ç»“æ„æ—¶æœ‰ç”¨ï¼Œä½†ç©ºé—´å¼€é”€è¾ƒå¤§ã€‚</p>

<p>åœ¨å®é™… LeetCode æäº¤ä¸­ï¼Œè§£æ³•ä¸€å’Œè§£æ³•äºŒéƒ½æ˜¯å¯è¡Œçš„ï¼Œè§£æ³•ä¸€é€šå¸¸æ›´å¿«ä¸€äº›ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 19:06:37</em></p>

                </div>
            </div>

            <div class="footer">
                <p>ç”± <a href="https://github.com/LFrankl/leetcode" target="_blank">LeetCode Daily Script</a> è‡ªåŠ¨ç”Ÿæˆ</p>
                <p>AI è§£ç­”ç”± <a href="https://www.deepseek.com/" target="_blank">DeepSeek</a> æä¾›</p>
            </div>
        </div>
    </div>
</body>
</html>