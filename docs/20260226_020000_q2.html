<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2213. ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸² - LeetCode</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="top-bar">
        <button class="menu-button" onclick="history.back()" aria-label="è¿”å›">
            <div class="menu-icon">
                <span style="transform: rotate(-45deg) translateY(-2px);"></span>
                <span style="transform: rotate(45deg) translateY(2px);"></span>
            </div>
        </button>
        <div class="logo">
            <span class="logo-emoji">ğŸ“š</span>
            LeetCode æ¯æ—¥é¢˜ç›®
        </div>
        <div class="update-time">2026-02-26 02:00:00</div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content" style="margin-left: 0;">
        <div class="content-wrapper">
            <button class="back-button" onclick="history.back()">
                â† è¿”å›é¢˜ç›®åˆ—è¡¨
            </button>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-number">2213. ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸²</span>
                    <span class="difficulty-badge difficulty-hard">
                        å›°éš¾
                    </span>
                    <a href="https://leetcode.cn/problems/longest-substring-of-one-repeating-character/" target="_blank" class="question-link">åœ¨ LeetCode æ‰“å¼€</a>
                </div>
                <div class="markdown-content">
                    <h1 id="2213-ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸²">2213. ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸²</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: çº¿æ®µæ ‘, æ•°ç»„, å­—ç¬¦ä¸², æœ‰åºé›†åˆ</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/longest-substring-of-one-repeating-character/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» <strong>0</strong> å¼€å§‹çš„å­—ç¬¦ä¸² <code>s</code> ã€‚å¦ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» <strong>0</strong> å¼€å§‹ã€é•¿åº¦ä¸º <code>k</code> çš„å­—ç¬¦ä¸² <code>queryCharacters</code> ï¼Œä¸€ä¸ªä¸‹æ ‡ä» <code>0</code> å¼€å§‹ã€é•¿åº¦ä¹Ÿæ˜¯ <code>k</code> çš„æ•´æ•° <strong>ä¸‹æ ‡</strong> æ•°ç»„&nbsp;<code>queryIndices</code> ï¼Œè¿™ä¸¤ä¸ªéƒ½ç”¨æ¥æè¿° <code>k</code> ä¸ªæŸ¥è¯¢ã€‚</p>

<p>ç¬¬ <code>i</code> ä¸ªæŸ¥è¯¢ä¼šå°† <code>s</code> ä¸­ä½äºä¸‹æ ‡ <code>queryIndices[i]</code> çš„å­—ç¬¦æ›´æ–°ä¸º <code>queryCharacters[i]</code> ã€‚</p>

<p>è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º <code>k</code> çš„æ•°ç»„ <code>lengths</code> ï¼Œå…¶ä¸­ <code>lengths[i]</code> æ˜¯åœ¨æ‰§è¡Œç¬¬ <code>i</code> ä¸ªæŸ¥è¯¢ <strong>ä¹‹å</strong> <code>s</code> ä¸­ä»…ç”± <strong>å•ä¸ªå­—ç¬¦é‡å¤</strong> ç»„æˆçš„ <strong>æœ€é•¿å­å­—ç¬¦ä¸²</strong> çš„ <strong>é•¿åº¦</strong> <em>ã€‚</em></p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]
<strong>è¾“å‡ºï¼š</strong>[3,3,4]
<strong>è§£é‡Šï¼š</strong>
- ç¬¬ 1 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>b<strong>b</strong>b</em>acc" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbb" ï¼Œé•¿åº¦ä¸º 3 ã€‚
- ç¬¬ 2 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "bbb<em><strong>c</strong>cc</em>" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbb" æˆ– "ccc"ï¼Œé•¿åº¦ä¸º 3 ã€‚
- ç¬¬ 3 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>bbb<strong>b</strong></em>cc" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbbb" ï¼Œé•¿åº¦ä¸º 4 ã€‚
å› æ­¤ï¼Œè¿”å› [3,3,4] ã€‚</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "abyzz", queryCharacters = "aa", queryIndices = [2,1]
<strong>è¾“å‡ºï¼š</strong>[2,3]
<strong>è§£é‡Šï¼š</strong>
- ç¬¬ 1 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "ab<strong>a</strong><em>zz</em>" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "zz" ï¼Œé•¿åº¦ä¸º 2 ã€‚
- ç¬¬ 2 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>a<strong>a</strong>a</em>zz" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "aaa" ï¼Œé•¿åº¦ä¸º 3 ã€‚
å› æ­¤ï¼Œè¿”å› [2,3] ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
    <li><code>s</code> ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ</li>
    <li><code>k == queryCharacters.length == queryIndices.length</code></li>
    <li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
    <li><code>queryCharacters</code> ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ</li>
    <li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -&gt; List[int]:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {string} s
 * @param {string} queryCharacters
 * @param {number[]} queryIndices
 * @return {number[]}
 */
var longestRepeating = function(s, queryCharacters, queryIndices) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Use a segment tree to perform fast point updates and range queries.</li>
<li>We need each segment tree node to store the length of the longest substring of that segment consisting of only 1 repeating character.</li>
<li>We will also have each segment tree node store the leftmost and rightmost character of the segment, the max length of a prefix substring consisting of only 1 repeating character, and the max length of a suffix substring consisting of only 1 repeating character.</li>
<li>Use this information to properly merge the two segment tree nodes together.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>"babacc"
"bcb"
[1,3,3]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p><strong>é—®é¢˜æ ¸å¿ƒ</strong>ï¼š
- åˆå§‹å­—ç¬¦ä¸² <code>s</code>ï¼Œé•¿åº¦ <code>n â‰¤ 1e5</code>
- æœ‰ <code>k â‰¤ 1e5</code> æ¬¡æŸ¥è¯¢ï¼Œæ¯æ¬¡æŸ¥è¯¢å°† <code>s[pos]</code> ä¿®æ”¹ä¸ºæŒ‡å®šå­—ç¬¦
- æ¯æ¬¡ä¿®æ”¹åï¼Œéœ€è¦è¿”å›å½“å‰å­—ç¬¦ä¸²ä¸­<strong>ç”±ç›¸åŒå­—ç¬¦ç»„æˆçš„è¿ç»­å­ä¸²çš„æœ€å¤§é•¿åº¦</strong></p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- æ¯æ¬¡ä¿®æ”¹åéœ€è¦å¿«é€Ÿè®¡ç®—æœ€é•¿è¿ç»­ç›¸åŒå­—ç¬¦çš„é•¿åº¦
- æš´åŠ›æ–¹æ³•ï¼ˆæ¯æ¬¡ O(n) æ‰«æï¼‰ä¼šè¶…æ—¶ï¼šO(nk) = 1e10
- éœ€è¦ç»´æŠ¤åŠ¨æ€ä¿¡æ¯ï¼Œæ”¯æŒå•ç‚¹æ›´æ–°å’Œå¿«é€ŸæŸ¥è¯¢å…¨å±€æœ€å¤§å€¼</p>

<hr />

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="æ€è·¯ä¸€çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ä¿¡æ¯æ¨è">æ€è·¯ä¸€ï¼šçº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ä¿¡æ¯ï¼ˆæ¨èï¼‰</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- ç”¨çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªåŒºé—´çš„æœ€é•¿è¿ç»­ç›¸åŒå­—ç¬¦ä¿¡æ¯
- æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ï¼š
  1. åŒºé—´é•¿åº¦ <code>len</code>
  2. å‰ç¼€æœ€é•¿è¿ç»­é•¿åº¦ <code>preLen</code>
  3. åç¼€æœ€é•¿è¿ç»­é•¿åº¦ <code>sufLen</code>
  4. åŒºé—´å†…æœ€é•¿è¿ç»­é•¿åº¦ <code>maxLen</code>
  5. åŒºé—´å·¦ç«¯å­—ç¬¦ <code>leftChar</code>
  6. åŒºé—´å³ç«¯å­—ç¬¦ <code>rightChar</code>
- åˆå¹¶ä¸¤ä¸ªå­åŒºé—´æ—¶ï¼š
  - å¦‚æœå·¦å­åŒºé—´çš„å³å­—ç¬¦ == å³å­åŒºé—´çš„å·¦å­—ç¬¦ï¼Œåˆ™å¯ä»¥åˆå¹¶
  - æ›´æ–° <code>preLen</code>, <code>sufLen</code>, <code>maxLen</code>
- æ¯æ¬¡ä¿®æ”¹æ›´æ–°å¶å­èŠ‚ç‚¹ï¼Œå‘ä¸Šåˆå¹¶
- æ ¹èŠ‚ç‚¹çš„ <code>maxLen</code> å°±æ˜¯ç­”æ¡ˆ</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- å»ºæ ‘ï¼šO(n)
- æ¯æ¬¡æŸ¥è¯¢æ›´æ–°ï¼šO(log n)
- æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h3 id="æ€è·¯äºŒåˆ†å—æ³•">æ€è·¯äºŒï¼šåˆ†å—æ³•</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- å°†å­—ç¬¦ä¸²åˆ†æˆè‹¥å¹²å—ï¼ˆæ¯å—å¤§å° â‰ˆ âˆšnï¼‰
- æ¯å—ç»´æŠ¤ï¼š
  - å—å†…æœ€é•¿è¿ç»­é•¿åº¦
  - å—å†…å‰ç¼€è¿ç»­é•¿åº¦
  - å—å†…åç¼€è¿ç»­é•¿åº¦
  - å—å†…å­—ç¬¦
- æ›´æ–°æ—¶åªæ›´æ–°æ‰€åœ¨å—
- æŸ¥è¯¢æ—¶ï¼š
  - å—å†…ç›´æ¥è®¡ç®—
  - å—é—´éœ€è¦è€ƒè™‘è¿æ¥å¤„</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- æ›´æ–°ï¼šO(âˆšn)
- æŸ¥è¯¢ï¼šO(âˆšn)
- æ€»å¤æ‚åº¦ï¼šO(kâˆšn)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h3 id="æ€è·¯ä¸‰å¹³è¡¡æ ‘treapsplayç»´æŠ¤è¿ç»­æ®µ">æ€è·¯ä¸‰ï¼šå¹³è¡¡æ ‘ï¼ˆTreap/Splayï¼‰ç»´æŠ¤è¿ç»­æ®µ</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- å°†å­—ç¬¦ä¸²è§†ä¸ºè‹¥å¹²è¿ç»­ç›¸åŒå­—ç¬¦çš„æ®µ
- ç”¨å¹³è¡¡æ ‘ç»´æŠ¤è¿™äº›æ®µï¼ˆæ¯æ®µè®°å½•å­—ç¬¦ã€é•¿åº¦ã€èµ·å§‹ä½ç½®ï¼‰
- ä¿®æ”¹æ—¶ï¼š
  - æ‰¾åˆ°åŒ…å«è¯¥ä½ç½®çš„æ®µ
  - å¯èƒ½åˆ†è£‚æ®µï¼ˆä¿®æ”¹ç‚¹åœ¨æ®µä¸­é—´ï¼‰
  - æ›´æ–°å­—ç¬¦
  - åˆå¹¶ç›¸é‚»ç›¸åŒå­—ç¬¦çš„æ®µ
- æŸ¥è¯¢æ—¶ï¼šå¹³è¡¡æ ‘ä¸­ç»´æŠ¤çš„æœ€å¤§é•¿åº¦</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- æ¯æ¬¡æ“ä½œï¼šO(log m)ï¼Œm ä¸ºæ®µæ•°
- æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h2 id="ä»£ç å®ç°">ä»£ç å®ç°</h2>

<h3 id="è§£æ³•ä¸€çº¿æ®µæ ‘æœ€ä¼˜è§£">è§£æ³•ä¸€ï¼šçº¿æ®µæ ‘ï¼ˆæœ€ä¼˜è§£ï¼‰</h3>

<pre><code>type Node struct {
    leftChar, rightChar byte
    preLen, sufLen, maxLen, size int
}

type SegmentTree struct {
    n int
    s []byte
    nodes []Node
}

func NewSegmentTree(str string) *SegmentTree {
    n := len(str)
    st := &amp;SegmentTree{
        n: n,
        s: []byte(str),
        nodes: make([]Node, 4*n),
    }
    st.build(1, 0, n-1)
    return st
}

func (st *SegmentTree) build(idx, l, r int) {
    if l == r {
        ch := st.s[l]
        st.nodes[idx] = Node{
            leftChar: ch,
            rightChar: ch,
            preLen: 1,
            sufLen: 1,
            maxLen: 1,
            size: 1,
        }
        return
    }
    mid := (l + r) / 2
    st.build(idx*2, l, mid)
    st.build(idx*2+1, mid+1, r)
    st.pushUp(idx)
}

func (st *SegmentTree) pushUp(idx int) {
    left := &amp;st.nodes[idx*2]
    right := &amp;st.nodes[idx*2+1]
    node := &amp;st.nodes[idx]

    node.leftChar = left.leftChar
    node.rightChar = right.rightChar
    node.size = left.size + right.size

    // å‰ç¼€é•¿åº¦
    node.preLen = left.preLen
    if left.preLen == left.size &amp;&amp; left.rightChar == right.leftChar {
        node.preLen = left.size + right.preLen
    }

    // åç¼€é•¿åº¦
    node.sufLen = right.sufLen
    if right.sufLen == right.size &amp;&amp; left.rightChar == right.leftChar {
        node.sufLen = right.size + left.sufLen
    }

    // æœ€å¤§é•¿åº¦
    node.maxLen = max(left.maxLen, right.maxLen)
    if left.rightChar == right.leftChar {
        node.maxLen = max(node.maxLen, left.sufLen+right.preLen)
    }
}

func (st *SegmentTree) update(pos int, ch byte) {
    st.updateHelper(1, 0, st.n-1, pos, ch)
}

func (st *SegmentTree) updateHelper(idx, l, r, pos int, ch byte) {
    if l == r {
        st.nodes[idx].leftChar = ch
        st.nodes[idx].rightChar = ch
        return
    }
    mid := (l + r) / 2
    if pos &lt;= mid {
        st.updateHelper(idx*2, l, mid, pos, ch)
    } else {
        st.updateHelper(idx*2+1, mid+1, r, pos, ch)
    }
    st.pushUp(idx)
}

func (st *SegmentTree) query() int {
    return st.nodes[1].maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    st := NewSegmentTree(s)
    k := len(queryIndices)
    ans := make([]int, k)

    for i := 0; i &lt; k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            st.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = st.query()
    }
    return ans
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Node {
    char leftChar, rightChar;
    int preLen, sufLen, maxLen, size;
};

class SegmentTree {
private:
    int n;
    string s;
    vector&lt;Node&gt; nodes;

    void build(int idx, int l, int r) {
        if (l == r) {
            char ch = s[l];
            nodes[idx] = {ch, ch, 1, 1, 1, 1};
            return;
        }
        int mid = (l + r) / 2;
        build(idx * 2, l, mid);
        build(idx * 2 + 1, mid + 1, r);
        pushUp(idx);
    }

    void pushUp(int idx) {
        Node&amp; left = nodes[idx * 2];
        Node&amp; right = nodes[idx * 2 + 1];
        Node&amp; node = nodes[idx];

        node.leftChar = left.leftChar;
        node.rightChar = right.rightChar;
        node.size = left.size + right.size;

        // å‰ç¼€é•¿åº¦
        node.preLen = left.preLen;
        if (left.preLen == left.size &amp;&amp; left.rightChar == right.leftChar) {
            node.preLen = left.size + right.preLen;
        }

        // åç¼€é•¿åº¦
        node.sufLen = right.sufLen;
        if (right.sufLen == right.size &amp;&amp; left.rightChar == right.leftChar) {
            node.sufLen = right.size + left.sufLen;
        }

        // æœ€å¤§é•¿åº¦
        node.maxLen = max(left.maxLen, right.maxLen);
        if (left.rightChar == right.leftChar) {
            node.maxLen = max(node.maxLen, left.sufLen + right.preLen);
        }
    }

    void updateHelper(int idx, int l, int r, int pos, char ch) {
        if (l == r) {
            nodes[idx].leftChar = ch;
            nodes[idx].rightChar = ch;
            return;
        }
        int mid = (l + r) / 2;
        if (pos &lt;= mid) {
            updateHelper(idx * 2, l, mid, pos, ch);
        } else {
            updateHelper(idx * 2 + 1, mid + 1, r, pos, ch);
        }
        pushUp(idx);
    }

public:
    SegmentTree(const string&amp; str) : s(str) {
        n = s.length();
        nodes.resize(4 * n);
        build(1, 0, n - 1);
    }

    void update(int pos, char ch) {
        updateHelper(1, 0, n - 1, pos, ch);
    }

    int query() {
        return nodes[1].maxLen;
    }
};

class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {
        SegmentTree st(s);
        int k = queryIndices.size();
        vector&lt;int&gt; ans(k);

        for (int i = 0; i &lt; k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                st.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = st.query();
        }
        return ans;
    }
};
</code></pre>

<hr />

<h3 id="è§£æ³•äºŒåˆ†å—æ³•">è§£æ³•äºŒï¼šåˆ†å—æ³•</h3>

<pre><code>type Block struct {
    start, end int
    chars []byte
    preLen, sufLen, maxLen int
}

func (b *Block) recalc() {
    n := len(b.chars)
    b.preLen = 1
    for i := 1; i &lt; n &amp;&amp; b.chars[i] == b.chars[0]; i++ {
        b.preLen++
    }

    b.sufLen = 1
    for i := n - 2; i &gt;= 0 &amp;&amp; b.chars[i] == b.chars[n-1]; i-- {
        b.sufLen++
    }

    b.maxLen = 1
    cur := 1
    for i := 1; i &lt; n; i++ {
        if b.chars[i] == b.chars[i-1] {
            cur++
            if cur &gt; b.maxLen {
                b.maxLen = cur
            }
        } else {
            cur = 1
        }
    }
}

type BlockArray struct {
    blocks []*Block
    blockSize int
    s []byte
}

func NewBlockArray(s string, blockSize int) *BlockArray {
    n := len(s)
    ba := &amp;BlockArray{
        s: []byte(s),
        blockSize: blockSize,
    }
    for i := 0; i &lt; n; i += blockSize {
        end := min(i+blockSize, n)
        block := &amp;Block{
            start: i,
            end: end,
            chars: []byte(s[i:end]),
        }
        block.recalc()
        ba.blocks = append(ba.blocks, block)
    }
    return ba
}

func (ba *BlockArray) update(pos int, ch byte) {
    ba.s[pos] = ch
    blockIdx := pos / ba.blockSize
    block := ba.blocks[blockIdx]
    localPos := pos % ba.blockSize
    block.chars[localPos] = ch
    block.recalc()
}

func (ba *BlockArray) query() int {
    maxLen := 0
    lastChar := byte(0)
    lastLen := 0

    for _, block := range ba.blocks {
        maxLen = max(maxLen, block.maxLen)

        // å¤„ç†å—é—´è¿æ¥
        if lastChar != 0 &amp;&amp; lastChar == block.chars[0] {
            total := lastLen + block.preLen
            maxLen = max(maxLen, total)
        }

        // æ›´æ–° lastChar å’Œ lastLen
        if block.sufLen == len(block.chars) {
            if lastChar == block.chars[0] {
                lastLen += len(block.chars)
            } else {
                lastLen = block.sufLen
                lastChar = block.chars[0]
            }
        } else {
            lastLen = block.sufLen
            lastChar = block.chars[len(block.chars)-1]
        }
    }
    return maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    n := len(s)
    blockSize := int(math.Sqrt(float64(n))) + 1
    ba := NewBlockArray(s, blockSize)

    k := len(queryIndices)
    ans := make([]int, k)

    for i := 0; i &lt; k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            ba.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = ba.query()
    }
    return ans
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Block {
    int start, end;
    vector&lt;char&gt; chars;
    int preLen, sufLen, maxLen;

    void recalc() {
        int n = chars.size();
        // è®¡ç®—å‰ç¼€é•¿åº¦
        preLen = 1;
        for (int i = 1; i &lt; n &amp;&amp; chars[i] == chars[0]; i++) {
            preLen++;
        }

        // è®¡ç®—åç¼€é•¿åº¦
        sufLen = 1;
        for (int i = n - 2; i &gt;= 0 &amp;&amp; chars[i] == chars[n-1]; i--) {
            sufLen++;
        }

        // è®¡ç®—æœ€å¤§é•¿åº¦
        maxLen = 1;
        int cur = 1;
        for (int i = 1; i &lt; n; i++) {
            if (chars[i] == chars[i-1]) {
                cur++;
                maxLen = max(maxLen, cur);
            } else {
                cur = 1;
            }
        }
    }
};

class BlockArray {
private:
    vector&lt;Block&gt; blocks;
    int blockSize;
    string s;

public:
    BlockArray(const string&amp; str, int bs) : s(str), blockSize(bs) {
        int n = s.length();
        for (int i = 0; i &lt; n; i += blockSize) {
            int end = min(i + blockSize, n);
            Block block;
            block.start = i;
            block.end = end;
            for (int j = i; j &lt; end; j++) {
                block.chars.push_back(s[j]);
            }
            block.recalc();
            blocks.push_back(block);
        }
    }

    void update(int pos, char ch) {
        s[pos] = ch;
        int blockIdx = pos / blockSize;
        int localPos = pos % blockSize;
        blocks[blockIdx].chars[localPos] = ch;
        blocks[blockIdx].recalc();
    }

    int query() {
        int maxLen = 0;
        char lastChar = 0;
        int lastLen = 0;

        for (auto&amp; block : blocks) {
            maxLen = max(maxLen, block.maxLen);

            // å¤„ç†å—é—´è¿æ¥
            if (lastChar != 0 &amp;&amp; lastChar == block.chars[0]) {
                int total = lastLen + block.preLen;
                maxLen = max(maxLen, total);
            }

            // æ›´æ–° lastChar å’Œ lastLen
            if (block.sufLen == (int)block.chars.size()) {
                if (lastChar == block.chars[0]) {
                    lastLen += block.chars.size();
                } else {
                    lastLen = block.sufLen;
                    lastChar = block.chars[0];
                }
            } else {
                lastLen = block.sufLen;
                lastChar = block.chars.back();
            }
        }
        return maxLen;
    }
};

class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {
        int n = s.length();
        int blockSize = sqrt(n) + 1;
        BlockArray ba(s, blockSize);

        int k = queryIndices.size();
        vector&lt;int&gt; ans(k);

        for (int i = 0; i &lt; k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                ba.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = ba.query();
        }
        return ans;
    }
};
</code></pre>

<hr />

<h2 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h2>

<h3 id="è§£æ³•ä¸€çº¿æ®µæ ‘">è§£æ³•ä¸€ï¼šçº¿æ®µæ ‘</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
<ul>
<li>å»ºæ ‘ï¼šO(n)</li>
<li>æ¯æ¬¡æ›´æ–°ï¼šO(log n)</li>
<li>æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</li>
</ul>

<h3 id="è§£æ³•äºŒåˆ†å—æ³•-2">è§£æ³•äºŒï¼šåˆ†å—æ³•</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
<ul>
<li>åˆå§‹åŒ–ï¼šO(n)</li>
<li>æ¯æ¬¡æ›´æ–°ï¼šO(âˆšn)ï¼ˆæ›´æ–°ä¸€ä¸ªå—ï¼‰</li>
<li>æ¯æ¬¡æŸ¥è¯¢ï¼šO(âˆšn)ï¼ˆéå†æ‰€æœ‰å—ï¼‰</li>
<li>æ€»å¤æ‚åº¦ï¼šO(kâˆšn)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</li>
</ul>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<p>| ç‰¹æ€§</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:50:30</em></p>

                </div>
            </div>

            <div class="footer">
                <p>ç”± <a href="https://github.com/LFrankl/leetcode" target="_blank">LeetCode Daily Script</a> è‡ªåŠ¨ç”Ÿæˆ</p>
                <p>AI è§£ç­”ç”± <a href="https://www.deepseek.com/" target="_blank">DeepSeek</a> æä¾›</p>
            </div>
        </div>
    </div>

    <!-- æµ®åŠ¨è¿”å›æŒ‰é’® -->
    <button class="fab-back" onclick="history.back()" aria-label="è¿”å›é¢˜ç›®åˆ—è¡¨">
        â†‘
    </button>
</body>
</html>