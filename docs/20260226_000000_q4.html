<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1616. åˆ†å‰²ä¸¤ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å›æ–‡ä¸² - LeetCode</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="top-bar">
        <button class="menu-button" onclick="history.back()" aria-label="è¿”å›">
            <div class="menu-icon">
                <span style="transform: rotate(-45deg) translateY(-2px);"></span>
                <span style="transform: rotate(45deg) translateY(2px);"></span>
            </div>
        </button>
        <div class="logo">
            <span class="logo-emoji">ğŸ“š</span>
            LeetCode æ¯æ—¥é¢˜ç›®
        </div>
        <div class="update-time">2026-02-26 00:00:00</div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content" style="margin-left: 0;">
        <div class="content-wrapper">
            <button class="back-button" onclick="history.back()">
                â† è¿”å›é¢˜ç›®åˆ—è¡¨
            </button>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-number">1616. åˆ†å‰²ä¸¤ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å›æ–‡ä¸²</span>
                    <span class="difficulty-badge difficulty-medium">
                        ä¸­ç­‰
                    </span>
                    <a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/" target="_blank" class="question-link">åœ¨ LeetCode æ‰“å¼€</a>
                </div>
                <div class="markdown-content">
                    <h1 id="1616-åˆ†å‰²ä¸¤ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å›æ–‡ä¸²">1616. åˆ†å‰²ä¸¤ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å›æ–‡ä¸²</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: åŒæŒ‡é’ˆ, å­—ç¬¦ä¸²</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/split-two-strings-to-make-palindrome/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²&nbsp;<code>a</code> å’Œ&nbsp;<code>b</code>&nbsp;ï¼Œå®ƒä»¬é•¿åº¦ç›¸åŒã€‚è¯·ä½ é€‰æ‹©ä¸€ä¸ªä¸‹æ ‡ï¼Œå°†ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½åœ¨&nbsp;<strong>ç›¸åŒçš„ä¸‹æ ‡ </strong>åˆ†å‰²å¼€ã€‚ç”±&nbsp;<code>a</code>&nbsp;å¯ä»¥å¾—åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼š&nbsp;<code>a<sub>prefix</sub></code>&nbsp;å’Œ&nbsp;<code>a<sub>suffix</sub></code>&nbsp;ï¼Œæ»¡è¶³&nbsp;<code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub>&nbsp;</sub>ï¼ŒåŒç†ï¼Œç”±&nbsp;<code>b</code> å¯ä»¥å¾—åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²&nbsp;<code>b<sub>prefix</sub></code> å’Œ&nbsp;<code>b<sub>suffix</sub></code>&nbsp;ï¼Œæ»¡è¶³&nbsp;<code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>&nbsp;ã€‚è¯·ä½ åˆ¤æ–­&nbsp;<code>a<sub>prefix</sub> + b<sub>suffix</sub></code> æˆ–è€…&nbsp;<code>b<sub>prefix</sub> + a<sub>suffix</sub></code>&nbsp;èƒ½å¦æ„æˆå›æ–‡ä¸²ã€‚</p>

<p>å½“ä½ å°†ä¸€ä¸ªå­—ç¬¦ä¸²&nbsp;<code>s</code>&nbsp;åˆ†å‰²æˆ&nbsp;<code>s<sub>prefix</sub></code> å’Œ&nbsp;<code>s<sub>suffix</sub></code>&nbsp;æ—¶ï¼Œ&nbsp;<code>s<sub>suffix</sub></code> æˆ–è€…&nbsp;<code>s<sub>prefix</sub></code> å¯ä»¥ä¸ºç©ºã€‚æ¯”æ–¹è¯´ï¼Œ&nbsp;<code>s = "abc"</code>&nbsp;é‚£ä¹ˆ&nbsp;<code>"" + "abc"</code>&nbsp;ï¼Œ&nbsp;<code>"a" + "bc"&nbsp;</code>ï¼Œ&nbsp;<code>"ab" + "c"</code>&nbsp;å’Œ&nbsp;<code>"abc" + ""</code>&nbsp;éƒ½æ˜¯åˆæ³•åˆ†å‰²ã€‚</p>

<p>å¦‚æœ <strong>èƒ½æ„æˆå›æ–‡å­—ç¬¦ä¸²</strong> ï¼Œé‚£ä¹ˆè¯·è¿”å›&nbsp;<code>true</code>ï¼Œå¦åˆ™è¿”å›<em>&nbsp;</em><code>false</code>&nbsp;ã€‚</p>

<p><strong>æ³¨æ„</strong>ï¼Œ&nbsp;<code>x + y</code>&nbsp;è¡¨ç¤ºè¿æ¥å­—ç¬¦ä¸²&nbsp;<code>x</code> å’Œ&nbsp;<code>y</code>&nbsp;ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>a = "x", b = "y"
<b>è¾“å‡ºï¼š</b>true
<b>è§£é‡Šï¼š</b>å¦‚æœ a æˆ–è€… b æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸€å®šä¸º true ï¼Œå› ä¸ºä½ å¯ä»¥å¦‚ä¸‹åˆ†å‰²ï¼š
a<sub>prefix</sub> = "", a<sub>suffix</sub> = "x"
b<sub>prefix</sub> = "", b<sub>suffix</sub> = "y"
é‚£ä¹ˆ a<sub>prefix</sub> + b<sub>suffix</sub> = "" + "y" = "y" æ˜¯å›æ–‡ä¸²ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>a = "xbdef", b = "xecab"
<strong>è¾“å‡ºï¼š</strong>false
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>a = "ulacfd", b = "jizalu"
<b>è¾“å‡ºï¼š</b>true
<b>è§£é‡Šï¼š</b>åœ¨ä¸‹æ ‡ä¸º 3 å¤„åˆ†å‰²ï¼š
a<sub>prefix</sub> = "ula", a<sub>suffix</sub> = "cfd"
b<sub>prefix</sub> = "jiz", b<sub>suffix</sub> = "alu"
é‚£ä¹ˆ a<sub>prefix</sub> + b<sub>suffix</sub> = "ula" + "alu" = "ulaalu" æ˜¯å›æ–‡ä¸²ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>
    <li><code>a.length == b.length</code></li>
    <li><code>a</code> å’Œ&nbsp;<code>b</code>&nbsp;éƒ½åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    bool checkPalindromeFormation(string a, string b) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public boolean checkPalindromeFormation(String a, String b) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def checkPalindromeFormation(self, a: str, b: str) -&gt; bool:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {string} a
 * @param {string} b
 * @return {boolean}
 */
var checkPalindromeFormation = function(a, b) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func checkPalindromeFormation(a string, b string) bool {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Try finding the largest prefix from a that matches a suffix in b</li>
<li>Try string matching</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>"x"
"y"
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>é¢˜ç›®è¦æ±‚ï¼šç»™å®šä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„å­—ç¬¦ä¸² <code>a</code> å’Œ <code>b</code>ï¼Œé€‰æ‹©ä¸€ä¸ªç›¸åŒçš„åˆ†å‰²ç‚¹ï¼Œå°†ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ†åˆ«åˆ†å‰²ä¸ºå‰åä¸¤éƒ¨åˆ†ï¼Œç„¶åäº¤æ¢å‰åéƒ¨åˆ†ç»„åˆæˆä¸¤ä¸ªæ–°å­—ç¬¦ä¸²ï¼š
- <code>aprefix + bsuffix</code>
- <code>bprefix + asuffix</code></p>

<p>åˆ¤æ–­è¿™ä¸¤ä¸ªæ–°å­—ç¬¦ä¸²ä¸­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å›æ–‡ä¸²ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
1. åˆ†å‰²ç‚¹å¯ä»¥åœ¨ä»»æ„ä½ç½®ï¼ˆåŒ…æ‹¬ä¸¤ç«¯ï¼Œå³å‰åéƒ¨åˆ†å¯ä»¥ä¸ºç©ºï¼‰
2. éœ€è¦æ£€æŸ¥ä¸¤ç§ç»„åˆæ–¹å¼
3. å­—ç¬¦ä¸²é•¿åº¦å¯è¾¾ 10^5ï¼Œéœ€è¦ O(n) æˆ– O(n log n) çš„ç®—æ³•</p>

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="æ ¸å¿ƒè§‚å¯Ÿ">æ ¸å¿ƒè§‚å¯Ÿ</h3>

<p>å½“æˆ‘ä»¬ç»„åˆ <code>aprefix + bsuffix</code> æ—¶ï¼š
- <code>aprefix</code> æ¥è‡ª <code>a</code> çš„å‰ç¼€
- <code>bsuffix</code> æ¥è‡ª <code>b</code> çš„åç¼€
- ç»„åˆåçš„å­—ç¬¦ä¸²é•¿åº¦ä¸ºåŸå­—ç¬¦ä¸²é•¿åº¦</p>

<p>è®¾å­—ç¬¦ä¸²é•¿åº¦ä¸º <code>n</code>ï¼Œåˆ†å‰²ç‚¹ä¸º <code>i</code>ï¼ˆ0 â‰¤ i â‰¤ nï¼‰ï¼š
- <code>aprefix = a[0:i]</code>, <code>asuffix = a[i:n]</code>
- <code>bprefix = b[0:i]</code>, <code>bsuffix = b[i:n]</code>
- ç»„åˆ1ï¼š<code>a[0:i] + b[i:n]</code>
- ç»„åˆ2ï¼š<code>b[0:i] + a[i:n]</code></p>

<h3 id="æ€è·¯ä¸€åŒæŒ‡é’ˆæ£€æŸ¥æ³•æœ€ä¼˜è§£">æ€è·¯ä¸€ï¼šåŒæŒ‡é’ˆæ£€æŸ¥æ³•ï¼ˆæœ€ä¼˜è§£ï¼‰</h3>

<p>æˆ‘ä»¬å¯ä»¥ä»ä¸¤ç«¯å‘ä¸­é—´æ£€æŸ¥ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„ä½ç½®ï¼Œç„¶åå°è¯•ç”¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¯¹åº”éƒ¨åˆ†æ¥å¼¥è¡¥ã€‚</p>

<p>å…·ä½“æ­¥éª¤ï¼š
1. æ£€æŸ¥ <code>aprefix + bsuffix</code> æ˜¯å¦å¯èƒ½ä¸ºå›æ–‡ï¼š
   - ä»ä¸¤ç«¯å‘ä¸­é—´æ¯”è¾ƒ <code>a</code> çš„å‰ç¼€å’Œ <code>b</code> çš„åç¼€
   - å½“é‡åˆ°å­—ç¬¦ä¸åŒ¹é…æ—¶ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼š
     a) ä½¿ç”¨ <code>a</code> çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
     b) ä½¿ç”¨ <code>b</code> çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
   - æ£€æŸ¥è¿™ä¸¤ç§æƒ…å†µçš„ä¸­é—´æ®µæ˜¯å¦ä¸ºå›æ–‡</p>

<ol start="2">
<li>åŒç†æ£€æŸ¥ <code>bprefix + asuffix</code></li>
</ol>

<p>æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)</p>

<h3 id="æ€è·¯äºŒä¸­å¿ƒæ‰©å±•æ³•">æ€è·¯äºŒï¼šä¸­å¿ƒæ‰©å±•æ³•</h3>

<p>å¯¹äºæ¯ä¸ªå¯èƒ½çš„åˆ†å‰²ç‚¹ï¼Œæ£€æŸ¥ç»„åˆåçš„å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡ã€‚ä½†ç›´æ¥æ£€æŸ¥æ‰€æœ‰åˆ†å‰²ç‚¹ä¼šè¾¾åˆ° O(nÂ²) å¤æ‚åº¦ï¼Œéœ€è¦ä¼˜åŒ–ã€‚</p>

<p>ä¼˜åŒ–æ–¹æ³•ï¼š
- é¢„å¤„ç†å­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°æœ€é•¿çš„å‰ååŒ¹é…éƒ¨åˆ†
- ç„¶åæ£€æŸ¥å‰©ä½™éƒ¨åˆ†æ˜¯å¦ä¸ºå›æ–‡</p>

<p>æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)</p>

<h3 id="æ€è·¯ä¸‰å­—ç¬¦ä¸²å“ˆå¸Œrabin-karp">æ€è·¯ä¸‰ï¼šå­—ç¬¦ä¸²å“ˆå¸Œï¼ˆRabin-Karpï¼‰</h3>

<p>ä½¿ç”¨å­—ç¬¦ä¸²å“ˆå¸Œå¯ä»¥åœ¨ O(1) æ—¶é—´å†…åˆ¤æ–­å­ä¸²æ˜¯å¦å›æ–‡ï¼Œä½†éœ€è¦é¢„å¤„ç†å‰ç¼€å“ˆå¸Œå’Œåç¼€å“ˆå¸Œã€‚</p>

<p>æ­¥éª¤ï¼š
1. è®¡ç®— <code>a</code> å’Œ <code>b</code> çš„å‰ç¼€å“ˆå¸Œå’Œåç¼€å“ˆå¸Œ
2. å¯¹äºæ¯ä¸ªåˆ†å‰²ç‚¹ï¼Œå¯ä»¥å¿«é€Ÿè®¡ç®—ç»„åˆå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼
3. åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡</p>

<p>æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(n)</p>

<hr />

<h2 id="è§£æ³•å®ç°">è§£æ³•å®ç°</h2>

<h3 id="è§£æ³•ä¸€åŒæŒ‡é’ˆæ£€æŸ¥æ³•æœ€ä¼˜è§£">è§£æ³•ä¸€ï¼šåŒæŒ‡é’ˆæ£€æŸ¥æ³•ï¼ˆæœ€ä¼˜è§£ï¼‰</h3>

<h4 id="æ€è·¯">æ€è·¯</h4>

<ol>
<li>å®šä¹‰è¾…åŠ©å‡½æ•° <code>checkPalindrome(a, b)</code>ï¼Œæ£€æŸ¥ <code>aprefix + bsuffix</code> æ˜¯å¦å¯èƒ½ä¸ºå›æ–‡</li>
<li>åœ¨å‡½æ•°ä¸­ï¼Œä»ä¸¤ç«¯å‘ä¸­é—´æ¯”è¾ƒï¼š
<ul>
<li>å¦‚æœæ‰€æœ‰å­—ç¬¦éƒ½åŒ¹é…ï¼Œç›´æ¥è¿”å› true</li>
<li>å½“é‡åˆ°ä¸åŒ¹é…æ—¶ï¼Œæ£€æŸ¥ <code>a[left:right+1]</code> æˆ– <code>b[left:right+1]</code> æ˜¯å¦ä¸ºå›æ–‡</li>
</ul></li>
<li>åˆ†åˆ«æ£€æŸ¥ä¸¤ç§ç»„åˆæ–¹å¼</li>
</ol>

<pre><code>// Go å®ç°
func checkPalindromeFormation(a string, b string) bool {
    // æ£€æŸ¥å­ä¸²æ˜¯å¦ä¸ºå›æ–‡
    isPalindrome := func(s string, left, right int) bool {
        for left &lt; right {
            if s[left] != s[right] {
                return false
            }
            left++
            right--
        }
        return true
    }

    // æ£€æŸ¥ a çš„å‰ç¼€å’Œ b çš„åç¼€ç»„åˆ
    check := func(a, b string) bool {
        left, right := 0, len(a)-1
        // ä»ä¸¤ç«¯å‘ä¸­é—´æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„ä½ç½®
        for left &lt; right &amp;&amp; a[left] == b[right] {
            left++
            right--
        }
        // å¦‚æœå…¨éƒ¨åŒ¹é…ï¼Œæˆ–è€…å‰©ä½™éƒ¨åˆ†æ˜¯å›æ–‡ï¼Œåˆ™æˆåŠŸ
        if left &gt;= right {
            return true
        }
        // å°è¯•ç”¨ a çš„å‰©ä½™éƒ¨åˆ†æˆ– b çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
        return isPalindrome(a, left, right) || isPalindrome(b, left, right)
    }

    return check(a, b) || check(b, a)
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
private:
    // æ£€æŸ¥å­ä¸²æ˜¯å¦ä¸ºå›æ–‡
    bool isPalindrome(const string&amp; s, int left, int right) {
        while (left &lt; right) {
            if (s[left] != s[right]) return false;
            left++;
            right--;
        }
        return true;
    }

    // æ£€æŸ¥ a çš„å‰ç¼€å’Œ b çš„åç¼€ç»„åˆ
    bool check(const string&amp; a, const string&amp; b) {
        int left = 0, right = a.length() - 1;
        // ä»ä¸¤ç«¯å‘ä¸­é—´æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„ä½ç½®
        while (left &lt; right &amp;&amp; a[left] == b[right]) {
            left++;
            right--;
        }
        // å¦‚æœå…¨éƒ¨åŒ¹é…ï¼Œæˆ–è€…å‰©ä½™éƒ¨åˆ†æ˜¯å›æ–‡ï¼Œåˆ™æˆåŠŸ
        if (left &gt;= right) return true;
        // å°è¯•ç”¨ a çš„å‰©ä½™éƒ¨åˆ†æˆ– b çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
        return isPalindrome(a, left, right) || isPalindrome(b, left, right);
    }

public:
    bool checkPalindromeFormation(string a, string b) {
        return check(a, b) || check(b, a);
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²æœ€å¤šéå†ä¸¤æ¬¡
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å¸¸æ•°ç©ºé—´</p>

<hr />

<h3 id="è§£æ³•äºŒä¸­å¿ƒæ‰©å±•æ³•">è§£æ³•äºŒï¼šä¸­å¿ƒæ‰©å±•æ³•</h3>

<h4 id="æ€è·¯-2">æ€è·¯</h4>

<ol>
<li>å…ˆæ‰¾åˆ° <code>a</code> å’Œ <code>b</code> çš„æœ€é•¿å…¬å…±å‰åç¼€</li>
<li>ç„¶åæ£€æŸ¥å‰©ä½™éƒ¨åˆ†æ˜¯å¦ä¸ºå›æ–‡</li>
<li>éœ€è¦è€ƒè™‘å››ç§æƒ…å†µï¼š
<ul>
<li><code>a</code> çš„å‰ç¼€ + <code>b</code> çš„åç¼€</li>
<li><code>b</code> çš„å‰ç¼€ + <code>a</code> çš„åç¼€</li>
<li>ä»¥åŠå®ƒä»¬å¯¹ç§°çš„æƒ…å†µ</li>
</ul></li>
</ol>

<pre><code>// Go å®ç°
func checkPalindromeFormation(a string, b string) bool {
    n := len(a)

    // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡
    isPalindrome := func(s string) bool {
        left, right := 0, len(s)-1
        for left &lt; right {
            if s[left] != s[right] {
                return false
            }
            left++
            right--
        }
        return true
    }

    // å¦‚æœ a æˆ– b æœ¬èº«å°±æ˜¯å›æ–‡ï¼Œç›´æ¥è¿”å› true
    if isPalindrome(a) || isPalindrome(b) {
        return true
    }

    // æ£€æŸ¥å››ç§æƒ…å†µ
    check := func(s1, s2 string) bool {
        // æ‰¾åˆ°ä»ä¸¤ç«¯å¼€å§‹åŒ¹é…çš„ä½ç½®
        left, right := 0, n-1
        for left &lt; right &amp;&amp; s1[left] == s2[right] {
            left++
            right--
        }

        if left &gt;= right {
            return true
        }

        // æ£€æŸ¥ s1[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        i, j := left, right
        for i &lt; j &amp;&amp; s1[i] == s1[j] {
            i++
            j--
        }
        if i &gt;= j {
            return true
        }

        // æ£€æŸ¥ s2[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        i, j = left, right
        for i &lt; j &amp;&amp; s2[i] == s2[j] {
            i++
            j--
        }
        return i &gt;= j
    }

    return check(a, b) || check(b, a)
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
private:
    bool isPalindrome(const string&amp; s) {
        int left = 0, right = s.length() - 1;
        while (left &lt; right) {
            if (s[left] != s[right]) return false;
            left++;
            right--;
        }
        return true;
    }

    bool check(const string&amp; s1, const string&amp; s2) {
        int n = s1.length();
        int left = 0, right = n - 1;

        // æ‰¾åˆ°ä»ä¸¤ç«¯å¼€å§‹åŒ¹é…çš„ä½ç½®
        while (left &lt; right &amp;&amp; s1[left] == s2[right]) {
            left++;
            right--;
        }

        if (left &gt;= right) return true;

        // æ£€æŸ¥ s1[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        int i = left, j = right;
        while (i &lt; j &amp;&amp; s1[i] == s1[j]) {
            i++;
            j--;
        }
        if (i &gt;= j) return true;

        // æ£€æŸ¥ s2[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        i = left, j = right;
        while (i &lt; j &amp;&amp; s2[i] == s2[j]) {
            i++;
            j--;
        }
        return i &gt;= j;
    }

public:
    bool checkPalindromeFormation(string a, string b) {
        if (isPalindrome(a) || isPalindrome(b)) return true;
        return check(a, b) || check(b, a);
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²æœ€å¤šéå†ä¸‰æ¬¡
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)</p>

<hr />

<h3 id="è§£æ³•ä¸‰å­—ç¬¦ä¸²å“ˆå¸Œæ³•">è§£æ³•ä¸‰ï¼šå­—ç¬¦ä¸²å“ˆå¸Œæ³•</h3>

<h4 id="æ€è·¯-3">æ€è·¯</h4>

<p>ä½¿ç”¨ Rabin-Karp å“ˆå¸Œç®—æ³•ï¼Œé¢„å¤„ç†å­—ç¬¦ä¸²çš„å‰ç¼€å“ˆå¸Œå’Œåç¼€å“ˆå¸Œï¼Œå¯ä»¥åœ¨ O(1) æ—¶é—´å†…åˆ¤æ–­ä»»æ„å­ä¸²æ˜¯å¦ä¸ºå›æ–‡ã€‚</p>

<pre><code>// Go å®ç°
func checkPalindromeFormation(a string, b string) bool {
    n := len(a)
    if n == 0 {
        return true
    }

    // è®¡ç®—å­—ç¬¦ä¸²çš„å“ˆå¸Œ
    computeHashes := func(s string) ([]uint64, []uint64) {
        base := uint64(131)
        prefix := make([]uint64, n+1)
        suffix := make([]uint64, n+1)
        pow := make([]uint64, n+1)
        pow[0] = 1

        for i := 1; i &lt;= n; i++ {
            prefix[i] = prefix[i-1]*base + uint64(s[i-1])
            pow[i] = pow[i-1] * base
        }

        for i := n - 1; i &gt;= 0; i-- {
            suffix[i] = suffix[i+1]*base + uint64(s[i])
        }

        return prefix, suffix
    }

    // æ£€æŸ¥å­ä¸²æ˜¯å¦ä¸ºå›æ–‡
    isPalindrome := func(prefix, suffix []uint64, pow []uint64, left, right int) bool {
        if left &gt;= right {
            return true
        }
        // æ­£åºå“ˆå¸Œ
        hash1 := prefix[right+1] - prefix[left]*pow[right-left+1]
        // é€†åºå“ˆå¸Œ
        hash2 := suffix[left] - suffix[right+1]*pow[right-left+1]
        return hash1 == hash2
    }

    // é¢„å¤„ç†å“ˆå¸Œ
    aPrefix, aSuffix := computeHashes(a)
    bPrefix, bSuffix := computeHashes(b)

    // è®¡ç®— pow æ•°ç»„
    pow := make([]uint64, n+1)
    pow[0] = 1
    base := uint64(131)
    for i := 1; i &lt;= n; i++ {
        pow[i] = pow[i-1] * base
    }

    // æ£€æŸ¥å‡½æ•°
    check := func(prefix1, suffix1, prefix2, suffix2 []uint64) bool {
        left, right := 0, n-1
        for left &lt; right {
            if isPalindrome(prefix1, suffix1, pow, left, right) || 
               isPalindrome(prefix2, suffix2, pow, left, right) {
                return true
            }
            // æ£€æŸ¥å½“å‰å­—ç¬¦æ˜¯å¦åŒ¹é…
            hash1 := prefix1[right+1] - prefix1[left]*pow[right-left+1]
            hash2 := suffix2[left] - suffix2[right+1]*pow[right-left+1]
            if hash1 != hash2 {
                break
            }
            left++
            right--
        }
        return left &gt;= right
    }

    // æ£€æŸ¥ä¸¤ç§æƒ…å†µ
    return check(aPrefix, aSuffix, bPrefix, bSuffix) || 
           check(bPrefix, bSuffix, aPrefix, aSuffix)
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
private:
    using ULL = unsigned long long;
    const ULL BASE = 131;

    vector&lt;ULL&gt; computePrefixHash(const string&amp; s) {
        int n = s.length();
        vector&lt;ULL&gt; prefix(n + 1, 0);
        for (int i = 1; i &lt;= n; i++) {
            prefix[i] = prefix[i-1] * BASE + s[i-1];
        }
        return prefix;
    }

    vector&lt;ULL&gt; computeSuffixHash(const string&amp; s) {
        int n = s.length();
        vector&lt;ULL&gt; suffix(n + 1, 0);
        for (int i = n - 1; i &gt;= 0; i--) {
            suffix[i] = suffix[i+1] * BASE + s[i];
        }
        return suffix;
    }

    bool isPalindrome(const vector&lt;ULL&gt;&amp; prefix, const vector&lt;ULL&gt;&amp; suffix, 
                     const vector&lt;ULL&gt;&amp; pow, int left, int right) {
        if (left &gt;= right) return true;
        ULL hash1 = prefix[right+1] - prefix[left] * pow[right-left+1];
        ULL hash2 = suffix[left] - suffix[right+1] * pow[right-left+1];
        return hash1 == hash2;
    }

public:
    bool checkPalindromeFormation(string a, string b) {
        int n = a.length();

        // é¢„å¤„ç†å“ˆå¸Œ
        auto aPrefix = computePrefixHash(a);
        auto aSuffix = computeSuffixHash(a);
        auto bPrefix = computePrefixHash(b);
        auto bSuffix = computeSuffixHash(b);

        // é¢„å¤„ç†å¹‚
        vector&lt;ULL&gt; pow(n + 1, 1);
        for (int i = 1; i &lt;= n; i++) {
            pow[i] = pow[i-1] * BASE;
        }

        // æ£€æŸ¥å‡½æ•°
        auto check = [&amp;](const vector&lt;ULL&gt;&amp; p1, const vector&lt;ULL&gt;&amp; s1,
                        const vector&lt;ULL&gt;&amp; p2, const vector&lt;ULL&gt;&amp; s2) -&gt; bool {
            int left = 0, right = n - 1;
            while (left &lt; right) {
                if (isPalindrome(p1, s1, pow, left, right) || 
                    isPalindrome(p2, s2, pow, left, right)) {
                    return true;
                }
                ULL hash1 = p1[right+1] - p1[left] * pow[right-left+1];
                ULL hash2 = s2[left] - s2[right+1] * pow[right-left+1];
                if (hash1 != hash2) break;
                left++;
                right--;
            }
            return left &gt;= right;
        };

        return check(aPrefix, aSuffix, bPrefix, bSuffix) || 
               check(bPrefix, bSuffix, aPrefix, aSuffix);
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œéœ€è¦é¢„å¤„ç†å“ˆå¸Œ
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œéœ€è¦å­˜å‚¨å“ˆå¸Œæ•°ç»„</p>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>ç‰¹æ€§</th>
  <th>è§£æ³•ä¸€ï¼šåŒæŒ‡é’ˆæ£€æŸ¥æ³•</th>
  <th>è§£æ³•äºŒï¼šä¸­å¿ƒæ‰©å±•æ³•</th>
  <th>è§£æ³•ä¸‰ï¼šå­—ç¬¦ä¸²å“ˆå¸Œæ³•</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æ—¶é—´å¤æ‚åº¦</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>O(n)</td>
</tr>
<tr>
  <td>ç©ºé—´å¤æ‚åº¦</td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(n)</td>
</tr>
<tr>
  <td>å®ç°éš¾åº¦</td>
  <td>ç®€å•</td>
  <td>ä¸­ç­‰</td>
  <td>å¤æ‚</td>
</tr>
<tr>
  <td>è¿è¡Œæ•ˆç‡</td>
  <td>é«˜</td>
  <td>é«˜</td>
  <td>ä¸­ç­‰</td>
</tr>
<tr>
  <td>é€‚ç”¨åœºæ™¯</td>
  <td>é€šç”¨</td>
  <td>é€šç”¨</td>
  <td>éœ€è¦å¤šæ¬¡æŸ¥è¯¢æ—¶</td>
</tr>
</tbody>
</table>

<p><strong>æ€»ç»“</strong>ï¼š
1. <strong>è§£æ³•ä¸€ï¼ˆåŒæŒ‡é’ˆæ£€æŸ¥æ³•ï¼‰</strong> æ˜¯æœ€ä¼˜è§£ï¼Œä»£ç ç®€æ´ï¼Œæ•ˆç‡é«˜ï¼Œç©ºé—´å¤æ‚åº¦ä½ï¼Œæ¨èä½¿ç”¨
2. <strong>è§£æ³•äºŒï¼ˆä¸­å¿ƒæ‰©å±•æ³•ï¼‰</strong> æ€è·¯æ¸…æ™°ï¼Œå®ç°ç›¸å¯¹ç®€å•ï¼Œä¹Ÿæ˜¯å¾ˆå¥½çš„é€‰æ‹©
3. <strong>è§£æ³•ä¸‰ï¼ˆå­—ç¬¦ä¸²å“ˆå¸Œæ³•ï¼‰</strong> è™½ç„¶ç†è®ºæ—¶é—´å¤æ‚åº¦ç›¸åŒï¼Œä½†å®ç°å¤æ‚ï¼Œå¸¸æ•°å› å­å¤§ï¼Œä¸”éœ€è¦é¢å¤–ç©ºé—´ï¼Œåœ¨æœ¬é¢˜ä¸­ä¸æ˜¯æœ€ä½³é€‰æ‹©</p>

<p>åœ¨å®é™…é¢è¯•æˆ–ç«èµ›ä¸­ï¼Œæ¨èä½¿ç”¨<strong>è§£æ³•ä¸€</strong>ï¼Œå®ƒç›´è§‚ä¸”é«˜æ•ˆï¼Œå®¹æ˜“ç†è§£å’Œå®ç°ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 16:17:38</em></p>

                </div>
            </div>

            <div class="footer">
                <p>ç”± <a href="https://github.com/LFrankl/leetcode" target="_blank">LeetCode Daily Script</a> è‡ªåŠ¨ç”Ÿæˆ</p>
                <p>AI è§£ç­”ç”± <a href="https://www.deepseek.com/" target="_blank">DeepSeek</a> æä¾›</p>
            </div>
        </div>
    </div>
</body>
</html>