<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 2026-02-26 06:00:00</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
        <div class="content">
            <h1>ğŸ“… 2026-02-26 06:00:00 æ¯æ—¥é¢˜ç›® (ç¬¬ 7 ç»„)</h1>
            <h1 id="879-ç›ˆåˆ©è®¡åˆ’">879. ç›ˆåˆ©è®¡åˆ’</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, åŠ¨æ€è§„åˆ’</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/profitable-schemes/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>é›†å›¢é‡Œæœ‰ <code>n</code> åå‘˜å·¥ï¼Œä»–ä»¬å¯ä»¥å®Œæˆå„ç§å„æ ·çš„å·¥ä½œåˆ›é€ åˆ©æ¶¦ã€‚</p>

<p>ç¬¬Â <code>i</code>Â ç§å·¥ä½œä¼šäº§ç”ŸÂ <code>profit[i]</code>Â çš„åˆ©æ¶¦ï¼Œå®ƒè¦æ±‚Â <code>group[i]</code>Â åæˆå‘˜å…±åŒå‚ä¸ã€‚å¦‚æœæˆå‘˜å‚ä¸äº†å…¶ä¸­ä¸€é¡¹å·¥ä½œï¼Œå°±ä¸èƒ½å‚ä¸å¦ä¸€é¡¹å·¥ä½œã€‚</p>

<p>å·¥ä½œçš„ä»»ä½•è‡³å°‘äº§ç”ŸÂ <code>minProfit</code> åˆ©æ¶¦çš„å­é›†ç§°ä¸º <strong>ç›ˆåˆ©è®¡åˆ’</strong> ã€‚å¹¶ä¸”å·¥ä½œçš„æˆå‘˜æ€»æ•°æœ€å¤šä¸º <code>n</code> ã€‚</p>

<p>æœ‰å¤šå°‘ç§è®¡åˆ’å¯ä»¥é€‰æ‹©ï¼Ÿå› ä¸ºç­”æ¡ˆå¾ˆå¤§ï¼Œæ‰€ä»¥<strong> è¿”å›ç»“æœæ¨¡Â </strong><code>10^9 + 7</code><strong>Â çš„å€¼</strong>ã€‚</p>

<div class="original__bRMd">
<div>
<p>Â </p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]
<strong>è¾“å‡ºï¼š</strong>2
<strong>è§£é‡Šï¼š</strong>è‡³å°‘äº§ç”Ÿ 3 çš„åˆ©æ¶¦ï¼Œè¯¥é›†å›¢å¯ä»¥å®Œæˆå·¥ä½œ 0 å’Œå·¥ä½œ 1 ï¼Œæˆ–ä»…å®Œæˆå·¥ä½œ 1 ã€‚
æ€»çš„æ¥è¯´ï¼Œæœ‰ä¸¤ç§è®¡åˆ’ã€‚</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
<strong>è¾“å‡ºï¼š</strong>7
<strong>è§£é‡Šï¼š</strong>è‡³å°‘äº§ç”Ÿ 5 çš„åˆ©æ¶¦ï¼Œåªè¦å®Œæˆå…¶ä¸­ä¸€ç§å·¥ä½œå°±è¡Œï¼Œæ‰€ä»¥è¯¥é›†å›¢å¯ä»¥å®Œæˆä»»ä½•å·¥ä½œã€‚
æœ‰ 7 ç§å¯èƒ½çš„è®¡åˆ’ï¼š(0)ï¼Œ(1)ï¼Œ(2)ï¼Œ(0,1)ï¼Œ(0,2)ï¼Œ(1,2)ï¼Œä»¥åŠ (0,1,2) ã€‚</pre>
</div>
</div>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 <= n <= 100</code></li>
    <li><code>0 <= minProfit <= 100</code></li>
    <li><code>1 <= group.length <= 100</code></li>
    <li><code>1 <= group[i] <= 100</code></li>
    <li><code>profit.length == group.length</code></li>
    <li><code>0 <= profit[i] <= 100</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -&gt; int:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @param {number} minProfit
 * @param {number[]} group
 * @param {number[]} profit
 * @return {number}
 */
var profitableSchemes = function(n, minProfit, group, profit) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func profitableSchemes(n int, minProfit int, group []int, profit []int) int {

}
</code></pre>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>5
3
[2,2]
[2,3]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”">AI è§£ç­”</h2>

<p><em>DeepSeek API æœªé…ç½®æˆ–è°ƒç”¨å¤±è´¥</em></p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 15:44:52</em></p>

<hr />

<h1 id="888-å…¬å¹³çš„ç³–æœäº¤æ¢">888. å…¬å¹³çš„ç³–æœäº¤æ¢</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, å“ˆå¸Œè¡¨, äºŒåˆ†æŸ¥æ‰¾, æ’åº</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/fair-candy-swap/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-2">é¢˜ç›®æè¿°</h2>

<p>çˆ±ä¸½ä¸å’Œé²å‹ƒæ‹¥æœ‰ä¸åŒæ€»æ•°é‡çš„ç³–æœã€‚ç»™ä½ ä¸¤ä¸ªæ•°ç»„ <code>aliceSizes</code> å’Œ <code>bobSizes</code> ï¼Œ<code>aliceSizes[i]</code> æ˜¯çˆ±ä¸½ä¸æ‹¥æœ‰çš„ç¬¬ <code>i</code> ç›’ç³–æœä¸­çš„ç³–æœæ•°é‡ï¼Œ<code>bobSizes[j]</code> æ˜¯é²å‹ƒæ‹¥æœ‰çš„ç¬¬ <code>j</code> ç›’ç³–æœä¸­çš„ç³–æœæ•°é‡ã€‚</p>

<p>ä¸¤äººæƒ³è¦äº’ç›¸äº¤æ¢ä¸€ç›’ç³–æœï¼Œè¿™æ ·åœ¨äº¤æ¢ä¹‹åï¼Œä»–ä»¬å°±å¯ä»¥æ‹¥æœ‰ç›¸åŒæ€»æ•°é‡çš„ç³–æœã€‚ä¸€ä¸ªäººæ‹¥æœ‰çš„ç³–æœæ€»æ•°é‡æ˜¯ä»–ä»¬æ¯ç›’ç³–æœæ•°é‡çš„æ€»å’Œã€‚</p>

<p>è¿”å›ä¸€ä¸ªæ•´æ•°æ•°ç»„ <code>answer</code>ï¼Œå…¶ä¸­ <code>answer[0]</code> æ˜¯çˆ±ä¸½ä¸å¿…é¡»äº¤æ¢çš„ç³–æœç›’ä¸­çš„ç³–æœçš„æ•°ç›®ï¼Œ<code>answer[1]</code> æ˜¯é²å‹ƒå¿…é¡»äº¤æ¢çš„ç³–æœç›’ä¸­çš„ç³–æœçš„æ•°ç›®ã€‚å¦‚æœå­˜åœ¨å¤šä¸ªç­”æ¡ˆï¼Œä½ å¯ä»¥è¿”å›å…¶ä¸­ <strong>ä»»ä½•ä¸€ä¸ª</strong> ã€‚é¢˜ç›®æµ‹è¯•ç”¨ä¾‹ä¿è¯å­˜åœ¨ä¸è¾“å…¥å¯¹åº”çš„ç­”æ¡ˆã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>aliceSizes = [1,1], bobSizes = [2,2]
<strong>è¾“å‡ºï¼š</strong>[1,2]
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>aliceSizes = [1,2], bobSizes = [2,3]
<strong>è¾“å‡ºï¼š</strong>[1,2]
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>aliceSizes = [2], bobSizes = [1,3]
<strong>è¾“å‡ºï¼š</strong>[2,3]
</pre>

<p><strong>ç¤ºä¾‹ 4ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>aliceSizes = [1,2,5], bobSizes = [2,4]
<strong>è¾“å‡ºï¼š</strong>[5,4]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= aliceSizes.length, bobSizes.length &lt;= 10<sup>4</sup></code></li>
    <li><code>1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 10<sup>5</sup></code></li>
    <li>çˆ±ä¸½ä¸å’Œé²å‹ƒçš„ç³–æœæ€»æ•°é‡ä¸åŒã€‚</li>
    <li>é¢˜ç›®æ•°æ®ä¿è¯å¯¹äºç»™å®šçš„è¾“å…¥è‡³å°‘å­˜åœ¨ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆã€‚</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-2">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-2">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; fairCandySwap(vector&lt;int&gt;&amp; aliceSizes, vector&lt;int&gt;&amp; bobSizes) {

    }
};
</code></pre>

<h3 id="java-2">Java</h3>

<pre><code>class Solution {
    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {

    }
}
</code></pre>

<h3 id="python3-2">Python3</h3>

<pre><code>class Solution:
    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -&gt; List[int]:

</code></pre>

<h3 id="javascript-2">JavaScript</h3>

<pre><code>/**
 * @param {number[]} aliceSizes
 * @param {number[]} bobSizes
 * @return {number[]}
 */
var fairCandySwap = function(aliceSizes, bobSizes) {

};
</code></pre>

<h3 id="go-2">Go</h3>

<pre><code>func fairCandySwap(aliceSizes []int, bobSizes []int) []int {

}
</code></pre>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-2">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>[1,1]
[2,2]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p><strong>é—®é¢˜æè¿°</strong>ï¼š
- çˆ±ä¸½ä¸å’Œé²å‹ƒå„æœ‰è‹¥å¹²ç›’ç³–æœï¼Œæ¯ç›’ç³–æœæ•°é‡ä¸åŒã€‚
- ä»–ä»¬æƒ³äº¤æ¢<strong>æ°å¥½ä¸€ç›’</strong>ç³–æœï¼Œä½¿å¾—äº¤æ¢åä¸¤äººç³–æœæ€»æ•°ç›¸ç­‰ã€‚
- é¢˜ç›®ä¿è¯è‡³å°‘å­˜åœ¨ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆã€‚
- è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º 2 çš„æ•°ç»„ <code>[a, b]</code>ï¼Œå…¶ä¸­ <code>a</code> æ˜¯çˆ±ä¸½ä¸ç»™å‡ºçš„ç³–æœæ•°ï¼Œ<code>b</code> æ˜¯é²å‹ƒç»™å‡ºçš„ç³–æœæ•°ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- è®¾çˆ±ä¸½ä¸åˆå§‹æ€»æ•°ä¸º <code>sumA</code>ï¼Œé²å‹ƒåˆå§‹æ€»æ•°ä¸º <code>sumB</code>ã€‚
- äº¤æ¢åï¼š<code>sumA - a + b = sumB - b + a</code>
- åŒ–ç®€å¾—ï¼š<code>sumA - sumB = 2a - 2b</code>
- å³ï¼š<code>a - b = (sumA - sumB) / 2</code>
- ä»¤ <code>diff = (sumA - sumB) / 2</code>ï¼Œåˆ™æˆ‘ä»¬éœ€è¦æ‰¾åˆ° <code>a</code> å’Œ <code>b</code> ä½¿å¾— <code>a = b + diff</code>ã€‚</p>

<hr />

<h2 id="è§£æ³•ä¸€å“ˆå¸Œè¡¨æ³•">è§£æ³•ä¸€ï¼šå“ˆå¸Œè¡¨æ³•</h2>

<p><strong>æ€è·¯</strong>ï¼š
1. è®¡ç®— <code>sumA</code> å’Œ <code>sumB</code>ï¼Œå¾—åˆ° <code>diff = (sumA - sumB) / 2</code>ã€‚
2. å°†é²å‹ƒçš„ç³–æœç›’æ•°é‡å­˜å…¥å“ˆå¸Œè¡¨ï¼ˆé›†åˆï¼‰ã€‚
3. éå†çˆ±ä¸½ä¸çš„ç³–æœç›’æ•°é‡ <code>a</code>ï¼Œæ£€æŸ¥ <code>b = a - diff</code> æ˜¯å¦åœ¨é²å‹ƒçš„é›†åˆä¸­ã€‚
4. æ‰¾åˆ°åè¿”å› <code>[a, b]</code>ã€‚</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n + m)<br />
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(m)ï¼ˆå­˜å‚¨é²å‹ƒçš„ç³–æœç›’é›†åˆï¼‰</p>

<h3 id="go-å®ç°">Go å®ç°</h3>

<pre><code>func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
    sumA, sumB := 0, 0
    for _, v := range aliceSizes {
        sumA += v
    }
    for _, v := range bobSizes {
        sumB += v
    }
    diff := (sumA - sumB) / 2

    setB := make(map[int]bool)
    for _, v := range bobSizes {
        setB[v] = true
    }

    for _, a := range aliceSizes {
        b := a - diff
        if setB[b] {
            return []int{a, b}
        }
    }
    return nil
}
</code></pre>

<h3 id="c-å®ç°">C++ å®ç°</h3>

<pre><code>#include &lt;vector&gt;
#include &lt;unordered_set&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; fairCandySwap(vector&lt;int&gt;&amp; aliceSizes, vector&lt;int&gt;&amp; bobSizes) {
        int sumA = 0, sumB = 0;
        for (int v : aliceSizes) sumA += v;
        for (int v : bobSizes) sumB += v;
        int diff = (sumA - sumB) / 2;

        unordered_set&lt;int&gt; setB(bobSizes.begin(), bobSizes.end());
        for (int a : aliceSizes) {
            int b = a - diff;
            if (setB.count(b)) {
                return {a, b};
            }
        }
        return {};
    }
};
</code></pre>

<hr />

<h2 id="è§£æ³•äºŒæ’åº-åŒæŒ‡é’ˆ">è§£æ³•äºŒï¼šæ’åº + åŒæŒ‡é’ˆ</h2>

<p><strong>æ€è·¯</strong>ï¼š
1. è®¡ç®— <code>diff = (sumA - sumB) / 2</code>ã€‚
2. å¯¹ <code>aliceSizes</code> å’Œ <code>bobSizes</code> æ’åºã€‚
3. åŒæŒ‡é’ˆéå†ä¸¤ä¸ªæ•°ç»„ï¼Œå¯»æ‰¾æ»¡è¶³ <code>a - b = diff</code> çš„ä¸€å¯¹ã€‚</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n log n + m log m)<br />
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼ˆä¸è€ƒè™‘æ’åºçš„æ ˆç©ºé—´ï¼‰</p>

<h3 id="go-å®ç°-2">Go å®ç°</h3>

<pre><code>func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
    sumA, sumB := 0, 0
    for _, v := range aliceSizes {
        sumA += v
    }
    for _, v := range bobSizes {
        sumB += v
    }
    diff := (sumA - sumB) / 2

    sort.Ints(aliceSizes)
    sort.Ints(bobSizes)

    i, j := 0, 0
    for i &lt; len(aliceSizes) &amp;&amp; j &lt; len(bobSizes) {
        d := aliceSizes[i] - bobSizes[j]
        if d == diff {
            return []int{aliceSizes[i], bobSizes[j]}
        } else if d &lt; diff {
            i++
        } else {
            j++
        }
    }
    return nil
}
</code></pre>

<h3 id="c-å®ç°-2">C++ å®ç°</h3>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; fairCandySwap(vector&lt;int&gt;&amp; aliceSizes, vector&lt;int&gt;&amp; bobSizes) {
        int sumA = 0, sumB = 0;
        for (int v : aliceSizes) sumA += v;
        for (int v : bobSizes) sumB += v;
        int diff = (sumA - sumB) / 2;

        sort(aliceSizes.begin(), aliceSizes.end());
        sort(bobSizes.begin(), bobSizes.end());

        int i = 0, j = 0;
        while (i &lt; aliceSizes.size() &amp;&amp; j &lt; bobSizes.size()) {
            int d = aliceSizes[i] - bobSizes[j];
            if (d == diff) {
                return {aliceSizes[i], bobSizes[j]};
            } else if (d &lt; diff) {
                i++;
            } else {
                j++;
            }
        }
        return {};
    }
};
</code></pre>

<hr />

<h2 id="è§£æ³•ä¸‰äºŒåˆ†æŸ¥æ‰¾">è§£æ³•ä¸‰ï¼šäºŒåˆ†æŸ¥æ‰¾</h2>

<p><strong>æ€è·¯</strong>ï¼š
1. è®¡ç®— <code>diff = (sumA - sumB) / 2</code>ã€‚
2. å¯¹é²å‹ƒçš„æ•°ç»„æ’åºã€‚
3. éå†çˆ±ä¸½ä¸çš„æ•°ç»„ï¼Œå¯¹æ¯ä¸ª <code>a</code>ï¼Œåœ¨é²å‹ƒæ•°ç»„ä¸­äºŒåˆ†æŸ¥æ‰¾ <code>b = a - diff</code>ã€‚</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(m log m + n log m)<br />
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼ˆä¸è€ƒè™‘æ’åºçš„æ ˆç©ºé—´ï¼‰</p>

<h3 id="go-å®ç°-3">Go å®ç°</h3>

<pre><code>func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
    sumA, sumB := 0, 0
    for _, v := range aliceSizes {
        sumA += v
    }
    for _, v := range bobSizes {
        sumB += v
    }
    diff := (sumA - sumB) / 2

    sort.Ints(bobSizes)

    for _, a := range aliceSizes {
        b := a - diff
        idx := sort.SearchInts(bobSizes, b)
        if idx &lt; len(bobSizes) &amp;&amp; bobSizes[idx] == b {
            return []int{a, b}
        }
    }
    return nil
}
</code></pre>

<h3 id="c-å®ç°-3">C++ å®ç°</h3>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; fairCandySwap(vector&lt;int&gt;&amp; aliceSizes, vector&lt;int&gt;&amp; bobSizes) {
        int sumA = 0, sumB = 0;
        for (int v : aliceSizes) sumA += v;
        for (int v : bobSizes) sumB += v;
        int diff = (sumA - sumB) / 2;

        sort(bobSizes.begin(), bobSizes.end());

        for (int a : aliceSizes) {
            int b = a - diff;
            if (binary_search(bobSizes.begin(), bobSizes.end(), b)) {
                return {a, b};
            }
        }
        return {};
    }
};
</code></pre>

<hr />

<h2 id="å¤æ‚åº¦å¯¹æ¯”">å¤æ‚åº¦å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>å“ˆå¸Œè¡¨æ³•</td>
  <td>O(n + m)</td>
  <td>O(m)</td>
  <td>æœ€å¿«ï¼Œä»£ç ç®€å•</td>
  <td>éœ€è¦é¢å¤–ç©ºé—´å­˜å‚¨å“ˆå¸Œè¡¨</td>
</tr>
<tr>
  <td>æ’åº+åŒæŒ‡é’ˆ</td>
  <td>O(n log n + m log m)</td>
  <td>O(1)</td>
  <td>ç©ºé—´æœ€ä¼˜</td>
  <td>æ’åºå¢åŠ æ—¶é—´å¤æ‚åº¦</td>
</tr>
<tr>
  <td>äºŒåˆ†æŸ¥æ‰¾</td>
  <td>O(m log m + n log m)</td>
  <td>O(1)</td>
  <td>ç©ºé—´è¾ƒä¼˜ï¼Œæ¯”åŒæŒ‡é’ˆç¨æ…¢</td>
  <td>éœ€è¦æ’åºï¼Œä¸”æŸ¥æ‰¾ç¨æ…¢</td>
</tr>
</tbody>
</table>

<hr />

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<ul>
<li><strong>å“ˆå¸Œè¡¨æ³•</strong>æ˜¯æœ€ç›´è§‚ä¸”æ•ˆç‡æœ€é«˜çš„è§£æ³•ï¼Œé€‚åˆæœ¬é¢˜æ•°æ®è§„æ¨¡ã€‚</li>
<li><strong>æ’åº+åŒæŒ‡é’ˆ</strong>åœ¨ç©ºé—´å—é™æ—¶æ›´ä¼˜ã€‚</li>
<li><strong>äºŒåˆ†æŸ¥æ‰¾</strong>æ˜¯å“ˆå¸Œè¡¨å’ŒåŒæŒ‡é’ˆçš„æŠ˜ä¸­æ–¹æ¡ˆã€‚</li>
</ul>

<p><strong>æ¨èä½¿ç”¨å“ˆå¸Œè¡¨æ³•</strong>ï¼Œå› ä¸ºå…¶æ—¶é—´å¤æ‚åº¦æœ€ä½ï¼Œä¸”ä»£ç ç®€æ´æ˜“æ‡‚ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:52:02</em></p>

<hr />

<h1 id="lcr-031-lru-ç¼“å­˜">LCR 031. LRU ç¼“å­˜</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: è®¾è®¡, å“ˆå¸Œè¡¨, é“¾è¡¨, åŒå‘é“¾è¡¨</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/OrIXps/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-3">é¢˜ç›®æè¿°</h2>

<div class="title__3Vvk">
<p>è¿ç”¨æ‰€æŒæ¡çš„æ•°æ®ç»“æ„ï¼Œè®¾è®¡å’Œå®ç°ä¸€ä¸ª&nbsp; <a href="https://baike.baidu.com/item/LRU" target="_blank">LRU (Least Recently Usedï¼Œæœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜æœºåˆ¶</a> ã€‚</p>

<p>å®ç° <code>LRUCache</code> ç±»ï¼š</p>

<ul>
    <li><code>LRUCache(int capacity)</code> ä»¥æ­£æ•´æ•°ä½œä¸ºå®¹é‡&nbsp;<code>capacity</code> åˆå§‹åŒ– LRU ç¼“å­˜</li>
    <li><code>int get(int key)</code> å¦‚æœå…³é”®å­— <code>key</code> å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› <code>-1</code> ã€‚</li>
    <li><code>void put(int key, int value)</code>&nbsp;å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ï¼›å¦‚æœå…³é”®å­—ä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥è¯¥ç»„ã€Œå…³é”®å­—-å€¼ã€ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ã€‚</li>
</ul>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ï¼š</strong></p>

<pre>
<strong>è¾“å…¥</strong>
[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>è¾“å‡º</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>è§£é‡Š</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // ç¼“å­˜æ˜¯ {1=1}
lRUCache.put(2, 2); // ç¼“å­˜æ˜¯ {1=1, 2=2}
lRUCache.get(1);    // è¿”å› 1
lRUCache.put(3, 3); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {1=1, 3=3}
lRUCache.get(2);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.put(4, 4); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {4=4, 3=3}
lRUCache.get(1);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.get(3);    // è¿”å› 3
lRUCache.get(4);    // è¿”å› 4
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= capacity &lt;= 3000</code></li>
    <li><code>0 &lt;= key &lt;= 10000</code></li>
    <li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
    <li>æœ€å¤šè°ƒç”¨ <code>2 * 10<sup>5</sup></code> æ¬¡ <code>get</code> å’Œ <code>put</code></li>
</ul>
</div>

<p>&nbsp;</p>

<p><strong>è¿›é˜¶</strong>ï¼šæ˜¯å¦å¯ä»¥åœ¨&nbsp;<code>O(1)</code> æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸¤ç§æ“ä½œï¼Ÿ</p>

<p>&nbsp;</p>

<p><meta charset="UTF-8" />æ³¨æ„ï¼šæœ¬é¢˜ä¸ä¸»ç«™ 146&nbsp;é¢˜ç›¸åŒï¼š<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a>&nbsp;</p>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-3">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-3">C++</h3>

<pre><code>class LRUCache {
public:
    LRUCache(int capacity) {

    }

    int get(int key) {

    }

    void put(int key, int value) {

    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */
</code></pre>

<h3 id="java-3">Java</h3>

<pre><code>class LRUCache {

    public LRUCache(int capacity) {

    }

    public int get(int key) {

    }

    public void put(int key, int value) {

    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
</code></pre>

<h3 id="python3-3">Python3</h3>

<pre><code>class LRUCache:

    def __init__(self, capacity: int):


    def get(self, key: int) -&gt; int:


    def put(self, key: int, value: int) -&gt; None:



# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
</code></pre>

<h3 id="javascript-3">JavaScript</h3>

<pre><code>/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {

};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {

};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {

};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
</code></pre>

<h3 id="go-3">Go</h3>

<pre><code>type LRUCache struct {

}


func Constructor(capacity int) LRUCache {

}


func (this *LRUCache) Get(key int) int {

}


func (this *LRUCache) Put(key int, value int)  {

}


/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
</code></pre>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-3">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>["LRUCache","put","put","get","put","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-2">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-2">é¢˜ç›®åˆ†æ</h2>

<p>LRUï¼ˆLeast Recently Usedï¼‰ç¼“å­˜æ˜¯ä¸€ç§å¸¸è§çš„ç¼“å­˜æ·˜æ±°ç­–ç•¥ï¼Œè¦æ±‚ï¼š
1. <strong>å¿«é€ŸæŸ¥æ‰¾</strong>ï¼šé€šè¿‡ key å¿«é€Ÿæ‰¾åˆ°å¯¹åº”çš„ value
2. <strong>å¿«é€Ÿæ’å…¥/åˆ é™¤</strong>ï¼šæ’å…¥æ–°æ•°æ®æˆ–åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®
3. <strong>ç»´æŠ¤è®¿é—®é¡ºåº</strong>ï¼šéœ€è¦çŸ¥é“å“ªä¸ªæ•°æ®æ˜¯æœ€è¿‘ä½¿ç”¨çš„ï¼Œå“ªä¸ªæ˜¯æœ€ä¹…æœªä½¿ç”¨çš„</p>

<p><strong>æ ¸å¿ƒéœ€æ±‚</strong>ï¼š
- <code>get(key)</code>ï¼šå¦‚æœ key å­˜åœ¨ï¼Œè¿”å› valueï¼Œå¹¶å°†è¯¥ key æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨
- <code>put(key, value)</code>ï¼š
  - å¦‚æœ key å­˜åœ¨ï¼Œæ›´æ–° valueï¼Œå¹¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨
  - å¦‚æœ key ä¸å­˜åœ¨ï¼Œæ’å…¥æ–°æ•°æ®
    - å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®
    - æ’å…¥æ–°æ•°æ®å¹¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨</p>

<p><strong>æ—¶é—´å¤æ‚åº¦è¦æ±‚</strong>ï¼šO(1) å®Œæˆ get å’Œ put æ“ä½œ</p>

<hr />

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="å…³é”®æ•°æ®ç»“æ„é€‰æ‹©">å…³é”®æ•°æ®ç»“æ„é€‰æ‹©</h3>

<ol>
<li><strong>å“ˆå¸Œè¡¨</strong>ï¼šæä¾› O(1) çš„æŸ¥æ‰¾èƒ½åŠ›</li>
<li><strong>åŒå‘é“¾è¡¨</strong>ï¼šç»´æŠ¤è®¿é—®é¡ºåºï¼Œå¤´éƒ¨æ˜¯æœ€è¿‘ä½¿ç”¨çš„ï¼Œå°¾éƒ¨æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„
<ul>
<li>åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥æ–°èŠ‚ç‚¹æˆ–ç§»åŠ¨èŠ‚ç‚¹</li>
<li>ä»é“¾è¡¨å°¾éƒ¨åˆ é™¤èŠ‚ç‚¹</li>
<li>ç§»åŠ¨èŠ‚ç‚¹åˆ°å¤´éƒ¨éœ€è¦ O(1) æ—¶é—´</li>
</ul></li>
</ol>

<h3 id="æ•°æ®ç»“æ„ç»„åˆ">æ•°æ®ç»“æ„ç»„åˆ</h3>

<ul>
<li><strong>å“ˆå¸Œè¡¨</strong>ï¼š<code>map[key] -&gt; é“¾è¡¨èŠ‚ç‚¹æŒ‡é’ˆ</code></li>
<li><strong>åŒå‘é“¾è¡¨</strong>ï¼šèŠ‚ç‚¹åŒ…å« <code>key, value, prev, next</code></li>
<li>æ“ä½œï¼š
<ul>
<li><code>get(key)</code>ï¼šé€šè¿‡å“ˆå¸Œè¡¨æ‰¾åˆ°èŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨</li>
<li><code>put(key, value)</code>ï¼š
<ul>
<li>å¦‚æœ key å­˜åœ¨ï¼šæ›´æ–° valueï¼ŒèŠ‚ç‚¹ç§»åˆ°å¤´éƒ¨</li>
<li>å¦‚æœ key ä¸å­˜åœ¨ï¼š
<ul>
<li>å¦‚æœå®¹é‡å·²æ»¡ï¼šåˆ é™¤é“¾è¡¨å°¾éƒ¨èŠ‚ç‚¹ï¼Œä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤å¯¹åº” key</li>
<li>åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œæ’å…¥é“¾è¡¨å¤´éƒ¨ï¼ŒåŠ å…¥å“ˆå¸Œè¡¨</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<hr />

<h2 id="è§£æ³•ä¸€å“ˆå¸Œè¡¨-è‡ªå®šä¹‰åŒå‘é“¾è¡¨">è§£æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + è‡ªå®šä¹‰åŒå‘é“¾è¡¨</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<p>æ‰‹åŠ¨å®ç°åŒå‘é“¾è¡¨ï¼Œæ˜ç¡®æ§åˆ¶èŠ‚ç‚¹çš„æ’å…¥ã€åˆ é™¤å’Œç§»åŠ¨æ“ä½œã€‚</p>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-4">Go å®ç°</h4>

<pre><code>type LRUCache struct {
    capacity int
    cache    map[int]*DLinkedNode
    head     *DLinkedNode
    tail     *DLinkedNode
}

type DLinkedNode struct {
    key   int
    value int
    prev  *DLinkedNode
    next  *DLinkedNode
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*DLinkedNode),
        head:     &amp;DLinkedNode{key: 0, value: 0},
        tail:     &amp;DLinkedNode{key: 0, value: 0},
    }
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
        return
    }

    if len(this.cache) &gt;= this.capacity {
        removed := this.removeTail()
        delete(this.cache, removed.key)
    }

    newNode := &amp;DLinkedNode{key: key, value: value}
    this.cache[key] = newNode
    this.addToHead(newNode)
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
    node := this.tail.prev
    this.removeNode(node)
    return node
}
</code></pre>

<h4 id="c-å®ç°-4">C++ å®ç°</h4>

<pre><code>class LRUCache {
private:
    struct DLinkedNode {
        int key, value;
        DLinkedNode* prev;
        DLinkedNode* next;
        DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
        DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
    };

    unordered_map&lt;int, DLinkedNode*&gt; cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int capacity;
    int size;

    void addToHead(DLinkedNode* node) {
        node-&gt;prev = head;
        node-&gt;next = head-&gt;next;
        head-&gt;next-&gt;prev = node;
        head-&gt;next = node;
    }

    void removeNode(DLinkedNode* node) {
        node-&gt;prev-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = node-&gt;prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail-&gt;prev;
        removeNode(node);
        return node;
    }

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }

    int get(int key) {
        if (!cache.count(key)) return -1;
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node-&gt;value;
    }

    void put(int key, int value) {
        if (cache.count(key)) {
            DLinkedNode* node = cache[key];
            node-&gt;value = value;
            moveToHead(node);
            return;
        }

        if (size == capacity) {
            DLinkedNode* removed = removeTail();
            cache.erase(removed-&gt;key);
            delete removed;
            size--;
        }

        DLinkedNode* newNode = new DLinkedNode(key, value);
        cache[key] = newNode;
        addToHead(newNode);
        size++;
    }

    ~LRUCache() {
        for (auto&amp; pair : cache) {
            delete pair.second;
        }
        delete head;
        delete tail;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)
<ul>
<li>get å’Œ put æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´</li>
<li>å“ˆå¸Œè¡¨æ“ä½œ O(1)ï¼Œé“¾è¡¨æ“ä½œ O(1)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(capacity)
<ul>
<li>å“ˆå¸Œè¡¨å’Œé“¾è¡¨å­˜å‚¨ capacity ä¸ªå…ƒç´ </li>
</ul></li>
</ul>

<hr />

<h2 id="è§£æ³•äºŒä½¿ç”¨-stlcæˆ–-containerlistgo">è§£æ³•äºŒï¼šä½¿ç”¨ STLï¼ˆC++ï¼‰æˆ– container/listï¼ˆGoï¼‰</h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<p>åˆ©ç”¨è¯­è¨€æ ‡å‡†åº“ä¸­çš„åŒå‘é“¾è¡¨å’Œå“ˆå¸Œè¡¨ï¼Œå‡å°‘æ‰‹åŠ¨é“¾è¡¨æ“ä½œã€‚</p>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°ä½¿ç”¨-containerlist">Go å®ç°ï¼ˆä½¿ç”¨ container/listï¼‰</h4>

<pre><code>import "container/list"

type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
}

type entry struct {
    key   int
    value int
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (this *LRUCache) Get(key int) int {
    if elem, ok := this.cache[key]; ok {
        this.list.MoveToFront(elem)
        return elem.Value.(*entry).value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if elem, ok := this.cache[key]; ok {
        elem.Value.(*entry).value = value
        this.list.MoveToFront(elem)
        return
    }

    if this.list.Len() &gt;= this.capacity {
        back := this.list.Back()
        delete(this.cache, back.Value.(*entry).key)
        this.list.Remove(back)
    }

    newEntry := &amp;entry{key: key, value: value}
    elem := this.list.PushFront(newEntry)
    this.cache[key] = elem
}
</code></pre>

<h4 id="c-å®ç°ä½¿ç”¨-stl">C++ å®ç°ï¼ˆä½¿ç”¨ STLï¼‰</h4>

<pre><code>class LRUCache {
private:
    int capacity;
    list&lt;pair&lt;int, int&gt;&gt; cacheList;
    unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cacheMap;

public:
    LRUCache(int _capacity): capacity(_capacity) {}

    int get(int key) {
        if (cacheMap.find(key) == cacheMap.end()) return -1;

        auto it = cacheMap[key];
        int value = it-&gt;second;

        cacheList.erase(it);
        cacheList.push_front({key, value});
        cacheMap[key] = cacheList.begin();

        return value;
    }

    void put(int key, int value) {
        if (cacheMap.find(key) != cacheMap.end()) {
            cacheList.erase(cacheMap[key]);
        } else if (cacheList.size() == capacity) {
            auto last = cacheList.back();
            cacheMap.erase(last.first);
            cacheList.pop_back();
        }

        cacheList.push_front({key, value});
        cacheMap[key] = cacheList.begin();
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-2">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)
<ul>
<li>æ‰€æœ‰æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(capacity)
<ul>
<li>å­˜å‚¨ capacity ä¸ªå…ƒç´ </li>
</ul></li>
</ul>

<hr />

<h2 id="è§£æ³•ä¸‰ä½¿ç”¨-linkedhashmapjava-é£æ ¼æ€è·¯">è§£æ³•ä¸‰ï¼šä½¿ç”¨ LinkedHashMapï¼ˆJava é£æ ¼æ€è·¯ï¼‰</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<p>æŸäº›è¯­è¨€ï¼ˆå¦‚ Javaï¼‰æœ‰å†…ç½®çš„ LinkedHashMap å¯ä»¥ç›´æ¥å®ç° LRUã€‚è¿™é‡Œç”¨ Go æ¨¡æ‹Ÿç±»ä¼¼ç»“æ„ã€‚</p>

<h3 id="go-å®ç°ç®€åŒ–ç‰ˆ">Go å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰</h3>

<pre><code>type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
    mu       sync.RWMutex // å¦‚æœè€ƒè™‘å¹¶å‘
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (lru *LRUCache) Get(key int) int {
    lru.mu.RLock()
    elem, ok := lru.cache[key]
    lru.mu.RUnlock()

    if !ok {
        return -1
    }

    lru.mu.Lock()
    lru.list.MoveToFront(elem)
    value := elem.Value.(*entry).value
    lru.mu.Unlock()

    return value
}

func (lru *LRUCache) Put(key int, value int) {
    lru.mu.Lock()
    defer lru.mu.Unlock()

    if elem, ok := lru.cache[key]; ok {
        elem.Value.(*entry).value = value
        lru.list.MoveToFront(elem)
        return
    }

    if lru.list.Len() &gt;= lru.capacity {
        back := lru.list.Back()
        delete(lru.cache, back.Value.(*entry).key)
        lru.list.Remove(back)
    }

    newEntry := &amp;entry{key: key, value: value}
    elem := lru.list.PushFront(newEntry)
    lru.cache[key] = elem
}
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-3">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(capacity)</li>
</ul>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>ç‰¹æ€§</th>
  <th>è§£æ³•ä¸€ï¼ˆè‡ªå®šä¹‰é“¾è¡¨ï¼‰</th>
  <th>è§£æ³•äºŒï¼ˆæ ‡å‡†åº“ï¼‰</th>
  <th>è§£æ³•ä¸‰ï¼ˆå¹¶å‘å®‰å…¨ï¼‰</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>å®ç°å¤æ‚åº¦</strong></td>
  <td>è¾ƒé«˜ï¼Œéœ€è¦æ‰‹åŠ¨ç®¡ç†é“¾è¡¨</td>
  <td>è¾ƒä½ï¼Œåˆ©ç”¨æ ‡å‡†åº“</td>
  <td>ä¸­ç­‰ï¼Œæ·»åŠ é”æœºåˆ¶</td>
</tr>
<tr>
  <td><strong>æ€§èƒ½</strong></td>
  <td>æœ€ä¼˜ï¼Œæ— é¢å¤–å¼€é”€</td>
  <td>ç¨æ…¢ï¼Œæœ‰æ¥å£è°ƒç”¨å¼€é”€</td>
  <td>æœ€æ…¢ï¼Œæœ‰é”å¼€é”€</td>
</tr>
<tr>
  <td><strong>å¯è¯»æ€§</strong></td>
  <td>è¾ƒä½ï¼Œä»£ç é‡å¤§</td>
  <td>è¾ƒé«˜ï¼Œä»£ç ç®€æ´</td>
  <td>ä¸­ç­‰</td>
</tr>
<tr>
  <td><strong>æ‰©å±•æ€§</strong></td>
  <td>é«˜ï¼Œå®Œå…¨å¯æ§</td>
  <td>ä½ï¼Œå—é™äºåº“åŠŸèƒ½</td>
  <td>é«˜ï¼Œå¯æ‰©å±•å¹¶å‘</td>
</tr>
<tr>
  <td><strong>é€‚ç”¨åœºæ™¯</strong></td>
  <td>æ€§èƒ½è¦æ±‚æé«˜</td>
  <td>å¿«é€Ÿå®ç°ï¼Œä»£ç ç®€æ´</td>
  <td>å¹¶å‘ç¯å¢ƒ</td>
</tr>
</tbody>
</table>

<h3 id="æ¨èæ–¹æ¡ˆ">æ¨èæ–¹æ¡ˆ</h3>

<ol>
<li><strong>é¢è¯•/ç«èµ›</strong>ï¼šè§£æ³•ä¸€ï¼Œå±•ç¤ºå¯¹æ•°æ®ç»“æ„çš„æ·±å…¥ç†è§£</li>
<li><strong>ç”Ÿäº§ç¯å¢ƒ</strong>ï¼šè§£æ³•äºŒï¼Œä»£ç ç®€æ´æ˜“ç»´æŠ¤</li>
<li><strong>å¹¶å‘ç¯å¢ƒ</strong>ï¼šè§£æ³•ä¸‰ï¼Œæ·»åŠ é€‚å½“çš„åŒæ­¥æœºåˆ¶</li>
</ol>

<h3 id="å…³é”®ç‚¹æ€»ç»“">å…³é”®ç‚¹æ€»ç»“</h3>

<ol>
<li><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼šå“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨</li>
<li><strong>O(1) æ“ä½œ</strong>ï¼šå“ˆå¸Œè¡¨æŸ¥æ‰¾ O(1)ï¼Œé“¾è¡¨æ’å…¥/åˆ é™¤ O(1)</li>
<li><strong>ç»´æŠ¤é¡ºåº</strong>ï¼šæœ€è¿‘ä½¿ç”¨çš„æ”¾å¤´éƒ¨ï¼Œæœ€ä¹…æœªä½¿ç”¨çš„åœ¨å°¾éƒ¨</li>
<li><strong>å®¹é‡ç®¡ç†</strong>ï¼šæ’å…¥æ—¶æ£€æŸ¥å®¹é‡ï¼Œæ»¡åˆ™åˆ é™¤å°¾éƒ¨èŠ‚ç‚¹</li>
</ol>

<p>æ‰€æœ‰è§£æ³•éƒ½èƒ½æ»¡è¶³ O(1) æ—¶é—´å¤æ‚åº¦è¦æ±‚ï¼Œé€‰æ‹©å“ªç§å–å†³äºå…·ä½“éœ€æ±‚å’Œç¯å¢ƒã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 15:50:14</em></p>

<hr />

<h1 id="lcr-112-çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„">LCR 112. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: æ·±åº¦ä¼˜å…ˆæœç´¢, å¹¿åº¦ä¼˜å…ˆæœç´¢, å›¾, æ‹“æ‰‘æ’åº, è®°å¿†åŒ–, æ•°ç»„, åŠ¨æ€è§„åˆ’, çŸ©é˜µ</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/fpTFWP/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-4">é¢˜ç›®æè¿°</h2>

<p>ç»™å®šä¸€ä¸ª&nbsp;<code>m x n</code> æ•´æ•°çŸ©é˜µ&nbsp;<code>matrix</code> ï¼Œæ‰¾å‡ºå…¶ä¸­ <strong>æœ€é•¿é€’å¢è·¯å¾„</strong> çš„é•¿åº¦ã€‚</p>

<p>å¯¹äºæ¯ä¸ªå•å…ƒæ ¼ï¼Œä½ å¯ä»¥å¾€ä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³å››ä¸ªæ–¹å‘ç§»åŠ¨ã€‚ <strong>ä¸èƒ½</strong> åœ¨ <strong>å¯¹è§’çº¿</strong> æ–¹å‘ä¸Šç§»åŠ¨æˆ–ç§»åŠ¨åˆ° <strong>è¾¹ç•Œå¤–</strong>ï¼ˆå³ä¸å…è®¸ç¯ç»•ï¼‰ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" /></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>è¾“å‡ºï¼š</strong>4 
<strong>è§£é‡Šï¼š</strong>æœ€é•¿é€’å¢è·¯å¾„ä¸º&nbsp;<code>[1, 2, 6, 9]</code>ã€‚</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" /></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>è¾“å‡ºï¼š</strong>4 
<strong>è§£é‡Šï¼š</strong>æœ€é•¿é€’å¢è·¯å¾„æ˜¯&nbsp;<code>[3, 4, 5, 6]</code>ã€‚æ³¨æ„ä¸å…è®¸åœ¨å¯¹è§’çº¿æ–¹å‘ä¸Šç§»åŠ¨ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>matrix = [[1]]
<strong>è¾“å‡ºï¼š</strong>1
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>m == matrix.length</code></li>
    <li><code>n == matrix[i].length</code></li>
    <li><code>1 &lt;= m, n &lt;= 200</code></li>
    <li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>

<p><meta charset="UTF-8" />æ³¨æ„ï¼šæœ¬é¢˜ä¸ä¸»ç«™ 329&nbsp;é¢˜ç›¸åŒï¼š&nbsp;<a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/</a></p>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-4">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-4">C++</h3>

<pre><code>class Solution {
public:
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {

    }
};
</code></pre>

<h3 id="java-4">Java</h3>

<pre><code>class Solution {
    public int longestIncreasingPath(int[][] matrix) {

    }
}
</code></pre>

<h3 id="python3-4">Python3</h3>

<pre><code>class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -&gt; int:
</code></pre>

<h3 id="javascript-4">JavaScript</h3>

<pre><code>/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {

};
</code></pre>

<h3 id="go-4">Go</h3>

<pre><code>func longestIncreasingPath(matrix [][]int) int {

}
</code></pre>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-4">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>[[9,9,4],[6,6,8],[2,1,1]]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-2">AI è§£ç­”</h2>

<p><em>DeepSeek API æœªé…ç½®æˆ–è°ƒç”¨å¤±è´¥</em></p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 15:19:43</em></p>

        </div>
    </div>
</body>
</html>