<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 2026-02-26 00:00:00</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
        <div class="content">
            <h1>ğŸ“… 2026-02-26 00:00:00 æ¯æ—¥é¢˜ç›® (ç¬¬ 1 ç»„)</h1>
            <h1 id="1184-å…¬äº¤ç«™é—´çš„è·ç¦»">1184. å…¬äº¤ç«™é—´çš„è·ç¦»</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/distance-between-bus-stops/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç¯å½¢å…¬äº¤è·¯çº¿ä¸Šæœ‰&nbsp;<code>n</code>&nbsp;ä¸ªç«™ï¼ŒæŒ‰æ¬¡åºä»&nbsp;<code>0</code>&nbsp;åˆ°&nbsp;<code>n - 1</code>&nbsp;è¿›è¡Œç¼–å·ã€‚æˆ‘ä»¬å·²çŸ¥æ¯ä¸€å¯¹ç›¸é‚»å…¬äº¤ç«™ä¹‹é—´çš„è·ç¦»ï¼Œ<code>distance[i]</code>&nbsp;è¡¨ç¤ºç¼–å·ä¸º&nbsp;<code>i</code>&nbsp;çš„è½¦ç«™å’Œç¼–å·ä¸º&nbsp;<code>(i + 1) % n</code>&nbsp;çš„è½¦ç«™ä¹‹é—´çš„è·ç¦»ã€‚</p>

<p>ç¯çº¿ä¸Šçš„å…¬äº¤è½¦éƒ½å¯ä»¥æŒ‰é¡ºæ—¶é’ˆå’Œé€†æ—¶é’ˆçš„æ–¹å‘è¡Œé©¶ã€‚</p>

<p>è¿”å›ä¹˜å®¢ä»å‡ºå‘ç‚¹&nbsp;<code>start</code>&nbsp;åˆ°ç›®çš„åœ°&nbsp;<code>destination</code>&nbsp;ä¹‹é—´çš„æœ€çŸ­è·ç¦»ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg" style="height: 240px; width: 388px;"></p>

<pre><strong>è¾“å…¥ï¼š</strong>distance = [1,2,3,4], start = 0, destination = 1
<strong>è¾“å‡ºï¼š</strong>1
<strong>è§£é‡Šï¼š</strong>å…¬äº¤ç«™ 0 å’Œ 1 ä¹‹é—´çš„è·ç¦»æ˜¯ 1 æˆ– 9ï¼Œæœ€å°å€¼æ˜¯ 1ã€‚</pre>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg" style="height: 240px; width: 388px;"></p>

<pre><strong>è¾“å…¥ï¼š</strong>distance = [1,2,3,4], start = 0, destination = 2
<strong>è¾“å‡ºï¼š</strong>3
<strong>è§£é‡Šï¼š</strong>å…¬äº¤ç«™ 0 å’Œ 2 ä¹‹é—´çš„è·ç¦»æ˜¯ 3 æˆ– 7ï¼Œæœ€å°å€¼æ˜¯ 3ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg" style="height: 240px; width: 388px;"></p>

<pre><strong>è¾“å…¥ï¼š</strong>distance = [1,2,3,4], start = 0, destination = 3
<strong>è¾“å‡ºï¼š</strong>4
<strong>è§£é‡Šï¼š</strong>å…¬äº¤ç«™ 0 å’Œ 3 ä¹‹é—´çš„è·ç¦»æ˜¯ 6 æˆ– 4ï¼Œæœ€å°å€¼æ˜¯ 4ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= n&nbsp;&lt;= 10^4</code></li>
    <li><code>distance.length == n</code></li>
    <li><code>0 &lt;= start, destination &lt; n</code></li>
    <li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public int distanceBetweenBusStops(int[] distance, int start, int destination) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -&gt; int:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number[]} distance
 * @param {number} start
 * @param {number} destination
 * @return {number}
 */
var distanceBetweenBusStops = function(distance, start, destination) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func distanceBetweenBusStops(distance []int, start int, destination int) int {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Find the distance between the two stops if the bus moved in clockwise or counterclockwise directions.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>[1,2,3,4]
0
1
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ªç¯å½¢å…¬äº¤è·¯çº¿é—®é¢˜ï¼š
- æœ‰ n ä¸ªè½¦ç«™ï¼ˆ0 åˆ° n-1ï¼‰
- distance[i] è¡¨ç¤ºè½¦ç«™ i åˆ°è½¦ç«™ (i+1)%n çš„è·ç¦»
- å…¬äº¤è½¦å¯ä»¥é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆè¡Œé©¶
- æ±‚ä» start åˆ° destination çš„æœ€çŸ­è·ç¦»</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
1. ç¯å½¢è·¯çº¿æœ‰ä¸¤ç§èµ°æ³•ï¼šé¡ºæ—¶é’ˆå’Œé€†æ—¶é’ˆ
2. é¡ºæ—¶é’ˆè·ç¦» + é€†æ—¶é’ˆè·ç¦» = ç¯å½¢æ€»è·ç¦»
3. æœ€çŸ­è·ç¦» = min(é¡ºæ—¶é’ˆè·ç¦», æ€»è·ç¦» - é¡ºæ—¶é’ˆè·ç¦»)</p>

<hr />

<h2 id="è§£æ³•ä¸€ç›´æ¥è®¡ç®—ä¸¤ç§è·ç¦»">è§£æ³•ä¸€ï¼šç›´æ¥è®¡ç®—ä¸¤ç§è·ç¦»</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<ol>
<li>å…ˆè®¡ç®—ä» start åˆ° destination çš„é¡ºæ—¶é’ˆè·ç¦»</li>
<li>è®¡ç®—ç¯å½¢æ€»è·ç¦»</li>
<li>é€†æ—¶é’ˆè·ç¦» = æ€»è·ç¦» - é¡ºæ—¶é’ˆè·ç¦»</li>
<li>è¿”å›ä¸¤è€…ä¸­çš„è¾ƒå°å€¼</li>
</ol>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>func distanceBetweenBusStops(distance []int, start int, destination int) int {
    if start &gt; destination {
        start, destination = destination, start
    }

    total := 0
    for _, d := range distance {
        total += d
    }

    clockwise := 0
    for i := start; i &lt; destination; i++ {
        clockwise += distance[i]
    }

    counterClockwise := total - clockwise
    if clockwise &lt; counterClockwise {
        return clockwise
    }
    return counterClockwise
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {
        if (start &gt; destination) {
            swap(start, destination);
        }

        int total = 0;
        for (int d : distance) {
            total += d;
        }

        int clockwise = 0;
        for (int i = start; i &lt; destination; i++) {
            clockwise += distance[i];
        }

        int counterClockwise = total - clockwise;
        return min(clockwise, counterClockwise);
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œéœ€è¦éå†æ•°ç»„ä¸¤æ¬¡ï¼ˆä¸€æ¬¡è®¡ç®—æ€»è·ç¦»ï¼Œä¸€æ¬¡è®¡ç®—é¡ºæ—¶é’ˆè·ç¦»ï¼‰</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å¸¸æ•°ä¸ªé¢å¤–å˜é‡</li>
</ul>

<hr />

<h2 id="è§£æ³•äºŒå•æ¬¡éå†åŒæ—¶è®¡ç®—">è§£æ³•äºŒï¼šå•æ¬¡éå†åŒæ—¶è®¡ç®—</h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<p>åœ¨ä¸€æ¬¡éå†ä¸­åŒæ—¶è®¡ç®—ï¼š
1. æ€»è·ç¦»
2. ä» start åˆ° destination çš„é¡ºæ—¶é’ˆè·ç¦»
è¿™æ ·å¯ä»¥å‡å°‘ä¸€æ¬¡éå†</p>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-2">Go å®ç°</h4>

<pre><code>func distanceBetweenBusStops(distance []int, start int, destination int) int {
    if start &gt; destination {
        start, destination = destination, start
    }

    total := 0
    clockwise := 0

    for i, d := range distance {
        total += d
        if i &gt;= start &amp;&amp; i &lt; destination {
            clockwise += d
        }
    }

    counterClockwise := total - clockwise
    if clockwise &lt; counterClockwise {
        return clockwise
    }
    return counterClockwise
}
</code></pre>

<h4 id="c-å®ç°-2">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {
        if (start &gt; destination) {
            swap(start, destination);
        }

        int total = 0;
        int clockwise = 0;

        for (int i = 0; i &lt; distance.size(); i++) {
            total += distance[i];
            if (i &gt;= start &amp;&amp; i &lt; destination) {
                clockwise += distance[i];
            }
        }

        int counterClockwise = total - clockwise;
        return min(clockwise, counterClockwise);
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-2">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œåªéœ€è¦éå†æ•°ç»„ä¸€æ¬¡</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å¸¸æ•°ä¸ªé¢å¤–å˜é‡</li>
</ul>

<hr />

<h2 id="è§£æ³•ä¸‰æ¨¡è¿ç®—å¤„ç†ç¯å½¢ä¸äº¤æ¢-start-å’Œ-destination">è§£æ³•ä¸‰ï¼šæ¨¡è¿ç®—å¤„ç†ç¯å½¢ï¼ˆä¸äº¤æ¢ start å’Œ destinationï¼‰</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<p>ä¸äº¤æ¢ start å’Œ destinationï¼Œè€Œæ˜¯é€šè¿‡æ¨¡è¿ç®—æ¥å¤„ç†ç¯å½¢éå†</p>

<h3 id="ä»£ç å®ç°-3">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-3">Go å®ç°</h4>

<pre><code>func distanceBetweenBusStops(distance []int, start int, destination int) int {
    n := len(distance)
    clockwise := 0

    // è®¡ç®—é¡ºæ—¶é’ˆè·ç¦»
    i := start
    for i != destination {
        clockwise += distance[i]
        i = (i + 1) % n
    }

    // è®¡ç®—æ€»è·ç¦»
    total := 0
    for _, d := range distance {
        total += d
    }

    counterClockwise := total - clockwise
    if clockwise &lt; counterClockwise {
        return clockwise
    }
    return counterClockwise
}
</code></pre>

<h4 id="c-å®ç°-3">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {
        int n = distance.size();
        int clockwise = 0;

        // è®¡ç®—é¡ºæ—¶é’ˆè·ç¦»
        int i = start;
        while (i != destination) {
            clockwise += distance[i];
            i = (i + 1) % n;
        }

        // è®¡ç®—æ€»è·ç¦»
        int total = 0;
        for (int d : distance) {
            total += d;
        }

        int counterClockwise = total - clockwise;
        return min(clockwise, counterClockwise);
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-3">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦éå†æ•´ä¸ªç¯å½¢</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)</li>
</ul>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>ç‰¹æ€§</th>
  <th>è§£æ³•ä¸€</th>
  <th>è§£æ³•äºŒ</th>
  <th>è§£æ³•ä¸‰</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æ—¶é—´å¤æ‚åº¦</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>O(n)</td>
</tr>
<tr>
  <td>ç©ºé—´å¤æ‚åº¦</td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
<tr>
  <td>éå†æ¬¡æ•°</td>
  <td>2æ¬¡</td>
  <td>1æ¬¡</td>
  <td>2æ¬¡</td>
</tr>
<tr>
  <td>ä»£ç ç®€æ´æ€§</td>
  <td>ç®€å•</td>
  <td>ç®€å•</td>
  <td>ä¸­ç­‰</td>
</tr>
<tr>
  <td>æ˜¯å¦éœ€è¦äº¤æ¢</td>
  <td>éœ€è¦</td>
  <td>éœ€è¦</td>
  <td>ä¸éœ€è¦</td>
</tr>
<tr>
  <td>å®é™…æ€§èƒ½</td>
  <td>è‰¯å¥½</td>
  <td>æœ€ä¼˜</td>
  <td>è‰¯å¥½</td>
</tr>
</tbody>
</table>

<p><strong>æ¨èä½¿ç”¨è§£æ³•äºŒ</strong>ï¼š
1. åªéœ€è¦ä¸€æ¬¡éå†ï¼Œæ•ˆç‡æœ€é«˜
2. ä»£ç ç®€æ´æ˜“æ‡‚
3. å®é™…æ€§èƒ½æœ€å¥½</p>

<p><strong>æ³¨æ„äº‹é¡¹</strong>ï¼š
- è§£æ³•ä¸€å’Œè§£æ³•äºŒéƒ½å…ˆäº¤æ¢äº† start å’Œ destination ç¡®ä¿ start &lt; destinationï¼Œè¿™æ ·è®¡ç®—é¡ºæ—¶é’ˆè·ç¦»æ›´ç®€å•
- è§£æ³•ä¸‰å±•ç¤ºäº†ä¸äº¤æ¢çš„æ¨¡è¿ç®—æ–¹æ³•ï¼Œä½†å®é™…ä»£ç ç¨å¤æ‚
- æ‰€æœ‰è§£æ³•éƒ½åˆ©ç”¨äº†ç¯å½¢è·¯çº¿çš„ç‰¹æ€§ï¼šé¡ºæ—¶é’ˆè·ç¦» + é€†æ—¶é’ˆè·ç¦» = æ€»è·ç¦»</p>

<hr />

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<p>è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯ç†è§£ç¯å½¢è·¯çº¿çš„ç‰¹æ€§ï¼š
1. ä» A åˆ° B æœ‰ä¸¤æ¡è·¯å¾„ï¼šé¡ºæ—¶é’ˆå’Œé€†æ—¶é’ˆ
2. ä¸¤æ¡è·¯å¾„çš„è·ç¦»ä¹‹å’Œç­‰äºç¯å½¢æ€»è·ç¦»
3. æœ€çŸ­è·ç¦»å°±æ˜¯ä¸¤æ¡è·¯å¾„ä¸­çš„è¾ƒå°å€¼</p>

<p>æœ€ç®€å•çš„å®ç°æ€è·¯æ˜¯ï¼š
1. ç¡®ä¿ start &lt; destinationï¼ˆäº¤æ¢ï¼‰
2. è®¡ç®—æ€»è·ç¦»å’Œé¡ºæ—¶é’ˆè·ç¦»
3. é€†æ—¶é’ˆè·ç¦» = æ€»è·ç¦» - é¡ºæ—¶é’ˆè·ç¦»
4. è¿”å›ä¸¤è€…ä¸­çš„è¾ƒå°å€¼</p>

<p>åœ¨å®é™…ç¼–ç ä¸­ï¼Œè§£æ³•äºŒï¼ˆå•æ¬¡éå†ï¼‰æ˜¯æœ€ä¼˜é€‰æ‹©ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 15:17:42</em></p>

<hr />

<h1 id="1383-æœ€å¤§çš„å›¢é˜Ÿè¡¨ç°å€¼">1383. æœ€å¤§çš„å›¢é˜Ÿè¡¨ç°å€¼</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: è´ªå¿ƒ, æ•°ç»„, æ’åº, å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/maximum-performance-of-a-team/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-2">é¢˜ç›®æè¿°</h2>

<p>ç»™å®šä¸¤ä¸ªæ•´æ•° <code>n</code> å’Œ <code>k</code>ï¼Œä»¥åŠä¸¤ä¸ªé•¿åº¦ä¸º <code>n</code> çš„æ•´æ•°æ•°ç»„ <code>speed</code> å’Œ<code> efficiency</code>ã€‚ç°æœ‰ <code>n</code> åå·¥ç¨‹å¸ˆï¼Œç¼–å·ä» <code>1</code> åˆ° <code>n</code>ã€‚å…¶ä¸­ <code>speed[i]</code>&nbsp;å’Œ <code>efficiency[i]</code>&nbsp;åˆ†åˆ«ä»£è¡¨ç¬¬ <code>i</code>&nbsp;ä½å·¥ç¨‹å¸ˆçš„é€Ÿåº¦å’Œæ•ˆç‡ã€‚</p>

<p>ä»è¿™ <code>n</code> åå·¥ç¨‹å¸ˆä¸­æœ€å¤šé€‰æ‹© <code>k</code> åä¸åŒçš„å·¥ç¨‹å¸ˆï¼Œä½¿å…¶ç»„æˆçš„å›¢é˜Ÿå…·æœ‰æœ€å¤§çš„å›¢é˜Ÿè¡¨ç°å€¼ã€‚</p>

<p><strong>å›¢é˜Ÿè¡¨ç°å€¼</strong>&nbsp;çš„å®šä¹‰ä¸ºï¼šä¸€ä¸ªå›¢é˜Ÿä¸­ã€Œæ‰€æœ‰å·¥ç¨‹å¸ˆé€Ÿåº¦çš„å’Œã€ä¹˜ä»¥ä»–ä»¬ã€Œæ•ˆç‡å€¼ä¸­çš„æœ€å°å€¼ã€ã€‚</p>

<p>è¯·ä½ è¿”å›è¯¥å›¢é˜Ÿçš„â€‹â€‹â€‹â€‹â€‹â€‹æœ€å¤§å›¢é˜Ÿè¡¨ç°å€¼ï¼Œç”±äºç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œè¯·ä½ è¿”å›ç»“æœå¯¹ <code>10^9 + 7</code> å–ä½™åçš„ç»“æœã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
<strong>è¾“å‡ºï¼š</strong>60
<strong>è§£é‡Šï¼š</strong>
æˆ‘ä»¬é€‰æ‹©å·¥ç¨‹å¸ˆ 2ï¼ˆspeed=10 ä¸” efficiency=4ï¼‰å’Œå·¥ç¨‹å¸ˆ 5ï¼ˆspeed=5 ä¸” efficiency=7ï¼‰ã€‚ä»–ä»¬çš„å›¢é˜Ÿè¡¨ç°å€¼ä¸º performance = (10 + 5) * min(4, 7) = 60 ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
<strong>è¾“å‡ºï¼š</strong>68
<strong>è§£é‡Šï¼š
</strong>æ­¤ç¤ºä¾‹ä¸ç¬¬ä¸€ä¸ªç¤ºä¾‹ç›¸åŒï¼Œé™¤äº† k = 3 ã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹©å·¥ç¨‹å¸ˆ 1 ï¼Œå·¥ç¨‹å¸ˆ 2 å’Œå·¥ç¨‹å¸ˆ 5 å¾—åˆ°æœ€å¤§çš„å›¢é˜Ÿè¡¨ç°å€¼ã€‚è¡¨ç°å€¼ä¸º performance = (2 + 10 + 5) * min(5, 4, 7) = 68 ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
<strong>è¾“å‡ºï¼š</strong>72
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= k &lt;= n &lt;= 10^5</code></li>
    <li><code>speed.length == n</code></li>
    <li><code>efficiency.length == n</code></li>
    <li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>
    <li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-2">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-2">C++</h3>

<pre><code>class Solution {
public:
    int maxPerformance(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) {

    }
};
</code></pre>

<h3 id="java-2">Java</h3>

<pre><code>class Solution {
    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {

    }
}
</code></pre>

<h3 id="python3-2">Python3</h3>

<pre><code>class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -&gt; int:

</code></pre>

<h3 id="javascript-2">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @param {number[]} speed
 * @param {number[]} efficiency
 * @param {number} k
 * @return {number}
 */
var maxPerformance = function(n, speed, efficiency, k) {

};
</code></pre>

<h3 id="go-2">Go</h3>

<pre><code>func maxPerformance(n int, speed []int, efficiency []int, k int) int {

}
</code></pre>

<hr />

<h2 id="æç¤º-2">æç¤º</h2>

<ol>
<li>Keep track of the engineers by their efficiency in decreasing order.</li>
<li>Starting from one engineer, to build a team, it suffices to bring K-1 more engineers who have higher efficiencies as well as high speeds.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-2">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>6
[2,10,3,1,5,8]
[5,4,3,9,7,2]
2
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-2">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-2">é¢˜ç›®åˆ†æ</h2>

<p>æˆ‘ä»¬éœ€è¦ä» n ä¸ªå·¥ç¨‹å¸ˆä¸­é€‰å‡ºæœ€å¤š k ä¸ªï¼Œä½¿å¾— <code>(é€Ÿåº¦ä¹‹å’Œ) Ã— min(æ•ˆç‡)</code> æœ€å¤§ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- å›¢é˜Ÿè¡¨ç°å€¼ç”±ä¸¤éƒ¨åˆ†å†³å®šï¼šé€Ÿåº¦æ€»å’Œå’Œæ•ˆç‡æœ€å°å€¼
- æ•ˆç‡æœ€å°å€¼ç”±å›¢é˜Ÿä¸­æ•ˆç‡æœ€ä½çš„æˆå‘˜å†³å®š
- é€Ÿåº¦æ€»å’Œæ˜¯é€‰ä¸­çš„å·¥ç¨‹å¸ˆé€Ÿåº¦ä¹‹å’Œ</p>

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="æ ¸å¿ƒæ€è·¯">æ ¸å¿ƒæ€è·¯</h3>

<ol>
<li><strong>æŒ‰æ•ˆç‡æ’åº</strong>ï¼šå¦‚æœæˆ‘ä»¬å›ºå®šæŸä¸ªå·¥ç¨‹å¸ˆçš„æ•ˆç‡ä½œä¸ºå›¢é˜Ÿçš„æœ€å°æ•ˆç‡ï¼Œé‚£ä¹ˆæ‰€æœ‰æ•ˆç‡ä¸ä½äºè¯¥å·¥ç¨‹å¸ˆçš„å·¥ç¨‹å¸ˆéƒ½å¯ä»¥è¢«é€‰æ‹©</li>
<li><strong>é€‰æ‹©é€Ÿåº¦æœ€å¤§çš„ k-1 ä¸ª</strong>ï¼šåœ¨æ•ˆç‡ä¸ä½äºå½“å‰å·¥ç¨‹å¸ˆçš„æ‰€æœ‰å·¥ç¨‹å¸ˆä¸­ï¼Œé€‰æ‹©é€Ÿåº¦æœ€å¤§çš„ k-1 ä¸ªï¼ˆåŠ ä¸Šå½“å‰å·¥ç¨‹å¸ˆè‡ªå·±ï¼Œå…±æœ€å¤š k ä¸ªï¼‰</li>
<li><strong>éå†æ‰€æœ‰å¯èƒ½çš„æ•ˆç‡æœ€å°å€¼</strong>ï¼šå¯¹æ¯ä¸ªå·¥ç¨‹å¸ˆä½œä¸ºæ•ˆç‡æœ€å°å€¼çš„æƒ…å†µè¿›è¡Œè®¡ç®—ï¼Œå–æœ€å¤§å€¼</li>
</ol>

<h3 id="å…·ä½“å®ç°æ–¹æ³•">å…·ä½“å®ç°æ–¹æ³•</h3>

<ul>
<li>å°†å·¥ç¨‹å¸ˆæŒ‰æ•ˆç‡é™åºæ’åº</li>
<li>ä½¿ç”¨æœ€å°å †ç»´æŠ¤å½“å‰é€‰ä¸­çš„å·¥ç¨‹å¸ˆçš„é€Ÿåº¦</li>
<li>éå†æ’åºåçš„å·¥ç¨‹å¸ˆï¼š
<ul>
<li>å°†å½“å‰å·¥ç¨‹å¸ˆçš„é€Ÿåº¦åŠ å…¥å †å’Œé€Ÿåº¦æ€»å’Œ</li>
<li>å¦‚æœå †çš„å¤§å°è¶…è¿‡ kï¼Œç§»é™¤é€Ÿåº¦æœ€å°çš„å·¥ç¨‹å¸ˆï¼ˆå› ä¸ºæ•ˆç‡å·²ç»ç”±å½“å‰å·¥ç¨‹å¸ˆå†³å®šï¼Œæˆ‘ä»¬åªéœ€è¦é€Ÿåº¦æœ€å¤§çš„ k-1 ä¸ªï¼‰</li>
<li>è®¡ç®—å½“å‰å›¢é˜Ÿè¡¨ç°å€¼ï¼šé€Ÿåº¦æ€»å’Œ Ã— å½“å‰å·¥ç¨‹å¸ˆçš„æ•ˆç‡</li>
<li>æ›´æ–°æœ€å¤§å›¢é˜Ÿè¡¨ç°å€¼</li>
</ul></li>
</ul>

<h2 id="è§£æ³•è¯¦è§£">è§£æ³•è¯¦è§£</h2>

<h3 id="è§£æ³•ä¸€æ’åº-æœ€å°å †æ¨è">è§£æ³•ä¸€ï¼šæ’åº + æœ€å°å †ï¼ˆæ¨èï¼‰</h3>

<p><strong>æ€è·¯</strong>ï¼š
1. å°†å·¥ç¨‹å¸ˆæŒ‰æ•ˆç‡é™åºæ’åº
2. éå†æ¯ä¸ªå·¥ç¨‹å¸ˆï¼Œå°†å…¶ä½œä¸ºæ•ˆç‡æœ€å°å€¼
3. ä½¿ç”¨æœ€å°å †ç»´æŠ¤å½“å‰é€‰ä¸­çš„å·¥ç¨‹å¸ˆçš„é€Ÿåº¦
4. å§‹ç»ˆä¿æŒå †çš„å¤§å°ä¸è¶…è¿‡ k
5. è®¡ç®—å¹¶æ›´æ–°æœ€å¤§è¡¨ç°å€¼</p>

<pre><code>func maxPerformance(n int, speed []int, efficiency []int, k int) int {
    const MOD = 1e9 + 7

    // åˆ›å»ºå·¥ç¨‹å¸ˆåˆ—è¡¨
    engineers := make([][2]int, n)
    for i := 0; i &lt; n; i++ {
        engineers[i] = [2]int{efficiency[i], speed[i]}
    }

    // æŒ‰æ•ˆç‡é™åºæ’åº
    sort.Slice(engineers, func(i, j int) bool {
        return engineers[i][0] &gt; engineers[j][0]
    })

    // æœ€å°å †ï¼ˆä½¿ç”¨ container/heapï¼‰
    h := &amp;minHeap{}
    heap.Init(h)

    totalSpeed := 0
    maxPerf := 0

    for _, eng := range engineers {
        eff, spd := eng[0], eng[1]

        // å°†å½“å‰å·¥ç¨‹å¸ˆçš„é€Ÿåº¦åŠ å…¥å †
        heap.Push(h, spd)
        totalSpeed += spd

        // å¦‚æœå †çš„å¤§å°è¶…è¿‡ kï¼Œç§»é™¤é€Ÿåº¦æœ€å°çš„
        if h.Len() &gt; k {
            minSpd := heap.Pop(h).(int)
            totalSpeed -= minSpd
        }

        // è®¡ç®—å½“å‰å›¢é˜Ÿè¡¨ç°å€¼
        perf := totalSpeed * eff
        if perf &gt; maxPerf {
            maxPerf = perf
        }
    }

    return maxPerf % MOD
}

// æœ€å°å †å®ç°
type minHeap []int

func (h minHeap) Len() int           { return len(h) }
func (h minHeap) Less(i, j int) bool { return h[i] &lt; h[j] }
func (h minHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *minHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *minHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[:n-1]
    return x
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;

class Solution {
public:
    int maxPerformance(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) {
        const int MOD = 1e9 + 7;

        // åˆ›å»ºå·¥ç¨‹å¸ˆåˆ—è¡¨å¹¶æ’åº
        vector&lt;pair&lt;int, int&gt;&gt; engineers;
        for (int i = 0; i &lt; n; i++) {
            engineers.emplace_back(efficiency[i], speed[i]);
        }

        // æŒ‰æ•ˆç‡é™åºæ’åº
        sort(engineers.rbegin(), engineers.rend());

        // æœ€å°å †ï¼ˆä½¿ç”¨ priority_queueï¼‰
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;

        long long totalSpeed = 0;
        long long maxPerf = 0;

        for (auto&amp; eng : engineers) {
            int eff = eng.first;
            int spd = eng.second;

            // å°†å½“å‰å·¥ç¨‹å¸ˆçš„é€Ÿåº¦åŠ å…¥å †
            minHeap.push(spd);
            totalSpeed += spd;

            // å¦‚æœå †çš„å¤§å°è¶…è¿‡ kï¼Œç§»é™¤é€Ÿåº¦æœ€å°çš„
            if (minHeap.size() &gt; k) {
                totalSpeed -= minHeap.top();
                minHeap.pop();
            }

            // è®¡ç®—å½“å‰å›¢é˜Ÿè¡¨ç°å€¼
            long long perf = totalSpeed * eff;
            if (perf &gt; maxPerf) {
                maxPerf = perf;
            }
        }

        return maxPerf % MOD;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n log n)
- æ’åºï¼šO(n log n)
- å †æ“ä½œï¼šæ¯ä¸ªå…ƒç´ æœ€å¤šå…¥å †å‡ºå †ä¸€æ¬¡ï¼ŒO(n log k)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n + k)
- å­˜å‚¨å·¥ç¨‹å¸ˆåˆ—è¡¨ï¼šO(n)
- å †ï¼šO(k)</p>

<h3 id="è§£æ³•äºŒæ’åº-å‰ç¼€å’Œä»…é€‚ç”¨äº-k-è¾ƒå°çš„æƒ…å†µ">è§£æ³•äºŒï¼šæ’åº + å‰ç¼€å’Œï¼ˆä»…é€‚ç”¨äº k è¾ƒå°çš„æƒ…å†µï¼‰</h3>

<p><strong>æ€è·¯</strong>ï¼š
1. æŒ‰æ•ˆç‡é™åºæ’åº
2. å¯¹äºæ¯ä¸ªä½ç½® iï¼Œè€ƒè™‘ä»¥ engineers[i] çš„æ•ˆç‡ä½œä¸ºæœ€å°å€¼
3. åœ¨ i ä¹‹å‰ï¼ˆæ•ˆç‡æ›´é«˜ï¼‰çš„å·¥ç¨‹å¸ˆä¸­ï¼Œé€‰æ‹©é€Ÿåº¦æœ€å¤§çš„ k-1 ä¸ª
4. å¯ä»¥ä½¿ç”¨å‰ç¼€æœ€å¤§ k ä¸ªé€Ÿåº¦çš„å’Œæ¥ä¼˜åŒ–</p>

<pre><code>// æ³¨æ„ï¼šè¿™ç§æ–¹æ³•åœ¨ k è¾ƒå¤§æ—¶æ•ˆç‡è¾ƒä½ï¼Œä»…ä½œä¸ºæ€è·¯å±•ç¤º
func maxPerformance2(n int, speed []int, efficiency []int, k int) int {
    const MOD = 1e9 + 7

    engineers := make([][2]int, n)
    for i := 0; i &lt; n; i++ {
        engineers[i] = [2]int{efficiency[i], speed[i]}
    }

    // æŒ‰æ•ˆç‡é™åºæ’åº
    sort.Slice(engineers, func(i, j int) bool {
        return engineers[i][0] &gt; engineers[j][0]
    })

    maxPerf := 0

    for i := 0; i &lt; n; i++ {
        eff := engineers[i][0]

        // æ”¶é›†æ‰€æœ‰æ•ˆç‡ &gt;= eff çš„å·¥ç¨‹å¸ˆçš„é€Ÿåº¦
        speeds := make([]int, 0)
        for j := 0; j &lt;= i; j++ {
            speeds = append(speeds, engineers[j][1])
        }

        // å–æœ€å¤§çš„ min(k, len(speeds)) ä¸ªé€Ÿåº¦
        sort.Sort(sort.Reverse(sort.IntSlice(speeds)))

        totalSpeed := 0
        for j := 0; j &lt; min(k, len(speeds)); j++ {
            totalSpeed += speeds[j]
        }

        perf := totalSpeed * eff
        if perf &gt; maxPerf {
            maxPerf = perf
        }
    }

    return maxPerf % MOD
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}
</code></pre>

<pre><code>// æ³¨æ„ï¼šè¿™ç§æ–¹æ³•åœ¨ k è¾ƒå¤§æ—¶æ•ˆç‡è¾ƒä½ï¼Œä»…ä½œä¸ºæ€è·¯å±•ç¤º
int maxPerformance2(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) {
    const int MOD = 1e9 + 7;

    vector&lt;pair&lt;int, int&gt;&gt; engineers;
    for (int i = 0; i &lt; n; i++) {
        engineers.emplace_back(efficiency[i], speed[i]);
    }

    // æŒ‰æ•ˆç‡é™åºæ’åº
    sort(engineers.rbegin(), engineers.rend());

    long long maxPerf = 0;

    for (int i = 0; i &lt; n; i++) {
        int eff = engineers[i].first;

        // æ”¶é›†æ‰€æœ‰æ•ˆç‡ &gt;= eff çš„å·¥ç¨‹å¸ˆçš„é€Ÿåº¦
        vector&lt;int&gt; speeds;
        for (int j = 0; j &lt;= i; j++) {
            speeds.push_back(engineers[j].second);
        }

        // å–æœ€å¤§çš„ min(k, (int)speeds.size()) ä¸ªé€Ÿåº¦
        sort(speeds.rbegin(), speeds.rend());

        long long totalSpeed = 0;
        int limit = min(k, (int)speeds.size());
        for (int j = 0; j &lt; limit; j++) {
            totalSpeed += speeds[j];
        }

        long long perf = totalSpeed * eff;
        if (perf &gt; maxPerf) {
            maxPerf = perf;
        }
    }

    return maxPerf % MOD;
}
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(nÂ² log n) æˆ– O(nÂ²)
- å¤–å±‚å¾ªç¯ï¼šO(n)
- å†…å±‚æ”¶é›†å’Œæ’åºï¼šO(n log n)
- æ€»ä½“ï¼šO(nÂ² log n)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<h3 id="è§£æ³•ä¸‰æ’åº-å¹³è¡¡äºŒå‰æœç´¢æ ‘multiset">è§£æ³•ä¸‰ï¼šæ’åº + å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆmultisetï¼‰</h3>

<p><strong>æ€è·¯</strong>ï¼š
1. æŒ‰æ•ˆç‡é™åºæ’åº
2. ä½¿ç”¨å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆå¦‚ C++ çš„ multisetï¼‰ç»´æŠ¤å½“å‰é€‰ä¸­çš„å·¥ç¨‹å¸ˆé€Ÿåº¦
3. å§‹ç»ˆä¿æŒé€‰ä¸­çš„å·¥ç¨‹å¸ˆæ•°é‡ä¸è¶…è¿‡ k
4. å¯ä»¥å¿«é€Ÿè·å–å’Œåˆ é™¤æœ€å°é€Ÿåº¦</p>

<pre><code>// Go æ ‡å‡†åº“æ²¡æœ‰å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œè¿™é‡Œä½¿ç”¨å †æ˜¯æ›´å¥½çš„é€‰æ‹©
// æ­¤è§£æ³•ä¸»è¦å±•ç¤º C++ çš„å®ç°
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
using namespace std;

class Solution {
public:
    int maxPerformance(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) {
        const int MOD = 1e9 + 7;

        vector&lt;pair&lt;int, int&gt;&gt; engineers;
        for (int i = 0; i &lt; n; i++) {
            engineers.emplace_back(efficiency[i], speed[i]);
        }

        // æŒ‰æ•ˆç‡é™åºæ’åº
        sort(engineers.rbegin(), engineers.rend());

        multiset&lt;int&gt; speeds;
        long long totalSpeed = 0;
        long long maxPerf = 0;

        for (auto&amp; eng : engineers) {
            int eff = eng.first;
            int spd = eng.second;

            // å°†å½“å‰å·¥ç¨‹å¸ˆçš„é€Ÿåº¦åŠ å…¥é›†åˆ
            speeds.insert(spd);
            totalSpeed += spd;

            // å¦‚æœé›†åˆå¤§å°è¶…è¿‡ kï¼Œç§»é™¤é€Ÿåº¦æœ€å°çš„
            if (speeds.size() &gt; k) {
                totalSpeed -= *speeds.begin();
                speeds.erase(speeds.begin());
            }

            // è®¡ç®—å½“å‰å›¢é˜Ÿè¡¨ç°å€¼
            long long perf = totalSpeed * eff;
            if (perf &gt; maxPerf) {
                maxPerf = perf;
            }
        }

        return maxPerf % MOD;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n log n)
- æ’åºï¼šO(n log n)
- multiset æ“ä½œï¼šæ¯ä¸ªå…ƒç´ æ’å…¥åˆ é™¤ä¸€æ¬¡ï¼ŒO(n log k)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n + k)</p>

<h2 id="è§£æ³•å¯¹æ¯”-2">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æ’åº+æœ€å°å †</td>
  <td>O(n log n)</td>
  <td>O(n + k)</td>
  <td>æ•ˆç‡é«˜ï¼Œå®ç°ç®€å•</td>
  <td>éœ€è¦ç»´æŠ¤å †</td>
</tr>
<tr>
  <td>æ’åº+å‰ç¼€å’Œ</td>
  <td>O(nÂ² log n)</td>
  <td>O(n)</td>
  <td>æ€è·¯ç›´è§‚</td>
  <td>æ•ˆç‡ä½ï¼Œä»…é€‚ç”¨äºå°è§„æ¨¡æ•°æ®</td>
</tr>
<tr>
  <td>æ’åº+multiset</td>
  <td>O(n log n)</td>
  <td>O(n + k)</td>
  <td>å¯ä»¥æ–¹ä¾¿åœ°è·å–å’Œåˆ é™¤ä»»æ„å…ƒç´ </td>
  <td>å¸¸æ•°å› å­è¾ƒå¤§ï¼Œä¸å¦‚å †é«˜æ•ˆ</td>
</tr>
</tbody>
</table>

<h2 id="æ€»ç»“-2">æ€»ç»“</h2>

<p><strong>æ¨èä½¿ç”¨è§£æ³•ä¸€ï¼ˆæ’åº+æœ€å°å †ï¼‰</strong>ï¼Œå› ä¸ºï¼š
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ï¼šO(n log n)
2. ç©ºé—´å¤æ‚åº¦åˆç†ï¼šO(n + k)
3. å®ç°ç›¸å¯¹ç®€å•
4. é€‚ç”¨äºé¢˜ç›®ç»™å®šçš„æ•°æ®èŒƒå›´ï¼ˆn â‰¤ 10^5ï¼‰</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- æŒ‰æ•ˆç‡é™åºæ’åºï¼Œç¡®ä¿éå†æ—¶å½“å‰å·¥ç¨‹å¸ˆçš„æ•ˆç‡æ˜¯å›¢é˜Ÿæœ€å°å€¼
- ä½¿ç”¨æœ€å°å †ç»´æŠ¤é€Ÿåº¦ï¼Œç¡®ä¿å¯ä»¥å¿«é€Ÿç§»é™¤æœ€å°é€Ÿåº¦
- éå†è¿‡ç¨‹ä¸­åŠ¨æ€æ›´æ–°é€Ÿåº¦æ€»å’Œå’Œæœ€å¤§è¡¨ç°å€¼
- æ³¨æ„ä½¿ç”¨é•¿æ•´å‹é¿å…æº¢å‡ºï¼Œæœ€åå–æ¨¡</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 16:18:53</em></p>

<hr />

<h1 id="1408-æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é…">1408. æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é…</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, å­—ç¬¦ä¸², å­—ç¬¦ä¸²åŒ¹é…</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/string-matching-in-an-array/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-3">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ <code>words</code> ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªå•è¯ã€‚è¯·ä½ æŒ‰ <strong>ä»»æ„</strong> é¡ºåºè¿”å› <code>words</code> ä¸­æ˜¯å…¶ä»–å•è¯çš„ <span data-keyword="substring-nonempty">å­å­—ç¬¦ä¸²</span> çš„æ‰€æœ‰å•è¯ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["mass","as","hero","superhero"]
<strong>è¾“å‡ºï¼š</strong>["as","hero"]
<strong>è§£é‡Šï¼š</strong>"as" æ˜¯ "mass" çš„å­å­—ç¬¦ä¸²ï¼Œ"hero" æ˜¯ "superhero" çš„å­å­—ç¬¦ä¸²ã€‚
["hero","as"] ä¹Ÿæ˜¯æœ‰æ•ˆçš„ç­”æ¡ˆã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["leetcode","et","code"]
<strong>è¾“å‡ºï¼š</strong>["et","code"]
<strong>è§£é‡Šï¼š</strong>"et" å’Œ "code" éƒ½æ˜¯ "leetcode" çš„å­å­—ç¬¦ä¸²ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["blue","green","bu"]
<strong>è¾“å‡ºï¼š</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= words.length &lt;= 100</code></li>
    <li><code>1 &lt;= words[i].length &lt;= 30</code></li>
    <li><code>words[i]</code> ä»…åŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚</li>
    <li>é¢˜ç›®æ•°æ® <strong>ä¿è¯</strong> <code>words</code>&nbsp;çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-3">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-3">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {

    }
};
</code></pre>

<h3 id="java-3">Java</h3>

<pre><code>class Solution {
    public List&lt;String&gt; stringMatching(String[] words) {

    }
}
</code></pre>

<h3 id="python3-3">Python3</h3>

<pre><code>class Solution:
    def stringMatching(self, words: List[str]) -&gt; List[str]:

</code></pre>

<h3 id="javascript-3">JavaScript</h3>

<pre><code>/**
 * @param {string[]} words
 * @return {string[]}
 */
var stringMatching = function(words) {

};
</code></pre>

<h3 id="go-3">Go</h3>

<pre><code>func stringMatching(words []string) []string {

}
</code></pre>

<hr />

<h2 id="æç¤º-3">æç¤º</h2>

<ol>
<li>Bruteforce to find if one string is substring of another or use KMP algorithm.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-3">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>["mass","as","hero","superhero"]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-3">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-3">é¢˜ç›®åˆ†æ</h2>

<p>é¢˜ç›®è¦æ±‚æ‰¾å‡ºå­—ç¬¦ä¸²æ•°ç»„ä¸­ï¼Œé‚£äº›æ˜¯å…¶ä»–å•è¯å­å­—ç¬¦ä¸²çš„å•è¯ã€‚éœ€è¦è¿”å›æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„å•è¯ï¼Œé¡ºåºä»»æ„ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- ä¸€ä¸ªå•è¯æ˜¯å…¶ä»–å•è¯çš„å­å­—ç¬¦ä¸²ï¼ˆä¸èƒ½æ˜¯è‡ªèº«ï¼‰
- æ‰€æœ‰å•è¯éƒ½æ˜¯å”¯ä¸€çš„
- éœ€è¦æ£€æŸ¥æ¯ä¸ªå•è¯æ˜¯å¦æ˜¯å…¶ä»–ä»»æ„å•è¯çš„å­ä¸²</p>

<h2 id="è§£æ³•ä¸€æš´åŠ›æšä¸¾æ³•">è§£æ³•ä¸€ï¼šæš´åŠ›æšä¸¾æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-2">è§£é¢˜æ€è·¯</h3>

<p>æœ€ç›´æ¥çš„æ–¹æ³•ï¼šå¯¹äºæ¯ä¸ªå•è¯ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯å…¶ä»–ä»»æ„å•è¯çš„å­ä¸²ã€‚ä½¿ç”¨åŒé‡å¾ªç¯å®ç°ã€‚</p>

<h3 id="ä»£ç å®ç°-4">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-4">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    var result []string
    n := len(words)

    for i := 0; i &lt; n; i++ {
        for j := 0; j &lt; n; j++ {
            if i != j &amp;&amp; len(words[i]) &lt;= len(words[j]) {
                // æ£€æŸ¥ words[i] æ˜¯å¦æ˜¯ words[j] çš„å­ä¸²
                if strings.Contains(words[j], words[i]) {
                    result = append(result, words[i])
                    break  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                }
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°-4">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        vector&lt;string&gt; result;
        int n = words.size();

        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i != j &amp;&amp; words[i].length() &lt;= words[j].length()) {
                    // æ£€æŸ¥ words[i] æ˜¯å¦æ˜¯ words[j] çš„å­ä¸²
                    if (words[j].find(words[i]) != string::npos) {
                        result.push_back(words[i]);
                        break;  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                    }
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-4">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(nÂ² * L)ï¼Œå…¶ä¸­ n æ˜¯å•è¯æ•°é‡ï¼ŒL æ˜¯å•è¯å¹³å‡é•¿åº¦ã€‚æœ€åæƒ…å†µä¸‹éœ€è¦æ¯”è¾ƒæ‰€æœ‰å•è¯å¯¹ã€‚</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼ˆä¸è€ƒè™‘è¾“å‡ºç»“æœçš„ç©ºé—´ï¼‰</li>
</ul>

<h2 id="è§£æ³•äºŒæ’åº-åç¼€æ£€æŸ¥æ³•">è§£æ³•äºŒï¼šæ’åº + åç¼€æ£€æŸ¥æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-3">è§£é¢˜æ€è·¯</h3>

<ol>
<li>æŒ‰é•¿åº¦å¯¹å•è¯æ’åºï¼Œè¾ƒçŸ­çš„å•è¯æ›´å¯èƒ½æ˜¯è¾ƒé•¿å•è¯çš„å­ä¸²</li>
<li>å¯¹äºæ¯ä¸ªå•è¯ï¼Œåªæ£€æŸ¥å®ƒåé¢çš„å•è¯ï¼ˆå› ä¸ºåé¢çš„å•è¯æ›´é•¿ï¼‰</li>
<li>è¿™æ ·å¯ä»¥å‡å°‘ä¸å¿…è¦çš„æ¯”è¾ƒ</li>
</ol>

<h3 id="ä»£ç å®ç°-5">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-5">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    // æŒ‰é•¿åº¦æ’åº
    sortedWords := make([]string, len(words))
    copy(sortedWords, words)
    sort.Slice(sortedWords, func(i, j int) bool {
        return len(sortedWords[i]) &lt; len(sortedWords[j])
    })

    var result []string
    n := len(sortedWords)

    for i := 0; i &lt; n; i++ {
        for j := i + 1; j &lt; n; j++ {
            // åªæ£€æŸ¥æ›´é•¿çš„å•è¯
            if strings.Contains(sortedWords[j], sortedWords[i]) {
                result = append(result, sortedWords[i])
                break  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°-5">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        // æŒ‰é•¿åº¦æ’åº
        vector&lt;string&gt; sortedWords = words;
        sort(sortedWords.begin(), sortedWords.end(), 
             [](const string&amp; a, const string&amp; b) {
                 return a.length() &lt; b.length();
             });

        vector&lt;string&gt; result;
        int n = sortedWords.size();

        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                // åªæ£€æŸ¥æ›´é•¿çš„å•è¯
                if (sortedWords[j].find(sortedWords[i]) != string::npos) {
                    result.push_back(sortedWords[i]);
                    break;  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-5">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n log n + nÂ² * L)ï¼Œæ’åºéœ€è¦ O(n log n)ï¼Œæ¯”è¾ƒéœ€è¦ O(nÂ² * L)</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œéœ€è¦é¢å¤–çš„æ•°ç»„å­˜å‚¨æ’åºåçš„å•è¯</li>
</ul>

<h2 id="è§£æ³•ä¸‰è¿æ¥å­—ç¬¦ä¸²æ³•">è§£æ³•ä¸‰ï¼šè¿æ¥å­—ç¬¦ä¸²æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-4">è§£é¢˜æ€è·¯</h3>

<ol>
<li>å°†æ‰€æœ‰å•è¯ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æˆä¸€ä¸ªé•¿å­—ç¬¦ä¸²</li>
<li>å¯¹äºæ¯ä¸ªå•è¯ï¼Œæ£€æŸ¥å®ƒåœ¨è¿™ä¸ªé•¿å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°</li>
<li>å¦‚æœå‡ºç°æ¬¡æ•°å¤§äº1ï¼Œè¯´æ˜å®ƒæ˜¯å…¶ä»–å•è¯çš„å­ä¸²</li>
</ol>

<h3 id="ä»£ç å®ç°-6">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-6">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    // ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æ‰€æœ‰å•è¯
    joined := strings.Join(words, "#")

    var result []string
    for _, word := range words {
        // åœ¨è¿æ¥åçš„å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾è¯¥å•è¯
        // éœ€è¦ç¡®ä¿æ‰¾åˆ°çš„ä½ç½®ä¸æ˜¯å•è¯æœ¬èº«çš„ä¸€éƒ¨åˆ†
        count := 0
        pos := 0
        for {
            idx := strings.Index(joined[pos:], word)
            if idx == -1 {
                break
            }
            count++
            pos += idx + 1
            if count &gt;= 2 {
                // å‡ºç°è‡³å°‘2æ¬¡ï¼Œè¯´æ˜æ˜¯å…¶ä»–å•è¯çš„å­ä¸²
                result = append(result, word)
                break
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°-6">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        // ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æ‰€æœ‰å•è¯
        string joined;
        for (const string&amp; word : words) {
            joined += word + "#";
        }

        vector&lt;string&gt; result;
        for (const string&amp; word : words) {
            // ç»Ÿè®¡å•è¯åœ¨è¿æ¥å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°
            int count = 0;
            size_t pos = 0;

            while ((pos = joined.find(word, pos)) != string::npos) {
                count++;
                pos += 1;  // ç§»åŠ¨ä½ç½®ç»§ç»­æŸ¥æ‰¾
                if (count &gt;= 2) {
                    // å‡ºç°è‡³å°‘2æ¬¡ï¼Œè¯´æ˜æ˜¯å…¶ä»–å•è¯çš„å­ä¸²
                    result.push_back(word);
                    break;
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-6">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n * L * S)ï¼Œå…¶ä¸­ S æ˜¯è¿æ¥åå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œæœ€åæƒ…å†µä¸‹æ¥è¿‘ n*L</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n * L)ï¼Œéœ€è¦å­˜å‚¨è¿æ¥åçš„å­—ç¬¦ä¸²</li>
</ul>

<h2 id="è§£æ³•å¯¹æ¯”-3">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
  <th>é€‚ç”¨åœºæ™¯</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æš´åŠ›æšä¸¾</td>
  <td>å®ç°ç®€å•ï¼Œæ— éœ€é¢å¤–ç©ºé—´</td>
  <td>æ—¶é—´å¤æ‚åº¦é«˜ï¼ŒO(nÂ² * L)</td>
  <td>æ•°æ®è§„æ¨¡å°ï¼ˆn â‰¤ 100ï¼‰</td>
</tr>
<tr>
  <td>æ’åº+åç¼€æ£€æŸ¥</td>
  <td>å‡å°‘æ¯”è¾ƒæ¬¡æ•°ï¼Œæ•ˆç‡è¾ƒé«˜</td>
  <td>éœ€è¦æ’åºï¼Œæ”¹å˜åŸå§‹é¡ºåº</td>
  <td>é€šç”¨åœºæ™¯ï¼Œæ€§èƒ½è¾ƒå¥½</td>
</tr>
<tr>
  <td>è¿æ¥å­—ç¬¦ä¸²</td>
  <td>æ€è·¯å·§å¦™ï¼Œä»£ç ç®€æ´</td>
  <td>å¯èƒ½è¯¯åˆ¤ï¼ˆå¦‚"a"åœ¨"ab"ä¸­å‡ºç°ï¼‰ï¼Œéœ€è¦ç‰¹æ®Šåˆ†éš”ç¬¦</td>
  <td>éœ€è¦å¿«é€Ÿå®ç°ï¼Œå¯¹æ€§èƒ½è¦æ±‚ä¸é«˜</td>
</tr>
</tbody>
</table>

<h2 id="æ¨èè§£æ³•">æ¨èè§£æ³•</h2>

<p>å¯¹äºæœ¬é¢˜çš„æ•°æ®è§„æ¨¡ï¼ˆn â‰¤ 100ï¼ŒL â‰¤ 30ï¼‰ï¼Œ<strong>è§£æ³•ä¸€ï¼ˆæš´åŠ›æšä¸¾ï¼‰</strong> æ˜¯æœ€ç®€å•ç›´æ¥çš„é€‰æ‹©ï¼Œä»£ç æ¸…æ™°æ˜“æ‡‚ï¼Œæ€§èƒ½ä¹Ÿå®Œå…¨è¶³å¤Ÿã€‚</p>

<p><strong>è§£æ³•äºŒï¼ˆæ’åº+åç¼€æ£€æŸ¥ï¼‰</strong> åœ¨æ€§èƒ½ä¸Šæ›´ä¼˜ï¼Œç‰¹åˆ«æ˜¯å½“å•è¯æ•°é‡è¾ƒå¤šæ—¶ï¼Œæ˜¯æ›´é€šç”¨çš„è§£å†³æ–¹æ¡ˆã€‚</p>

<p><strong>è§£æ³•ä¸‰ï¼ˆè¿æ¥å­—ç¬¦ä¸²ï¼‰</strong> è™½ç„¶æ€è·¯å·§å¦™ï¼Œä½†éœ€è¦æ³¨æ„å¤„ç†è¾¹ç•Œæƒ…å†µï¼Œå®é™…åº”ç”¨ä¸­è¾ƒå°‘ä½¿ç”¨ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:47:40</em></p>

<hr />

<h1 id="1616-åˆ†å‰²ä¸¤ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å›æ–‡ä¸²">1616. åˆ†å‰²ä¸¤ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å›æ–‡ä¸²</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: åŒæŒ‡é’ˆ, å­—ç¬¦ä¸²</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/split-two-strings-to-make-palindrome/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-4">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²&nbsp;<code>a</code> å’Œ&nbsp;<code>b</code>&nbsp;ï¼Œå®ƒä»¬é•¿åº¦ç›¸åŒã€‚è¯·ä½ é€‰æ‹©ä¸€ä¸ªä¸‹æ ‡ï¼Œå°†ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½åœ¨&nbsp;<strong>ç›¸åŒçš„ä¸‹æ ‡ </strong>åˆ†å‰²å¼€ã€‚ç”±&nbsp;<code>a</code>&nbsp;å¯ä»¥å¾—åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼š&nbsp;<code>a<sub>prefix</sub></code>&nbsp;å’Œ&nbsp;<code>a<sub>suffix</sub></code>&nbsp;ï¼Œæ»¡è¶³&nbsp;<code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub>&nbsp;</sub>ï¼ŒåŒç†ï¼Œç”±&nbsp;<code>b</code> å¯ä»¥å¾—åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²&nbsp;<code>b<sub>prefix</sub></code> å’Œ&nbsp;<code>b<sub>suffix</sub></code>&nbsp;ï¼Œæ»¡è¶³&nbsp;<code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>&nbsp;ã€‚è¯·ä½ åˆ¤æ–­&nbsp;<code>a<sub>prefix</sub> + b<sub>suffix</sub></code> æˆ–è€…&nbsp;<code>b<sub>prefix</sub> + a<sub>suffix</sub></code>&nbsp;èƒ½å¦æ„æˆå›æ–‡ä¸²ã€‚</p>

<p>å½“ä½ å°†ä¸€ä¸ªå­—ç¬¦ä¸²&nbsp;<code>s</code>&nbsp;åˆ†å‰²æˆ&nbsp;<code>s<sub>prefix</sub></code> å’Œ&nbsp;<code>s<sub>suffix</sub></code>&nbsp;æ—¶ï¼Œ&nbsp;<code>s<sub>suffix</sub></code> æˆ–è€…&nbsp;<code>s<sub>prefix</sub></code> å¯ä»¥ä¸ºç©ºã€‚æ¯”æ–¹è¯´ï¼Œ&nbsp;<code>s = "abc"</code>&nbsp;é‚£ä¹ˆ&nbsp;<code>"" + "abc"</code>&nbsp;ï¼Œ&nbsp;<code>"a" + "bc"&nbsp;</code>ï¼Œ&nbsp;<code>"ab" + "c"</code>&nbsp;å’Œ&nbsp;<code>"abc" + ""</code>&nbsp;éƒ½æ˜¯åˆæ³•åˆ†å‰²ã€‚</p>

<p>å¦‚æœ <strong>èƒ½æ„æˆå›æ–‡å­—ç¬¦ä¸²</strong> ï¼Œé‚£ä¹ˆè¯·è¿”å›&nbsp;<code>true</code>ï¼Œå¦åˆ™è¿”å›<em>&nbsp;</em><code>false</code>&nbsp;ã€‚</p>

<p><strong>æ³¨æ„</strong>ï¼Œ&nbsp;<code>x + y</code>&nbsp;è¡¨ç¤ºè¿æ¥å­—ç¬¦ä¸²&nbsp;<code>x</code> å’Œ&nbsp;<code>y</code>&nbsp;ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>a = "x", b = "y"
<b>è¾“å‡ºï¼š</b>true
<b>è§£é‡Šï¼š</b>å¦‚æœ a æˆ–è€… b æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸€å®šä¸º true ï¼Œå› ä¸ºä½ å¯ä»¥å¦‚ä¸‹åˆ†å‰²ï¼š
a<sub>prefix</sub> = "", a<sub>suffix</sub> = "x"
b<sub>prefix</sub> = "", b<sub>suffix</sub> = "y"
é‚£ä¹ˆ a<sub>prefix</sub> + b<sub>suffix</sub> = "" + "y" = "y" æ˜¯å›æ–‡ä¸²ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>a = "xbdef", b = "xecab"
<strong>è¾“å‡ºï¼š</strong>false
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>a = "ulacfd", b = "jizalu"
<b>è¾“å‡ºï¼š</b>true
<b>è§£é‡Šï¼š</b>åœ¨ä¸‹æ ‡ä¸º 3 å¤„åˆ†å‰²ï¼š
a<sub>prefix</sub> = "ula", a<sub>suffix</sub> = "cfd"
b<sub>prefix</sub> = "jiz", b<sub>suffix</sub> = "alu"
é‚£ä¹ˆ a<sub>prefix</sub> + b<sub>suffix</sub> = "ula" + "alu" = "ulaalu" æ˜¯å›æ–‡ä¸²ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>
    <li><code>a.length == b.length</code></li>
    <li><code>a</code> å’Œ&nbsp;<code>b</code>&nbsp;éƒ½åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-4">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-4">C++</h3>

<pre><code>class Solution {
public:
    bool checkPalindromeFormation(string a, string b) {

    }
};
</code></pre>

<h3 id="java-4">Java</h3>

<pre><code>class Solution {
    public boolean checkPalindromeFormation(String a, String b) {

    }
}
</code></pre>

<h3 id="python3-4">Python3</h3>

<pre><code>class Solution:
    def checkPalindromeFormation(self, a: str, b: str) -&gt; bool:

</code></pre>

<h3 id="javascript-4">JavaScript</h3>

<pre><code>/**
 * @param {string} a
 * @param {string} b
 * @return {boolean}
 */
var checkPalindromeFormation = function(a, b) {

};
</code></pre>

<h3 id="go-4">Go</h3>

<pre><code>func checkPalindromeFormation(a string, b string) bool {

}
</code></pre>

<hr />

<h2 id="æç¤º-4">æç¤º</h2>

<ol>
<li>Try finding the largest prefix from a that matches a suffix in b</li>
<li>Try string matching</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-4">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>"x"
"y"
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-4">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-4">é¢˜ç›®åˆ†æ</h2>

<p>é¢˜ç›®è¦æ±‚ï¼šç»™å®šä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„å­—ç¬¦ä¸² <code>a</code> å’Œ <code>b</code>ï¼Œé€‰æ‹©ä¸€ä¸ªç›¸åŒçš„åˆ†å‰²ç‚¹ï¼Œå°†ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ†åˆ«åˆ†å‰²ä¸ºå‰åä¸¤éƒ¨åˆ†ï¼Œç„¶åäº¤æ¢å‰åéƒ¨åˆ†ç»„åˆæˆä¸¤ä¸ªæ–°å­—ç¬¦ä¸²ï¼š
- <code>aprefix + bsuffix</code>
- <code>bprefix + asuffix</code></p>

<p>åˆ¤æ–­è¿™ä¸¤ä¸ªæ–°å­—ç¬¦ä¸²ä¸­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å›æ–‡ä¸²ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
1. åˆ†å‰²ç‚¹å¯ä»¥åœ¨ä»»æ„ä½ç½®ï¼ˆåŒ…æ‹¬ä¸¤ç«¯ï¼Œå³å‰åéƒ¨åˆ†å¯ä»¥ä¸ºç©ºï¼‰
2. éœ€è¦æ£€æŸ¥ä¸¤ç§ç»„åˆæ–¹å¼
3. å­—ç¬¦ä¸²é•¿åº¦å¯è¾¾ 10^5ï¼Œéœ€è¦ O(n) æˆ– O(n log n) çš„ç®—æ³•</p>

<h2 id="è§£é¢˜æ€è·¯-5">è§£é¢˜æ€è·¯</h2>

<h3 id="æ ¸å¿ƒè§‚å¯Ÿ">æ ¸å¿ƒè§‚å¯Ÿ</h3>

<p>å½“æˆ‘ä»¬ç»„åˆ <code>aprefix + bsuffix</code> æ—¶ï¼š
- <code>aprefix</code> æ¥è‡ª <code>a</code> çš„å‰ç¼€
- <code>bsuffix</code> æ¥è‡ª <code>b</code> çš„åç¼€
- ç»„åˆåçš„å­—ç¬¦ä¸²é•¿åº¦ä¸ºåŸå­—ç¬¦ä¸²é•¿åº¦</p>

<p>è®¾å­—ç¬¦ä¸²é•¿åº¦ä¸º <code>n</code>ï¼Œåˆ†å‰²ç‚¹ä¸º <code>i</code>ï¼ˆ0 â‰¤ i â‰¤ nï¼‰ï¼š
- <code>aprefix = a[0:i]</code>, <code>asuffix = a[i:n]</code>
- <code>bprefix = b[0:i]</code>, <code>bsuffix = b[i:n]</code>
- ç»„åˆ1ï¼š<code>a[0:i] + b[i:n]</code>
- ç»„åˆ2ï¼š<code>b[0:i] + a[i:n]</code></p>

<h3 id="æ€è·¯ä¸€åŒæŒ‡é’ˆæ£€æŸ¥æ³•æœ€ä¼˜è§£">æ€è·¯ä¸€ï¼šåŒæŒ‡é’ˆæ£€æŸ¥æ³•ï¼ˆæœ€ä¼˜è§£ï¼‰</h3>

<p>æˆ‘ä»¬å¯ä»¥ä»ä¸¤ç«¯å‘ä¸­é—´æ£€æŸ¥ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„ä½ç½®ï¼Œç„¶åå°è¯•ç”¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¯¹åº”éƒ¨åˆ†æ¥å¼¥è¡¥ã€‚</p>

<p>å…·ä½“æ­¥éª¤ï¼š
1. æ£€æŸ¥ <code>aprefix + bsuffix</code> æ˜¯å¦å¯èƒ½ä¸ºå›æ–‡ï¼š
   - ä»ä¸¤ç«¯å‘ä¸­é—´æ¯”è¾ƒ <code>a</code> çš„å‰ç¼€å’Œ <code>b</code> çš„åç¼€
   - å½“é‡åˆ°å­—ç¬¦ä¸åŒ¹é…æ—¶ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼š
     a) ä½¿ç”¨ <code>a</code> çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
     b) ä½¿ç”¨ <code>b</code> çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
   - æ£€æŸ¥è¿™ä¸¤ç§æƒ…å†µçš„ä¸­é—´æ®µæ˜¯å¦ä¸ºå›æ–‡</p>

<ol start="2">
<li>åŒç†æ£€æŸ¥ <code>bprefix + asuffix</code></li>
</ol>

<p>æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)</p>

<h3 id="æ€è·¯äºŒä¸­å¿ƒæ‰©å±•æ³•">æ€è·¯äºŒï¼šä¸­å¿ƒæ‰©å±•æ³•</h3>

<p>å¯¹äºæ¯ä¸ªå¯èƒ½çš„åˆ†å‰²ç‚¹ï¼Œæ£€æŸ¥ç»„åˆåçš„å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡ã€‚ä½†ç›´æ¥æ£€æŸ¥æ‰€æœ‰åˆ†å‰²ç‚¹ä¼šè¾¾åˆ° O(nÂ²) å¤æ‚åº¦ï¼Œéœ€è¦ä¼˜åŒ–ã€‚</p>

<p>ä¼˜åŒ–æ–¹æ³•ï¼š
- é¢„å¤„ç†å­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°æœ€é•¿çš„å‰ååŒ¹é…éƒ¨åˆ†
- ç„¶åæ£€æŸ¥å‰©ä½™éƒ¨åˆ†æ˜¯å¦ä¸ºå›æ–‡</p>

<p>æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)</p>

<h3 id="æ€è·¯ä¸‰å­—ç¬¦ä¸²å“ˆå¸Œrabin-karp">æ€è·¯ä¸‰ï¼šå­—ç¬¦ä¸²å“ˆå¸Œï¼ˆRabin-Karpï¼‰</h3>

<p>ä½¿ç”¨å­—ç¬¦ä¸²å“ˆå¸Œå¯ä»¥åœ¨ O(1) æ—¶é—´å†…åˆ¤æ–­å­ä¸²æ˜¯å¦å›æ–‡ï¼Œä½†éœ€è¦é¢„å¤„ç†å‰ç¼€å“ˆå¸Œå’Œåç¼€å“ˆå¸Œã€‚</p>

<p>æ­¥éª¤ï¼š
1. è®¡ç®— <code>a</code> å’Œ <code>b</code> çš„å‰ç¼€å“ˆå¸Œå’Œåç¼€å“ˆå¸Œ
2. å¯¹äºæ¯ä¸ªåˆ†å‰²ç‚¹ï¼Œå¯ä»¥å¿«é€Ÿè®¡ç®—ç»„åˆå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼
3. åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡</p>

<p>æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(n)</p>

<hr />

<h2 id="è§£æ³•å®ç°">è§£æ³•å®ç°</h2>

<h3 id="è§£æ³•ä¸€åŒæŒ‡é’ˆæ£€æŸ¥æ³•æœ€ä¼˜è§£">è§£æ³•ä¸€ï¼šåŒæŒ‡é’ˆæ£€æŸ¥æ³•ï¼ˆæœ€ä¼˜è§£ï¼‰</h3>

<h4 id="æ€è·¯-4">æ€è·¯</h4>

<ol>
<li>å®šä¹‰è¾…åŠ©å‡½æ•° <code>checkPalindrome(a, b)</code>ï¼Œæ£€æŸ¥ <code>aprefix + bsuffix</code> æ˜¯å¦å¯èƒ½ä¸ºå›æ–‡</li>
<li>åœ¨å‡½æ•°ä¸­ï¼Œä»ä¸¤ç«¯å‘ä¸­é—´æ¯”è¾ƒï¼š
<ul>
<li>å¦‚æœæ‰€æœ‰å­—ç¬¦éƒ½åŒ¹é…ï¼Œç›´æ¥è¿”å› true</li>
<li>å½“é‡åˆ°ä¸åŒ¹é…æ—¶ï¼Œæ£€æŸ¥ <code>a[left:right+1]</code> æˆ– <code>b[left:right+1]</code> æ˜¯å¦ä¸ºå›æ–‡</li>
</ul></li>
<li>åˆ†åˆ«æ£€æŸ¥ä¸¤ç§ç»„åˆæ–¹å¼</li>
</ol>

<pre><code>// Go å®ç°
func checkPalindromeFormation(a string, b string) bool {
    // æ£€æŸ¥å­ä¸²æ˜¯å¦ä¸ºå›æ–‡
    isPalindrome := func(s string, left, right int) bool {
        for left &lt; right {
            if s[left] != s[right] {
                return false
            }
            left++
            right--
        }
        return true
    }

    // æ£€æŸ¥ a çš„å‰ç¼€å’Œ b çš„åç¼€ç»„åˆ
    check := func(a, b string) bool {
        left, right := 0, len(a)-1
        // ä»ä¸¤ç«¯å‘ä¸­é—´æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„ä½ç½®
        for left &lt; right &amp;&amp; a[left] == b[right] {
            left++
            right--
        }
        // å¦‚æœå…¨éƒ¨åŒ¹é…ï¼Œæˆ–è€…å‰©ä½™éƒ¨åˆ†æ˜¯å›æ–‡ï¼Œåˆ™æˆåŠŸ
        if left &gt;= right {
            return true
        }
        // å°è¯•ç”¨ a çš„å‰©ä½™éƒ¨åˆ†æˆ– b çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
        return isPalindrome(a, left, right) || isPalindrome(b, left, right)
    }

    return check(a, b) || check(b, a)
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
private:
    // æ£€æŸ¥å­ä¸²æ˜¯å¦ä¸ºå›æ–‡
    bool isPalindrome(const string&amp; s, int left, int right) {
        while (left &lt; right) {
            if (s[left] != s[right]) return false;
            left++;
            right--;
        }
        return true;
    }

    // æ£€æŸ¥ a çš„å‰ç¼€å’Œ b çš„åç¼€ç»„åˆ
    bool check(const string&amp; a, const string&amp; b) {
        int left = 0, right = a.length() - 1;
        // ä»ä¸¤ç«¯å‘ä¸­é—´æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„ä½ç½®
        while (left &lt; right &amp;&amp; a[left] == b[right]) {
            left++;
            right--;
        }
        // å¦‚æœå…¨éƒ¨åŒ¹é…ï¼Œæˆ–è€…å‰©ä½™éƒ¨åˆ†æ˜¯å›æ–‡ï¼Œåˆ™æˆåŠŸ
        if (left &gt;= right) return true;
        // å°è¯•ç”¨ a çš„å‰©ä½™éƒ¨åˆ†æˆ– b çš„å‰©ä½™éƒ¨åˆ†ä½œä¸ºä¸­é—´æ®µ
        return isPalindrome(a, left, right) || isPalindrome(b, left, right);
    }

public:
    bool checkPalindromeFormation(string a, string b) {
        return check(a, b) || check(b, a);
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²æœ€å¤šéå†ä¸¤æ¬¡
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å¸¸æ•°ç©ºé—´</p>

<hr />

<h3 id="è§£æ³•äºŒä¸­å¿ƒæ‰©å±•æ³•">è§£æ³•äºŒï¼šä¸­å¿ƒæ‰©å±•æ³•</h3>

<h4 id="æ€è·¯-5">æ€è·¯</h4>

<ol>
<li>å…ˆæ‰¾åˆ° <code>a</code> å’Œ <code>b</code> çš„æœ€é•¿å…¬å…±å‰åç¼€</li>
<li>ç„¶åæ£€æŸ¥å‰©ä½™éƒ¨åˆ†æ˜¯å¦ä¸ºå›æ–‡</li>
<li>éœ€è¦è€ƒè™‘å››ç§æƒ…å†µï¼š
<ul>
<li><code>a</code> çš„å‰ç¼€ + <code>b</code> çš„åç¼€</li>
<li><code>b</code> çš„å‰ç¼€ + <code>a</code> çš„åç¼€</li>
<li>ä»¥åŠå®ƒä»¬å¯¹ç§°çš„æƒ…å†µ</li>
</ul></li>
</ol>

<pre><code>// Go å®ç°
func checkPalindromeFormation(a string, b string) bool {
    n := len(a)

    // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡
    isPalindrome := func(s string) bool {
        left, right := 0, len(s)-1
        for left &lt; right {
            if s[left] != s[right] {
                return false
            }
            left++
            right--
        }
        return true
    }

    // å¦‚æœ a æˆ– b æœ¬èº«å°±æ˜¯å›æ–‡ï¼Œç›´æ¥è¿”å› true
    if isPalindrome(a) || isPalindrome(b) {
        return true
    }

    // æ£€æŸ¥å››ç§æƒ…å†µ
    check := func(s1, s2 string) bool {
        // æ‰¾åˆ°ä»ä¸¤ç«¯å¼€å§‹åŒ¹é…çš„ä½ç½®
        left, right := 0, n-1
        for left &lt; right &amp;&amp; s1[left] == s2[right] {
            left++
            right--
        }

        if left &gt;= right {
            return true
        }

        // æ£€æŸ¥ s1[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        i, j := left, right
        for i &lt; j &amp;&amp; s1[i] == s1[j] {
            i++
            j--
        }
        if i &gt;= j {
            return true
        }

        // æ£€æŸ¥ s2[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        i, j = left, right
        for i &lt; j &amp;&amp; s2[i] == s2[j] {
            i++
            j--
        }
        return i &gt;= j
    }

    return check(a, b) || check(b, a)
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
private:
    bool isPalindrome(const string&amp; s) {
        int left = 0, right = s.length() - 1;
        while (left &lt; right) {
            if (s[left] != s[right]) return false;
            left++;
            right--;
        }
        return true;
    }

    bool check(const string&amp; s1, const string&amp; s2) {
        int n = s1.length();
        int left = 0, right = n - 1;

        // æ‰¾åˆ°ä»ä¸¤ç«¯å¼€å§‹åŒ¹é…çš„ä½ç½®
        while (left &lt; right &amp;&amp; s1[left] == s2[right]) {
            left++;
            right--;
        }

        if (left &gt;= right) return true;

        // æ£€æŸ¥ s1[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        int i = left, j = right;
        while (i &lt; j &amp;&amp; s1[i] == s1[j]) {
            i++;
            j--;
        }
        if (i &gt;= j) return true;

        // æ£€æŸ¥ s2[left:right+1] æ˜¯å¦ä¸ºå›æ–‡
        i = left, j = right;
        while (i &lt; j &amp;&amp; s2[i] == s2[j]) {
            i++;
            j--;
        }
        return i &gt;= j;
    }

public:
    bool checkPalindromeFormation(string a, string b) {
        if (isPalindrome(a) || isPalindrome(b)) return true;
        return check(a, b) || check(b, a);
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²æœ€å¤šéå†ä¸‰æ¬¡
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)</p>

<hr />

<h3 id="è§£æ³•ä¸‰å­—ç¬¦ä¸²å“ˆå¸Œæ³•">è§£æ³•ä¸‰ï¼šå­—ç¬¦ä¸²å“ˆå¸Œæ³•</h3>

<h4 id="æ€è·¯-6">æ€è·¯</h4>

<p>ä½¿ç”¨ Rabin-Karp å“ˆå¸Œç®—æ³•ï¼Œé¢„å¤„ç†å­—ç¬¦ä¸²çš„å‰ç¼€å“ˆå¸Œå’Œåç¼€å“ˆå¸Œï¼Œå¯ä»¥åœ¨ O(1) æ—¶é—´å†…åˆ¤æ–­ä»»æ„å­ä¸²æ˜¯å¦ä¸ºå›æ–‡ã€‚</p>

<pre><code>// Go å®ç°
func checkPalindromeFormation(a string, b string) bool {
    n := len(a)
    if n == 0 {
        return true
    }

    // è®¡ç®—å­—ç¬¦ä¸²çš„å“ˆå¸Œ
    computeHashes := func(s string) ([]uint64, []uint64) {
        base := uint64(131)
        prefix := make([]uint64, n+1)
        suffix := make([]uint64, n+1)
        pow := make([]uint64, n+1)
        pow[0] = 1

        for i := 1; i &lt;= n; i++ {
            prefix[i] = prefix[i-1]*base + uint64(s[i-1])
            pow[i] = pow[i-1] * base
        }

        for i := n - 1; i &gt;= 0; i-- {
            suffix[i] = suffix[i+1]*base + uint64(s[i])
        }

        return prefix, suffix
    }

    // æ£€æŸ¥å­ä¸²æ˜¯å¦ä¸ºå›æ–‡
    isPalindrome := func(prefix, suffix []uint64, pow []uint64, left, right int) bool {
        if left &gt;= right {
            return true
        }
        // æ­£åºå“ˆå¸Œ
        hash1 := prefix[right+1] - prefix[left]*pow[right-left+1]
        // é€†åºå“ˆå¸Œ
        hash2 := suffix[left] - suffix[right+1]*pow[right-left+1]
        return hash1 == hash2
    }

    // é¢„å¤„ç†å“ˆå¸Œ
    aPrefix, aSuffix := computeHashes(a)
    bPrefix, bSuffix := computeHashes(b)

    // è®¡ç®— pow æ•°ç»„
    pow := make([]uint64, n+1)
    pow[0] = 1
    base := uint64(131)
    for i := 1; i &lt;= n; i++ {
        pow[i] = pow[i-1] * base
    }

    // æ£€æŸ¥å‡½æ•°
    check := func(prefix1, suffix1, prefix2, suffix2 []uint64) bool {
        left, right := 0, n-1
        for left &lt; right {
            if isPalindrome(prefix1, suffix1, pow, left, right) || 
               isPalindrome(prefix2, suffix2, pow, left, right) {
                return true
            }
            // æ£€æŸ¥å½“å‰å­—ç¬¦æ˜¯å¦åŒ¹é…
            hash1 := prefix1[right+1] - prefix1[left]*pow[right-left+1]
            hash2 := suffix2[left] - suffix2[right+1]*pow[right-left+1]
            if hash1 != hash2 {
                break
            }
            left++
            right--
        }
        return left &gt;= right
    }

    // æ£€æŸ¥ä¸¤ç§æƒ…å†µ
    return check(aPrefix, aSuffix, bPrefix, bSuffix) || 
           check(bPrefix, bSuffix, aPrefix, aSuffix)
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
private:
    using ULL = unsigned long long;
    const ULL BASE = 131;

    vector&lt;ULL&gt; computePrefixHash(const string&amp; s) {
        int n = s.length();
        vector&lt;ULL&gt; prefix(n + 1, 0);
        for (int i = 1; i &lt;= n; i++) {
            prefix[i] = prefix[i-1] * BASE + s[i-1];
        }
        return prefix;
    }

    vector&lt;ULL&gt; computeSuffixHash(const string&amp; s) {
        int n = s.length();
        vector&lt;ULL&gt; suffix(n + 1, 0);
        for (int i = n - 1; i &gt;= 0; i--) {
            suffix[i] = suffix[i+1] * BASE + s[i];
        }
        return suffix;
    }

    bool isPalindrome(const vector&lt;ULL&gt;&amp; prefix, const vector&lt;ULL&gt;&amp; suffix, 
                     const vector&lt;ULL&gt;&amp; pow, int left, int right) {
        if (left &gt;= right) return true;
        ULL hash1 = prefix[right+1] - prefix[left] * pow[right-left+1];
        ULL hash2 = suffix[left] - suffix[right+1] * pow[right-left+1];
        return hash1 == hash2;
    }

public:
    bool checkPalindromeFormation(string a, string b) {
        int n = a.length();

        // é¢„å¤„ç†å“ˆå¸Œ
        auto aPrefix = computePrefixHash(a);
        auto aSuffix = computeSuffixHash(a);
        auto bPrefix = computePrefixHash(b);
        auto bSuffix = computeSuffixHash(b);

        // é¢„å¤„ç†å¹‚
        vector&lt;ULL&gt; pow(n + 1, 1);
        for (int i = 1; i &lt;= n; i++) {
            pow[i] = pow[i-1] * BASE;
        }

        // æ£€æŸ¥å‡½æ•°
        auto check = [&amp;](const vector&lt;ULL&gt;&amp; p1, const vector&lt;ULL&gt;&amp; s1,
                        const vector&lt;ULL&gt;&amp; p2, const vector&lt;ULL&gt;&amp; s2) -&gt; bool {
            int left = 0, right = n - 1;
            while (left &lt; right) {
                if (isPalindrome(p1, s1, pow, left, right) || 
                    isPalindrome(p2, s2, pow, left, right)) {
                    return true;
                }
                ULL hash1 = p1[right+1] - p1[left] * pow[right-left+1];
                ULL hash2 = s2[left] - s2[right+1] * pow[right-left+1];
                if (hash1 != hash2) break;
                left++;
                right--;
            }
            return left &gt;= right;
        };

        return check(aPrefix, aSuffix, bPrefix, bSuffix) || 
               check(bPrefix, bSuffix, aPrefix, aSuffix);
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œéœ€è¦é¢„å¤„ç†å“ˆå¸Œ
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œéœ€è¦å­˜å‚¨å“ˆå¸Œæ•°ç»„</p>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”-4">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>ç‰¹æ€§</th>
  <th>è§£æ³•ä¸€ï¼šåŒæŒ‡é’ˆæ£€æŸ¥æ³•</th>
  <th>è§£æ³•äºŒï¼šä¸­å¿ƒæ‰©å±•æ³•</th>
  <th>è§£æ³•ä¸‰ï¼šå­—ç¬¦ä¸²å“ˆå¸Œæ³•</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æ—¶é—´å¤æ‚åº¦</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>O(n)</td>
</tr>
<tr>
  <td>ç©ºé—´å¤æ‚åº¦</td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(n)</td>
</tr>
<tr>
  <td>å®ç°éš¾åº¦</td>
  <td>ç®€å•</td>
  <td>ä¸­ç­‰</td>
  <td>å¤æ‚</td>
</tr>
<tr>
  <td>è¿è¡Œæ•ˆç‡</td>
  <td>é«˜</td>
  <td>é«˜</td>
  <td>ä¸­ç­‰</td>
</tr>
<tr>
  <td>é€‚ç”¨åœºæ™¯</td>
  <td>é€šç”¨</td>
  <td>é€šç”¨</td>
  <td>éœ€è¦å¤šæ¬¡æŸ¥è¯¢æ—¶</td>
</tr>
</tbody>
</table>

<p><strong>æ€»ç»“</strong>ï¼š
1. <strong>è§£æ³•ä¸€ï¼ˆåŒæŒ‡é’ˆæ£€æŸ¥æ³•ï¼‰</strong> æ˜¯æœ€ä¼˜è§£ï¼Œä»£ç ç®€æ´ï¼Œæ•ˆç‡é«˜ï¼Œç©ºé—´å¤æ‚åº¦ä½ï¼Œæ¨èä½¿ç”¨
2. <strong>è§£æ³•äºŒï¼ˆä¸­å¿ƒæ‰©å±•æ³•ï¼‰</strong> æ€è·¯æ¸…æ™°ï¼Œå®ç°ç›¸å¯¹ç®€å•ï¼Œä¹Ÿæ˜¯å¾ˆå¥½çš„é€‰æ‹©
3. <strong>è§£æ³•ä¸‰ï¼ˆå­—ç¬¦ä¸²å“ˆå¸Œæ³•ï¼‰</strong> è™½ç„¶ç†è®ºæ—¶é—´å¤æ‚åº¦ç›¸åŒï¼Œä½†å®ç°å¤æ‚ï¼Œå¸¸æ•°å› å­å¤§ï¼Œä¸”éœ€è¦é¢å¤–ç©ºé—´ï¼Œåœ¨æœ¬é¢˜ä¸­ä¸æ˜¯æœ€ä½³é€‰æ‹©</p>

<p>åœ¨å®é™…é¢è¯•æˆ–ç«èµ›ä¸­ï¼Œæ¨èä½¿ç”¨<strong>è§£æ³•ä¸€</strong>ï¼Œå®ƒç›´è§‚ä¸”é«˜æ•ˆï¼Œå®¹æ˜“ç†è§£å’Œå®ç°ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 16:17:38</em></p>

        </div>
    </div>
</body>
</html>