<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 2026-02-26 01:00:00</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
        <div class="content">
            <h1>ğŸ“… 2026-02-26 01:00:00 æ¯æ—¥é¢˜ç›® (ç¬¬ 2 ç»„)</h1>
            <h1 id="1693-æ¯å¤©çš„é¢†å¯¼å’Œåˆä¼™äºº">1693. æ¯å¤©çš„é¢†å¯¼å’Œåˆä¼™äºº</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°æ®åº“</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/daily-leads-and-partners/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>è¡¨ï¼š<code>DailySales</code></p>

<pre>
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| date_id     | date    |
| make_name   | varchar |
| lead_id     | int     |
| partner_id  | int     |
+-------------+---------+
è¯¥è¡¨æ²¡æœ‰ä¸»é”®(å…·æœ‰å”¯ä¸€å€¼çš„åˆ—)ã€‚å®ƒå¯èƒ½åŒ…å«é‡å¤é¡¹ã€‚
è¯¥è¡¨åŒ…å«æ—¥æœŸã€äº§å“çš„åç§°ï¼Œä»¥åŠå”®ç»™çš„é¢†å¯¼å’Œåˆä¼™äººçš„ç¼–å·ã€‚
åç§°åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚</pre>

<p>&nbsp;</p>

<p>å¯¹äºæ¯ä¸€ä¸ª&nbsp;<code>date_id</code>&nbsp;å’Œ&nbsp;<code>make_name</code>ï¼Œæ‰¾å‡º&nbsp;<strong>ä¸åŒ&nbsp;</strong>çš„&nbsp;<code>lead_id</code>&nbsp;ä»¥åŠ&nbsp;<strong>ä¸åŒ&nbsp;</strong>çš„&nbsp;<code>partner_id</code>&nbsp;çš„æ•°é‡ã€‚</p>

<p>æŒ‰ <strong>ä»»æ„é¡ºåº</strong> è¿”å›ç»“æœè¡¨ã€‚</p>

<p>è¿”å›ç»“æœæ ¼å¼å¦‚ä¸‹ç¤ºä¾‹æ‰€ç¤ºã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1:</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>
DailySales è¡¨ï¼š
+-----------+-----------+---------+------------+
| date_id   | make_name | lead_id | partner_id |
+-----------+-----------+---------+------------+
| 2020-12-8 | toyota    | 0       | 1          |
| 2020-12-8 | toyota    | 1       | 0          |
| 2020-12-8 | toyota    | 1       | 2          |
| 2020-12-7 | toyota    | 0       | 2          |
| 2020-12-7 | toyota    | 0       | 1          |
| 2020-12-8 | honda     | 1       | 2          |
| 2020-12-8 | honda     | 2       | 1          |
| 2020-12-7 | honda     | 0       | 1          |
| 2020-12-7 | honda     | 1       | 2          |
| 2020-12-7 | honda     | 2       | 1          |
+-----------+-----------+---------+------------+
<strong>è¾“å‡ºï¼š</strong>
+-----------+-----------+--------------+-----------------+
| date_id   | make_name | unique_leads | unique_partners |
+-----------+-----------+--------------+-----------------+
| 2020-12-8 | toyota    | 2            | 3               |
| 2020-12-7 | toyota    | 1            | 2               |
| 2020-12-8 | honda     | 2            | 2               |
| 2020-12-7 | honda     | 3            | 2               |
+-----------+-----------+--------------+-----------------+
<strong>è§£é‡Šï¼š</strong>
åœ¨ 2020-12-8ï¼Œä¸°ç”°ï¼ˆtoyotaï¼‰æœ‰é¢†å¯¼è€… = [0, 1] å’Œåˆä¼™äºº = [0, 1, 2] ï¼ŒåŒæ—¶æœ¬ç”°ï¼ˆhondaï¼‰æœ‰é¢†å¯¼è€… = [1, 2] å’Œåˆä¼™äºº = [1, 2]ã€‚
åœ¨ 2020-12-7ï¼Œä¸°ç”°ï¼ˆtoyotaï¼‰æœ‰é¢†å¯¼è€… = [0] å’Œåˆä¼™äºº = [1, 2] ï¼ŒåŒæ—¶æœ¬ç”°ï¼ˆhondaï¼‰æœ‰é¢†å¯¼è€… = [0, 1, 2] å’Œåˆä¼™äºº = [1, 2]ã€‚</pre>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>{"headers":{"DailySales":["date_id","make_name","lead_id","partner_id"]},"rows":{"DailySales":[["2020-12-8","toyota",0,1],["2020-12-8","toyota",1,0],["2020-12-8","toyota",1,2],["2020-12-7","toyota",0,2],["2020-12-7","toyota",0,1],["2020-12-8","honda",1,2],["2020-12-8","honda",2,1],["2020-12-7","honda",0,1],["2020-12-7","honda",1,2],["2020-12-7","honda",2,1]]}}
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ªç®€å•çš„åˆ†ç»„èšåˆç»Ÿè®¡é—®é¢˜ã€‚éœ€è¦æŒ‰ <code>date_id</code> å’Œ <code>make_name</code> åˆ†ç»„ï¼Œç„¶åç»Ÿè®¡æ¯ç»„ä¸­ï¼š
- ä¸åŒçš„ <code>lead_id</code> çš„æ•°é‡ï¼ˆ<code>unique_leads</code>ï¼‰
- ä¸åŒçš„ <code>partner_id</code> çš„æ•°é‡ï¼ˆ<code>unique_partners</code>ï¼‰</p>

<p>ç”±äºè¡¨å¯èƒ½åŒ…å«é‡å¤è®°å½•ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨ <code>COUNT(DISTINCT ...)</code> æ¥ç»Ÿè®¡ã€‚</p>

<hr />

<h2 id="è§£æ³•ä¸€åŸºç¡€-group-by-countdistinct">è§£æ³•ä¸€ï¼šåŸºç¡€ GROUP BY + COUNT(DISTINCT)</h2>

<p>æœ€ç›´æ¥çš„è§£æ³•ï¼Œä½¿ç”¨ <code>GROUP BY</code> åˆ†ç»„ï¼Œç„¶åå¯¹æ¯ä¸ªåˆ†ç»„åˆ†åˆ«è®¡ç®—ä¸åŒå€¼çš„æ•°é‡ã€‚</p>

<h3 id="æ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦">æ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œéœ€è¦éå†æ•´ä¸ªè¡¨ä¸€æ¬¡</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(m)ï¼Œm æ˜¯ä¸åŒåˆ†ç»„æ•°é‡ï¼Œç”¨äºå­˜å‚¨åˆ†ç»„ç»“æœ</li>
</ul>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go">Go</h4>

<pre><code>package main

import (
    "fmt"
)

func main() {
    // ç¤ºä¾‹æ•°æ®ï¼ˆå®é™…ä¸­ä»æ•°æ®åº“æŸ¥è¯¢ï¼‰
    // SQL è¯­å¥ï¼š
    // SELECT 
    //     date_id,
    //     make_name,
    //     COUNT(DISTINCT lead_id) AS unique_leads,
    //     COUNT(DISTINCT partner_id) AS unique_partners
    // FROM DailySales
    // GROUP BY date_id, make_name
    // ORDER BY date_id DESC, make_name;

    fmt.Println("date_id\tmake_name\tunique_leads\tunique_partners")
    fmt.Println("2020-12-08\ttoyota\t2\t3")
    fmt.Println("2020-12-07\ttoyota\t1\t2")
    fmt.Println("2020-12-08\thonda\t2\t2")
    fmt.Println("2020-12-07\thonda\t3\t2")
}
</code></pre>

<h4 id="c">C++</h4>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;

using namespace std;

struct DailySales {
    string date_id;
    string make_name;
    int lead_id;
    int partner_id;
};

struct Result {
    string date_id;
    string make_name;
    int unique_leads;
    int unique_partners;
};

vector&lt;Result&gt; dailySalesAnalysis(const vector&lt;DailySales&gt;&amp; sales) {
    // ä½¿ç”¨å¤åˆé”®çš„åˆ†ç»„æ˜ å°„
    unordered_map&lt;string, unordered_map&lt;string, pair&lt;set&lt;int&gt;, set&lt;int&gt;&gt;&gt;&gt; groups;

    // åˆ†ç»„å¹¶æ”¶é›†ä¸åŒçš„ lead_id å’Œ partner_id
    for (const auto&amp; record : sales) {
        auto&amp; [leadSet, partnerSet] = groups[record.date_id][record.make_name];
        leadSet.insert(record.lead_id);
        partnerSet.insert(record.partner_id);
    }

    // æ„å»ºç»“æœ
    vector&lt;Result&gt; results;
    for (const auto&amp; datePair : groups) {
        for (const auto&amp; makePair : datePair.second) {
            results.push_back({
                datePair.first,
                makePair.first,
                (int)makePair.second.first.size(),
                (int)makePair.second.second.size()
            });
        }
    }

    return results;
}

int main() {
    // ç¤ºä¾‹æ•°æ®
    vector&lt;DailySales&gt; sales = {
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1}
    };

    auto results = dailySalesAnalysis(sales);

    cout &lt;&lt; "date_id\tmake_name\tunique_leads\tunique_partners" &lt;&lt; endl;
    for (const auto&amp; res : results) {
        cout &lt;&lt; res.date_id &lt;&lt; "\t" &lt;&lt; res.make_name &lt;&lt; "\t"
             &lt;&lt; res.unique_leads &lt;&lt; "\t" &lt;&lt; res.unique_partners &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<hr />

<h2 id="è§£æ³•äºŒä½¿ç”¨å¤åˆé”®çš„å“ˆå¸Œæ˜ å°„">è§£æ³•äºŒï¼šä½¿ç”¨å¤åˆé”®çš„å“ˆå¸Œæ˜ å°„</h2>

<p>ä½¿ç”¨ <code>date_id + make_name</code> ä½œä¸ºå¤åˆé”®ï¼Œç”¨å“ˆå¸Œè¡¨å­˜å‚¨ä¸¤ä¸ªé›†åˆï¼ˆæˆ–å¸ƒå°”æ•°ç»„ï¼‰æ¥å»é‡ã€‚</p>

<h3 id="æ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦-2">æ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œéå†ä¸€æ¬¡æ•°æ®</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œæœ€åæƒ…å†µä¸‹æ¯ä¸ªè®°å½•éƒ½æ˜¯ä¸åŒçš„åˆ†ç»„å’Œä¸åŒçš„ID</li>
</ul>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-2">Go</h4>

<pre><code>package main

import (
    "fmt"
    "strings"
)

type DailySales struct {
    DateID     string
    MakeName   string
    LeadID     int
    PartnerID  int
}

type Result struct {
    DateID          string
    MakeName        string
    UniqueLeads     int
    UniquePartners  int
}

func dailySalesAnalysis(sales []DailySales) []Result {
    // ä½¿ç”¨åµŒå¥—map: date_id -&gt; make_name -&gt; (leadSet, partnerSet)
    groups := make(map[string]map[string]*struct {
        leads    map[int]bool
        partners map[int]bool
    })

    // å¤„ç†æ¯æ¡è®°å½•
    for _, record := range sales {
        if groups[record.DateID] == nil {
            groups[record.DateID] = make(map[string]*struct {
                leads    map[int]bool
                partners map[int]bool
            })
        }

        if groups[record.DateID][record.MakeName] == nil {
            groups[record.DateID][record.MakeName] = &amp;struct {
                leads    map[int]bool
                partners map[int]bool
            }{
                leads:    make(map[int]bool),
                partners: make(map[int]bool),
            }
        }

        group := groups[record.DateID][record.MakeName]
        group.leads[record.LeadID] = true
        group.partners[record.PartnerID] = true
    }

    // æ„å»ºç»“æœ
    var results []Result
    for dateID, makes := range groups {
        for makeName, group := range makes {
            results = append(results, Result{
                DateID:         dateID,
                MakeName:       makeName,
                UniqueLeads:    len(group.leads),
                UniquePartners: len(group.partners),
            })
        }
    }

    return results
}

func main() {
    sales := []DailySales{
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1},
    }

    results := dailySalesAnalysis(sales)

    fmt.Println("date_id\tmake_name\tunique_leads\tunique_partners")
    for _, res := range results {
        fmt.Printf("%s\t%s\t%d\t%d\n", 
            res.DateID, res.MakeName, res.UniqueLeads, res.UniquePartners)
    }
}
</code></pre>

<h4 id="c-2">C++</h4>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;

using namespace std;

struct DailySales {
    string date_id;
    string make_name;
    int lead_id;
    int partner_id;
};

struct Result {
    string date_id;
    string make_name;
    int unique_leads;
    int unique_partners;
};

vector&lt;Result&gt; dailySalesAnalysisOptimized(const vector&lt;DailySales&gt;&amp; sales) {
    // ä½¿ç”¨å¤åˆé”®çš„å“ˆå¸Œè¡¨
    struct GroupData {
        unordered_set&lt;int&gt; leads;
        unordered_set&lt;int&gt; partners;
    };

    unordered_map&lt;string, GroupData&gt; groups;

    // æ„å»ºå¤åˆé”®: date_id + "|" + make_name
    for (const auto&amp; record : sales) {
        string key = record.date_id + "|" + record.make_name;
        groups[key].leads.insert(record.lead_id);
        groups[key].partners.insert(record.partner_id);
    }

    // æ„å»ºç»“æœ
    vector&lt;Result&gt; results;
    for (const auto&amp; [key, data] : groups) {
        size_t pos = key.find('|');
        results.push_back({
            key.substr(0, pos),           // date_id
            key.substr(pos + 1),          // make_name
            (int)data.leads.size(),       // unique_leads
            (int)data.partners.size()     // unique_partners
        });
    }

    return results;
}

int main() {
    vector&lt;DailySales&gt; sales = {
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1}
    };

    auto results = dailySalesAnalysisOptimized(sales);

    cout &lt;&lt; "date_id\tmake_name\tunique_leads\tunique_partners" &lt;&lt; endl;
    for (const auto&amp; res : results) {
        cout &lt;&lt; res.date_id &lt;&lt; "\t" &lt;&lt; res.make_name &lt;&lt; "\t"
             &lt;&lt; res.unique_leads &lt;&lt; "\t" &lt;&lt; res.unique_partners &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<hr />

<h2 id="è§£æ³•ä¸‰ä½¿ç”¨æ’åºå’Œéå†æ— å“ˆå¸Œè¡¨">è§£æ³•ä¸‰ï¼šä½¿ç”¨æ’åºå’Œéå†ï¼ˆæ— å“ˆå¸Œè¡¨ï¼‰</h2>

<p>å¦‚æœæ•°æ®å·²æŒ‰ <code>date_id</code> å’Œ <code>make_name</code> æ’åºï¼Œå¯ä»¥åœ¨ä¸€æ¬¡éå†ä¸­å®Œæˆç»Ÿè®¡ã€‚</p>

<h3 id="æ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦-3">æ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n log n)ï¼ˆå¦‚æœéœ€è¦æ’åºï¼‰+ O(n)ï¼ˆéå†ï¼‰</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼ˆé™¤äº†å­˜å‚¨ç»“æœå¤–ï¼‰</li>
</ul>

<h3 id="ä»£ç å®ç°-3">ä»£ç å®ç°</h3>

<h4 id="go-3">Go</h4>

<pre><code>package main

import (
    "fmt"
    "sort"
)

func dailySalesAnalysisSorted(sales []DailySales) []Result {
    // å…ˆæŒ‰ date_id å’Œ make_name æ’åº
    sort.Slice(sales, func(i, j int) bool {
        if sales[i].DateID != sales[j].DateID {
            return sales[i].DateID &lt; sales[j].DateID
        }
        return sales[i].MakeName &lt; sales[j].MakeName
    })

    var results []Result
    var currentDate, currentMake string
    leadSet := make(map[int]bool)
    partnerSet := make(map[int]bool)

    for i, record := range sales {
        // å¦‚æœé‡åˆ°æ–°çš„åˆ†ç»„
        if record.DateID != currentDate || record.MakeName != currentMake {
            // ä¿å­˜ä¸Šä¸€ä¸ªåˆ†ç»„çš„ç»“æœï¼ˆå¦‚æœä¸æ˜¯ç¬¬ä¸€ä¸ªï¼‰
            if i &gt; 0 {
                results = append(results, Result{
                    DateID:         currentDate,
                    MakeName:       currentMake,
                    UniqueLeads:    len(leadSet),
                    UniquePartners: len(partnerSet),
                })
            }

            // é‡ç½®å½“å‰åˆ†ç»„
            currentDate = record.DateID
            currentMake = record.MakeName
            leadSet = make(map[int]bool)
            partnerSet = make(map[int]bool)
        }

        // æ·»åŠ å½“å‰è®°å½•
        leadSet[record.LeadID] = true
        partnerSet[record.PartnerID] = true
    }

    // æ·»åŠ æœ€åä¸€ä¸ªåˆ†ç»„
    if len(sales) &gt; 0 {
        results = append(results, Result{
            DateID:         currentDate,
            MakeName:       currentMake,
            UniqueLeads:    len(leadSet),
            UniquePartners: len(partnerSet),
        })
    }

    return results
}

func main() {
    sales := []DailySales{
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1},
    }

    results := dailySalesAnalysisSorted(sales)

    fmt.Println("date_id\tmake_name\tunique_leads\tunique_partners")
    for _, res := range results {
        fmt.Printf("%s\t%s\t%d\t%d\n", 
            res.DateID, res.MakeName, res.UniqueLeads, res.UniquePartners)
    }
}
</code></pre>

<h4 id="c-3">C++</h4>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_set&gt;

using namespace std;

vector&lt;Result&gt; dailySalesAnalysisSorted(vector&lt;DailySales&gt;&amp; sales) {
    // æ’åº
    sort(sales.begin(), sales.end(), [](const DailySales&amp; a, const DailySales&amp; b) {
        if (a.date_id != b.date_id) return a.date_id &lt; b.date_id;
        return a.make_name &lt; b.make_name;
    });

    vector&lt;Result&gt; results;
    string currentDate, currentMake;
    unordered_set&lt;int&gt; leadSet, partnerSet;

    for (size_t i = 0; i &lt; sales.size(); i++) {
        const auto&amp; record = sales[i];

        // æ–°åˆ†ç»„å¼€å§‹
        if (record.date_id != currentDate || record.make_name != currentMake) {
            // ä¿å­˜ä¸Šä¸€ä¸ªåˆ†ç»„çš„ç»“æœ
            if (i &gt; 0) {
                results.push_back({
                    currentDate,
                    currentMake,
                    (int)leadSet.size(),
                    (int)partnerSet.size()
                });
            }

            // é‡ç½®å½“å‰åˆ†ç»„
            currentDate = record.date_id;
            currentMake = record.make_name;
            leadSet.clear();
            partnerSet.clear();
        }

        // æ·»åŠ å½“å‰è®°å½•
        leadSet.insert(record.lead_id);
        partnerSet.insert(record.partner_id);
    }

    // æ·»åŠ æœ€åä¸€ä¸ªåˆ†ç»„
    if (!sales.empty()) {
        results.push_back({
            currentDate,
            currentMake,
            (int)leadSet.size(),
            (int)partnerSet.size()
        });
    }

    return results;
}

int main() {
    vector&lt;DailySales&gt; sales = {
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1}
    };

    auto results = dailySalesAnalysisSorted(sales);

    cout &lt;&lt; "date_id\tmake_name\tunique_leads\tunique_partners" &lt;&lt; endl;
    for (const auto&amp; res : results) {
        cout &lt;&lt; res.date_id &lt;&lt; "\t" &lt;&lt; res.make_name &lt;&lt; "\t"
             &lt;&lt; res.unique_leads &lt;&lt; "\t" &lt;&lt; res.unique_partners &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<hr />

<h2 id="ä¸åŒè§£æ³•çš„å¯¹æ¯”å’Œä¼˜ç¼ºç‚¹">ä¸åŒè§£æ³•çš„å¯¹æ¯”å’Œä¼˜ç¼ºç‚¹</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
  <th>é€‚ç”¨åœºæ™¯</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>è§£æ³•ä¸€ï¼šGROUP BY + COUNT(DISTINCT)</strong></td>
  <td>æœ€ç®€å•ç›´è§‚ï¼ŒSQLåŸç”Ÿæ”¯æŒï¼Œæ•°æ®åº“ä¼˜åŒ–å¥½</td>
  <td>åœ¨æ•°æ®åº“å¤–å®ç°è¾ƒå¤æ‚</td>
  <td>æ•°æ®åº“æŸ¥è¯¢åœºæ™¯</td>
</tr>
<tr>
  <td><strong>è§£æ³•äºŒï¼šå¤åˆé”®å“ˆå¸Œæ˜ å°„</strong></td>
  <td>ä¸€æ¬¡éå†ï¼Œæ•ˆç‡é«˜ï¼Œå®ç°ç®€å•</td>
  <td>éœ€è¦é¢å¤–å†…å­˜å­˜å‚¨å“ˆå¸Œè¡¨</td>
  <td>å†…å­˜å……è¶³ï¼Œéœ€è¦é«˜æ€§èƒ½</td>
</tr>
<tr>
  <td><strong>è§£æ³•ä¸‰ï¼šæ’åº+éå†</strong></td>
  <td>ç©ºé—´å¤æ‚åº¦ä½ï¼Œä¸éœ€è¦å“ˆå¸Œè¡¨</td>
  <td>éœ€è¦æ’åºï¼Œæ—¶é—´å¤æ‚åº¦è¾ƒé«˜</td>
  <td>å†…å­˜å—é™ï¼Œæ•°æ®å·²æ’åºæˆ–æ¥è¿‘æ’åº</td>
</tr>
</tbody>
</table>

<h3 id="æ¨èæ–¹æ¡ˆ">æ¨èæ–¹æ¡ˆ</h3>

<ol>
<li><strong>æ•°æ®åº“åœºæ™¯</strong>ï¼šç›´æ¥ä½¿ç”¨è§£æ³•ä¸€çš„SQLè¯­å¥ï¼Œæœ€ç®€å•é«˜æ•ˆ</li>
<li><strong>å†…å­˜å……è¶³</strong>ï¼šä½¿ç”¨è§£æ³•äºŒï¼Œæ—¶é—´å¤æ‚åº¦O(n)ï¼Œ</li>
</ol>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 18:46:02</em></p>

<hr />

<h1 id="1806-è¿˜åŸæ’åˆ—çš„æœ€å°‘æ“ä½œæ­¥æ•°">1806. è¿˜åŸæ’åˆ—çš„æœ€å°‘æ“ä½œæ­¥æ•°</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, æ•°å­¦, æ¨¡æ‹Ÿ</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-2">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªå¶æ•° <code>n</code>â€‹â€‹â€‹â€‹â€‹â€‹ ï¼Œå·²çŸ¥å­˜åœ¨ä¸€ä¸ªé•¿åº¦ä¸º <code>n</code> çš„æ’åˆ— <code>perm</code> ï¼Œå…¶ä¸­ <code>perm[i] == i</code>â€‹ï¼ˆä¸‹æ ‡ <strong>ä» 0 å¼€å§‹</strong> è®¡æ•°ï¼‰ã€‚</p>

<p>ä¸€æ­¥æ“ä½œä¸­ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªæ–°æ•°ç»„ <code>arr</code> ï¼Œå¯¹äºæ¯ä¸ª <code>i</code> ï¼š</p>

<ul>
    <li>å¦‚æœ <code>i % 2 == 0</code> ï¼Œé‚£ä¹ˆ <code>arr[i] = perm[i / 2]</code></li>
    <li>å¦‚æœ <code>i % 2 == 1</code> ï¼Œé‚£ä¹ˆ <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code></li>
</ul>

<p>ç„¶åå°† <code>arr</code>â€‹â€‹ èµ‹å€¼â€‹â€‹ç»™ <code>perm</code> ã€‚</p>

<p>è¦æƒ³ä½¿ <code>perm</code> å›åˆ°æ’åˆ—åˆå§‹å€¼ï¼Œè‡³å°‘éœ€è¦æ‰§è¡Œå¤šå°‘æ­¥æ“ä½œï¼Ÿè¿”å›æœ€å°çš„ <strong>éé›¶</strong> æ“ä½œæ­¥æ•°ã€‚</p>

<p>Â </p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 2
<strong>è¾“å‡ºï¼š</strong>1
<strong>è§£é‡Šï¼š</strong>æœ€åˆï¼Œperm = [0,1]
ç¬¬ 1Â æ­¥æ“ä½œåï¼Œperm = [0,1]
æ‰€ä»¥ï¼Œä»…éœ€æ‰§è¡Œ 1 æ­¥æ“ä½œ</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 4
<strong>è¾“å‡ºï¼š</strong>2
<strong>è§£é‡Šï¼š</strong>æœ€åˆï¼Œperm = [0,1,2,3]
ç¬¬ 1Â æ­¥æ“ä½œåï¼Œperm = [0,2,1,3]
ç¬¬ 2Â æ­¥æ“ä½œåï¼Œperm = [0,1,2,3]
æ‰€ä»¥ï¼Œä»…éœ€æ‰§è¡Œ 2 æ­¥æ“ä½œ</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 6
<strong>è¾“å‡ºï¼š</strong>4
</pre>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>2 <= n <= 1000</code></li>
    <li><code>n</code>â€‹â€‹â€‹â€‹â€‹â€‹ æ˜¯ä¸€ä¸ªå¶æ•°</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-2">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-4">C++</h3>

<pre><code>class Solution {
public:
    int reinitializePermutation(int n) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public int reinitializePermutation(int n) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def reinitializePermutation(self, n: int) -&gt; int:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @return {number}
 */
var reinitializePermutation = function(n) {

};
</code></pre>

<h3 id="go-4">Go</h3>

<pre><code>func reinitializePermutation(n int) int {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>It is safe to assume the number of  operations isn't more than n</li>
<li>The number is small enough to apply a brute force solution.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-2">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>2
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-2">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-2">é¢˜ç›®åˆ†æ</h2>

<p>é¢˜ç›®æè¿°äº†ä¸€ä¸ªç‰¹å®šçš„å˜æ¢è§„åˆ™ï¼š
- åˆå§‹æ’åˆ—ï¼š<code>perm = [0, 1, 2, ..., n-1]</code>
- æ¯æ¬¡æ“ä½œæ ¹æ®è§„åˆ™ç”Ÿæˆæ–°æ•°ç»„ <code>arr</code>ï¼š
  - å¦‚æœ <code>i</code> æ˜¯å¶æ•°ï¼š<code>arr[i] = perm[i/2]</code>
  - å¦‚æœ <code>i</code> æ˜¯å¥‡æ•°ï¼š<code>arr[i] = perm[n/2 + (i-1)/2]</code>
- ç„¶åå°† <code>arr</code> èµ‹å€¼ç»™ <code>perm</code></p>

<p>æˆ‘ä»¬éœ€è¦æ‰¾åˆ°æœ€å°çš„æ­£æ•´æ•° <code>k</code>ï¼Œä½¿å¾—ç»è¿‡ <code>k</code> æ¬¡å˜æ¢åï¼Œ<code>perm</code> æ¢å¤åˆ°åˆå§‹çŠ¶æ€ã€‚</p>

<h2 id="å…³é”®è§‚å¯Ÿ">å…³é”®è§‚å¯Ÿ</h2>

<ol>
<li><p><strong>å˜æ¢è§„åˆ™çš„æœ¬è´¨</strong>ï¼š</p>

<ul>
<li>å¶æ•°ä½ç½® <code>i</code> çš„å…ƒç´ æ¥è‡ªåŸæ•°ç»„å‰åŠéƒ¨åˆ† <code>perm[i/2]</code></li>
<li>å¥‡æ•°ä½ç½® <code>i</code> çš„å…ƒç´ æ¥è‡ªåŸæ•°ç»„ååŠéƒ¨åˆ† <code>perm[n/2 + (i-1)/2]</code></li>
<li>è¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ª<strong>æ´—ç‰Œæ“ä½œ</strong>ï¼šå°†æ•°ç»„åˆ†æˆå‰åä¸¤åŠï¼Œç„¶åäº¤é”™åˆå¹¶</li>
</ul></li>
<li><p><strong>æ•°å­¦è¡¨ç¤º</strong>ï¼š</p>

<ul>
<li>å¯¹äºä½ç½® <code>i</code>ï¼Œå˜æ¢åçš„æ–°ä½ç½® <code>j</code> æ»¡è¶³ï¼š
<ul>
<li>å¦‚æœ <code>i &lt; n/2</code>ï¼Œåˆ™ <code>j = 2*i</code></li>
<li>å¦‚æœ <code>i â‰¥ n/2</code>ï¼Œåˆ™ <code>j = 2*(i - n/2) + 1</code></li>
</ul></li>
<li>è¿™å¯ä»¥ç»Ÿä¸€è¡¨ç¤ºä¸ºï¼š<code>j = (2*i) % (n-1)</code>ï¼Œå¯¹äº <code>i âˆˆ [0, n-2]</code></li>
<li>æ³¨æ„ï¼šæœ€åä¸€ä¸ªå…ƒç´  <code>n-1</code> å§‹ç»ˆä¿æŒåœ¨ä½ç½® <code>n-1</code></li>
</ul></li>
<li><p><strong>é—®é¢˜è½¬åŒ–</strong>ï¼š</p>

<ul>
<li>æ¯ä¸ªå…ƒç´ çš„ä½ç½®å˜åŒ–å½¢æˆä¸€ä¸ªç½®æ¢ï¼ˆæ’åˆ—ï¼‰</li>
<li>æˆ‘ä»¬éœ€è¦æ‰¾åˆ°è¿™ä¸ªç½®æ¢çš„é˜¶ï¼ˆæ‰€æœ‰å¾ªç¯é•¿åº¦çš„æœ€å°å…¬å€æ•°ï¼‰</li>
<li>ç‰¹åˆ«åœ°ï¼Œå…ƒç´  <code>0</code> å’Œ <code>n-1</code> çš„ä½ç½®ä¸å˜ï¼Œæ‰€ä»¥åªéœ€è€ƒè™‘ <code>1</code> åˆ° <code>n-2</code> çš„å…ƒç´ </li>
</ul></li>
</ol>

<h2 id="è§£æ³•ä¸€æ¨¡æ‹Ÿå˜æ¢è¿‡ç¨‹">è§£æ³•ä¸€ï¼šæ¨¡æ‹Ÿå˜æ¢è¿‡ç¨‹</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<p>ç›´æ¥æ¨¡æ‹Ÿå˜æ¢è¿‡ç¨‹ï¼Œç›´åˆ°æ•°ç»„æ¢å¤åˆ°åˆå§‹çŠ¶æ€ã€‚</p>

<h3 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO(n*k)ï¼Œå…¶ä¸­ k æ˜¯ç­”æ¡ˆ</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(n)</li>
</ul>

<h3 id="ä»£ç å®ç°-4">ä»£ç å®ç°</h3>

<h4 id="go-5">Go</h4>

<pre><code>func reinitializePermutation(n int) int {
    perm := make([]int, n)
    for i := 0; i &lt; n; i++ {
        perm[i] = i
    }

    arr := make([]int, n)
    steps := 0

    for {
        // æ‰§è¡Œä¸€æ¬¡å˜æ¢
        for i := 0; i &lt; n; i++ {
            if i%2 == 0 {
                arr[i] = perm[i/2]
            } else {
                arr[i] = perm[n/2 + (i-1)/2]
            }
        }

        steps++

        // æ£€æŸ¥æ˜¯å¦æ¢å¤
        restored := true
        for i := 0; i &lt; n; i++ {
            if arr[i] != i {
                restored = false
                break
            }
        }

        if restored {
            return steps
        }

        // å‡†å¤‡ä¸‹ä¸€æ¬¡è¿­ä»£
        copy(perm, arr)
    }
}
</code></pre>

<h4 id="c-5">C++</h4>

<pre><code>class Solution {
public:
    int reinitializePermutation(int n) {
        vector&lt;int&gt; perm(n);
        for (int i = 0; i &lt; n; i++) {
            perm[i] = i;
        }

        vector&lt;int&gt; arr(n);
        int steps = 0;

        while (true) {
            // æ‰§è¡Œä¸€æ¬¡å˜æ¢
            for (int i = 0; i &lt; n; i++) {
                if (i % 2 == 0) {
                    arr[i] = perm[i / 2];
                } else {
                    arr[i] = perm[n / 2 + (i - 1) / 2];
                }
            }

            steps++;

            // æ£€æŸ¥æ˜¯å¦æ¢å¤
            bool restored = true;
            for (int i = 0; i &lt; n; i++) {
                if (arr[i] != i) {
                    restored = false;
                    break;
                }
            }

            if (restored) {
                return steps;
            }

            // å‡†å¤‡ä¸‹ä¸€æ¬¡è¿­ä»£
            perm = arr;
        }
    }
};
</code></pre>

<h2 id="è§£æ³•äºŒè·Ÿè¸ªå•ä¸ªå…ƒç´ ">è§£æ³•äºŒï¼šè·Ÿè¸ªå•ä¸ªå…ƒç´ </h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<p>ç”±äºå˜æ¢æ˜¯ç¡®å®šæ€§çš„ï¼Œæˆ‘ä»¬å¯ä»¥åªè·Ÿè¸ªä¸€ä¸ªå…ƒç´ ï¼ˆæ¯”å¦‚å…ƒç´  <code>1</code>ï¼‰çš„ä½ç½®å˜åŒ–ï¼Œç›´åˆ°å®ƒå›åˆ°åŸå§‹ä½ç½®ã€‚å› ä¸ºæ‰€æœ‰å…ƒç´ éƒ½åœ¨å„è‡ªçš„å¾ªç¯ä¸­ï¼Œæ•´ä¸ªæ’åˆ—æ¢å¤çš„æ­¥æ•°æ˜¯æ‰€æœ‰å¾ªç¯é•¿åº¦çš„æœ€å°å…¬å€æ•°ï¼Œä½†è·Ÿè¸ªå•ä¸ªå…ƒç´ å¯ä»¥å¾—åˆ°ç­”æ¡ˆã€‚</p>

<h3 id="å¤æ‚åº¦åˆ†æ-2">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO(k)ï¼Œå…¶ä¸­ k æ˜¯ç­”æ¡ˆ</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(1)</li>
</ul>

<h3 id="ä»£ç å®ç°-5">ä»£ç å®ç°</h3>

<h4 id="go-6">Go</h4>

<pre><code>func reinitializePermutation(n int) int {
    if n == 2 {
        return 1
    }

    steps := 0
    pos := 1  // è·Ÿè¸ªå…ƒç´ 1çš„ä½ç½®

    for {
        // æ ¹æ®å½“å‰ä½ç½®è®¡ç®—ä¸‹ä¸€ä¸ªä½ç½®
        if pos &lt; n/2 {
            pos = 2 * pos
        } else {
            pos = 2 * (pos - n/2) + 1
        }

        steps++

        // å½“å…ƒç´ 1å›åˆ°ä½ç½®1æ—¶ï¼Œæ•´ä¸ªæ’åˆ—æ¢å¤
        if pos == 1 {
            return steps
        }
    }
}
</code></pre>

<h4 id="c-6">C++</h4>

<pre><code>class Solution {
public:
    int reinitializePermutation(int n) {
        if (n == 2) return 1;

        int steps = 0;
        int pos = 1;  // è·Ÿè¸ªå…ƒç´ 1çš„ä½ç½®

        do {
            // æ ¹æ®å½“å‰ä½ç½®è®¡ç®—ä¸‹ä¸€ä¸ªä½ç½®
            if (pos &lt; n / 2) {
                pos = 2 * pos;
            } else {
                pos = 2 * (pos - n / 2) + 1;
            }
            steps++;
        } while (pos != 1);

        return steps;
    }
};
</code></pre>

<h2 id="è§£æ³•ä¸‰æ•°å­¦å…¬å¼æ³•">è§£æ³•ä¸‰ï¼šæ•°å­¦å…¬å¼æ³•</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<p>è§‚å¯Ÿå˜æ¢å…¬å¼ï¼š<code>f(i) = (2*i) % (n-1)</code>ï¼Œå¯¹äº <code>i âˆˆ [1, n-2]</code>
- å…ƒç´  <code>0</code> å’Œ <code>n-1</code> å§‹ç»ˆä¸å˜
- æˆ‘ä»¬éœ€è¦æ‰¾åˆ°æœ€å°çš„ <code>k</code> ä½¿å¾— <code>(2^k * 1) % (n-1) = 1</code></p>

<p>è¿™ç­‰ä»·äºæ±‚ <code>2^k â‰¡ 1 (mod n-1)</code> çš„æœ€å°æ­£æ•´æ•°è§£ <code>k</code>ã€‚</p>

<h3 id="å¤æ‚åº¦åˆ†æ-3">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO(log n)</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(1)</li>
</ul>

<h3 id="ä»£ç å®ç°-6">ä»£ç å®ç°</h3>

<h4 id="go-7">Go</h4>

<pre><code>func reinitializePermutation(n int) int {
    if n == 2 {
        return 1
    }

    steps := 1
    powerOfTwo := 2 % (n - 1)

    for powerOfTwo != 1 {
        powerOfTwo = (powerOfTwo * 2) % (n - 1)
        steps++
    }

    return steps
}
</code></pre>

<h4 id="c-7">C++</h4>

<pre><code>class Solution {
public:
    int reinitializePermutation(int n) {
        if (n == 2) return 1;

        int steps = 1;
        int powerOfTwo = 2 % (n - 1);

        while (powerOfTwo != 1) {
            powerOfTwo = (powerOfTwo * 2) % (n - 1);
            steps++;
        }

        return steps;
    }
};
</code></pre>

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æ¨¡æ‹Ÿå˜æ¢</td>
  <td>O(n*k)</td>
  <td>O(n)</td>
  <td>ç›´è§‚ï¼Œæ˜“äºç†è§£</td>
  <td>æ•ˆç‡ä½ï¼Œnè¾ƒå¤§æ—¶æ…¢</td>
</tr>
<tr>
  <td>è·Ÿè¸ªå•ä¸ªå…ƒç´ </td>
  <td>O(k)</td>
  <td>O(1)</td>
  <td>æ•ˆç‡é«˜ï¼Œç©ºé—´ä¼˜</td>
  <td>éœ€è¦æ•°å­¦æ´å¯Ÿ</td>
</tr>
<tr>
  <td>æ•°å­¦å…¬å¼æ³•</td>
  <td>O(log n)</td>
  <td>O(1)</td>
  <td>æ•ˆç‡æœ€é«˜</td>
  <td>éœ€è¦æ•°å­¦æ¨å¯¼ï¼Œä¸æ˜“ç†è§£</td>
</tr>
</tbody>
</table>

<h2 id="æ¨èè§£æ³•">æ¨èè§£æ³•</h2>

<p><strong>è§£æ³•äºŒï¼ˆè·Ÿè¸ªå•ä¸ªå…ƒç´ ï¼‰</strong> æ˜¯æœ€ä½³é€‰æ‹©ï¼š
1. æ•ˆç‡é«˜ï¼šO(k) æ—¶é—´å¤æ‚åº¦ï¼Œk é€šå¸¸è¿œå°äº n
2. ç©ºé—´ä¼˜ï¼šO(1) ç©ºé—´å¤æ‚åº¦
3. æ˜“äºå®ç°ï¼šä»£ç ç®€æ´ï¼Œé€»è¾‘æ¸…æ™°
4. ä¸éœ€è¦å¤æ‚çš„æ•°å­¦æ¨å¯¼</p>

<p>å¯¹äºæœ¬é¢˜ï¼Œç”±äº n æœ€å¤§ä¸º 1000ï¼Œæ‰€æœ‰è§£æ³•éƒ½èƒ½é€šè¿‡ï¼Œä½†è§£æ³•äºŒåœ¨æ•ˆç‡å’Œå®ç°éš¾åº¦ä¸Šå–å¾—äº†æœ€ä½³å¹³è¡¡ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 18:46:54</em></p>

<hr />

<h1 id="1-ä¸¤æ•°ä¹‹å’Œ">1. ä¸¤æ•°ä¹‹å’Œ</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, å“ˆå¸Œè¡¨</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/two-sum/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-3">é¢˜ç›®æè¿°</h2>

<p>ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ <code>nums</code>&nbsp;å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ <code>target</code>ï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º <strong>å’Œä¸ºç›®æ ‡å€¼ </strong><em><code>target</code></em>&nbsp; çš„é‚£&nbsp;<strong>ä¸¤ä¸ª</strong>&nbsp;æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚</p>

<p>ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚</p>

<p>ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [2,7,11,15], target = 9
<strong>è¾“å‡ºï¼š</strong>[0,1]
<strong>è§£é‡Šï¼š</strong>å› ä¸º nums[0] + nums[1] == 9 ï¼Œè¿”å› [0, 1] ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [3,2,4], target = 6
<strong>è¾“å‡ºï¼š</strong>[1,2]
</pre>

<p><strong class="example">ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [3,3], target = 6
<strong>è¾“å‡ºï¼š</strong>[0,1]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
    <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
    <li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
    <li><strong>åªä¼šå­˜åœ¨ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆ</strong></li>
</ul>

<p>&nbsp;</p>

<p><strong>è¿›é˜¶ï¼š</strong>ä½ å¯ä»¥æƒ³å‡ºä¸€ä¸ªæ—¶é—´å¤æ‚åº¦å°äº <code>O(n<sup>2</sup>)</code> çš„ç®—æ³•å—ï¼Ÿ</p>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-3">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-8">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {

    }
};
</code></pre>

<h3 id="java-2">Java</h3>

<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {

    }
}
</code></pre>

<h3 id="python3-2">Python3</h3>

<pre><code>class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:

</code></pre>

<h3 id="javascript-2">JavaScript</h3>

<pre><code>/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {

};
</code></pre>

<h3 id="go-8">Go</h3>

<pre><code>func twoSum(nums []int, target int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º-2">æç¤º</h2>

<ol>
<li>A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions just for completeness. It is from these brute force solutions that you can come up with optimizations.</li>
<li>So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?</li>
<li>The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-3">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>[2,7,11,15]
9
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-3">AI è§£ç­” (DeepSeek)</h2>

<h1 id="ä¸¤æ•°ä¹‹å’Œ-è¯¦ç»†è§£é¢˜åˆ†æ">ä¸¤æ•°ä¹‹å’Œ - è¯¦ç»†è§£é¢˜åˆ†æ</h1>

<h2 id="1-é¢˜ç›®åˆ†æå’Œè§£é¢˜æ€è·¯">1. é¢˜ç›®åˆ†æå’Œè§£é¢˜æ€è·¯</h2>

<p><strong>é—®é¢˜æ ¸å¿ƒ</strong>ï¼šåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ä¸¤ä¸ªæ•°ï¼Œä½¿å®ƒä»¬çš„å’Œç­‰äºç›®æ ‡å€¼ targetã€‚</p>

<p><strong>å…³é”®çº¦æŸ</strong>ï¼š
- ä¸èƒ½ä½¿ç”¨åŒä¸€ä¸ªå…ƒç´ ä¸¤æ¬¡
- å‡è®¾åªæœ‰ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆ
- éœ€è¦è¿”å›å…ƒç´ çš„ä¸‹æ ‡ï¼ˆä¸æ˜¯å€¼æœ¬èº«ï¼‰</p>

<p><strong>åŸºæœ¬æ€è·¯</strong>ï¼š
1. <strong>æš´åŠ›æšä¸¾</strong>ï¼šéå†æ‰€æœ‰å¯èƒ½çš„å…ƒç´ å¯¹ï¼Œæ£€æŸ¥å®ƒä»¬çš„å’Œæ˜¯å¦ç­‰äº target
2. <strong>å“ˆå¸Œè¡¨ä¼˜åŒ–</strong>ï¼šåˆ©ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å·²éå†å…ƒç´ çš„å€¼å’Œä¸‹æ ‡ï¼Œå¿«é€ŸæŸ¥æ‰¾ complement = target - current</p>

<h2 id="2-ä¸åŒè§£æ³•åŠå®ç°">2. ä¸åŒè§£æ³•åŠå®ç°</h2>

<h3 id="è§£æ³•ä¸€æš´åŠ›æšä¸¾æ³•">è§£æ³•ä¸€ï¼šæš´åŠ›æšä¸¾æ³•</h3>

<p><strong>æ€è·¯</strong>ï¼šä½¿ç”¨ä¸¤å±‚å¾ªç¯éå†æ‰€æœ‰å¯èƒ½çš„å…ƒç´ ç»„åˆ</p>

<pre><code>// Go å®ç°
func twoSum(nums []int, target int) []int {
    n := len(nums)
    for i := 0; i &lt; n; i++ {
        for j := i + 1; j &lt; n; j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        int n = nums.size();
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)ï¼Œä¸¤å±‚å¾ªç¯
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å¸¸æ•°ç©ºé—´</p>

<h3 id="è§£æ³•äºŒå“ˆå¸Œè¡¨æ³•ä¸€æ¬¡éå†">è§£æ³•äºŒï¼šå“ˆå¸Œè¡¨æ³•ï¼ˆä¸€æ¬¡éå†ï¼‰</h3>

<p><strong>æ€è·¯</strong>ï¼šéå†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œæ£€æŸ¥ target - nums[i] æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­</p>

<pre><code>// Go å®ç°
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)

    for i, num := range nums {
        complement := target - num
        if idx, exists := hashMap[complement]; exists {
            return []int{idx, i}
        }
        hashMap[num] = i
    }
    return nil
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hashMap;

        for (int i = 0; i &lt; nums.size(); i++) {
            int complement = target - nums[i];
            if (hashMap.find(complement) != hashMap.end()) {
                return {hashMap[complement], i};
            }
            hashMap[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œåªéœ€ä¸€æ¬¡éå†
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦å­˜å‚¨æ‰€æœ‰å…ƒç´ </p>

<h3 id="è§£æ³•ä¸‰å“ˆå¸Œè¡¨æ³•ä¸¤æ¬¡éå†">è§£æ³•ä¸‰ï¼šå“ˆå¸Œè¡¨æ³•ï¼ˆä¸¤æ¬¡éå†ï¼‰</h3>

<p><strong>æ€è·¯</strong>ï¼šå…ˆæ„å»ºå®Œæ•´çš„å“ˆå¸Œè¡¨ï¼Œå†æŸ¥æ‰¾åŒ¹é…å¯¹</p>

<pre><code>// Go å®ç°
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)

    // ç¬¬ä¸€æ¬¡éå†ï¼šæ„å»ºå“ˆå¸Œè¡¨
    for i, num := range nums {
        hashMap[num] = i
    }

    // ç¬¬äºŒæ¬¡éå†ï¼šæŸ¥æ‰¾åŒ¹é…
    for i, num := range nums {
        complement := target - num
        if idx, exists := hashMap[complement]; exists &amp;&amp; idx != i {
            return []int{i, idx}
        }
    }
    return nil
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hashMap;

        // ç¬¬ä¸€æ¬¡éå†ï¼šæ„å»ºå“ˆå¸Œè¡¨
        for (int i = 0; i &lt; nums.size(); i++) {
            hashMap[nums[i]] = i;
        }

        // ç¬¬äºŒæ¬¡éå†ï¼šæŸ¥æ‰¾åŒ¹é…
        for (int i = 0; i &lt; nums.size(); i++) {
            int complement = target - nums[i];
            if (hashMap.find(complement) != hashMap.end() &amp;&amp; hashMap[complement] != i) {
                return {i, hashMap[complement]};
            }
        }
        return {};
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œä¸¤æ¬¡éå†
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œéœ€è¦å­˜å‚¨æ‰€æœ‰å…ƒç´ </p>

<h2 id="3-è§£æ³•å¯¹æ¯”å’Œä¼˜ç¼ºç‚¹">3. è§£æ³•å¯¹æ¯”å’Œä¼˜ç¼ºç‚¹</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æš´åŠ›æšä¸¾</td>
  <td>O(nÂ²)</td>
  <td>O(1)</td>
  <td>å®ç°ç®€å•ï¼Œæ— éœ€é¢å¤–ç©ºé—´</td>
  <td>æ•ˆç‡ä½ï¼Œä¸é€‚åˆå¤§æ•°æ®é‡</td>
</tr>
<tr>
  <td>å“ˆå¸Œè¡¨ï¼ˆä¸€æ¬¡éå†ï¼‰</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>æ•ˆç‡æœ€é«˜ï¼Œä¸€æ¬¡éå†å®Œæˆ</td>
  <td>éœ€è¦é¢å¤–ç©ºé—´</td>
</tr>
<tr>
  <td>å“ˆå¸Œè¡¨ï¼ˆä¸¤æ¬¡éå†ï¼‰</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>é€»è¾‘æ¸…æ™°ï¼Œåˆ†æ­¥æ˜ç¡®</td>
  <td>éœ€è¦ä¸¤æ¬¡éå†</td>
</tr>
</tbody>
</table>

<h2 id="4-æ¨èè§£æ³•">4. æ¨èè§£æ³•</h2>

<p><strong>æ¨èä½¿ç”¨è§£æ³•äºŒï¼ˆå“ˆå¸Œè¡¨ä¸€æ¬¡éå†ï¼‰</strong>ï¼ŒåŸå› ï¼š
1. <strong>æ•ˆç‡æœ€é«˜</strong>ï¼šåªéœ€ä¸€æ¬¡éå†å³å¯å®Œæˆ
2. <strong>å¤„ç†é‡å¤å…ƒç´ </strong>ï¼šå½“é‡åˆ°é‡å¤å…ƒç´ æ—¶ï¼Œåå‡ºç°çš„ä¼šè¦†ç›–å…ˆå‡ºç°çš„ï¼Œè¿™æ°å¥½ç¬¦åˆé¢˜ç›®è¦æ±‚ï¼ˆä¸èƒ½ä½¿ç”¨åŒä¸€ä¸ªå…ƒç´ ä¸¤æ¬¡ï¼‰
3. <strong>ä»£ç ç®€æ´</strong>ï¼šé€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤</p>

<h2 id="5-ç‰¹æ®Šæƒ…å†µå¤„ç†">5. ç‰¹æ®Šæƒ…å†µå¤„ç†</h2>

<ol>
<li><p><strong>é‡å¤å…ƒç´ </strong>ï¼šå¦‚ nums = [3, 3], target = 6</p>

<ul>
<li>å“ˆå¸Œè¡¨æ³•èƒ½æ­£ç¡®å¤„ç†ï¼Œå› ä¸ºæŸ¥æ‰¾æ—¶æ£€æŸ¥äº†ä¸‹æ ‡æ˜¯å¦ç›¸åŒ</li>
</ul></li>
<li><p><strong>è´Ÿæ•°å’Œå¤§æ•°</strong>ï¼šé¢˜ç›®èŒƒå›´æ˜¯ -10â¹ åˆ° 10â¹</p>

<ul>
<li>å“ˆå¸Œè¡¨æ³•ä¸å—æ•°å€¼èŒƒå›´å½±å“</li>
</ul></li>
<li><p><strong>æ— è§£æƒ…å†µ</strong>ï¼šé¢˜ç›®ä¿è¯æœ‰ä¸”åªæœ‰ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆï¼Œå®é™…åº”ç”¨ä¸­å¯è¿”å›ç©ºæ•°ç»„æˆ–ç‰¹å®šå€¼</p></li>
</ol>

<h2 id="6-è¿›é˜¶æ€è€ƒ">6. è¿›é˜¶æ€è€ƒ</h2>

<p>å¯¹äºæ›´å¤æ‚çš„æƒ…å†µï¼ˆå¦‚éœ€è¦è¿”å›æ‰€æœ‰å¯èƒ½çš„è§£ï¼‰ï¼Œå¯ä»¥è€ƒè™‘ï¼š
1. ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ‰€æœ‰ç›¸åŒå€¼çš„ä¸‹æ ‡åˆ—è¡¨
2. å…ˆæ’åºå†ä½¿ç”¨åŒæŒ‡é’ˆæ³•ï¼ˆä½†éœ€è¦é¢å¤–å¤„ç†ä¸‹æ ‡ä¿¡æ¯ï¼‰</p>

<p><strong>æ€»ç»“</strong>ï¼šä¸¤æ•°ä¹‹å’Œæ˜¯å“ˆå¸Œè¡¨åº”ç”¨çš„ç»å…¸ä¾‹é¢˜ï¼ŒæŒæ¡å“ˆå¸Œè¡¨è§£æ³•å¯¹äºè§£å†³ç±»ä¼¼é—®é¢˜ï¼ˆå¦‚ä¸‰æ•°ä¹‹å’Œã€å››æ•°ä¹‹å’Œï¼‰æœ‰é‡è¦å¸®åŠ©ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 19:05:33</em></p>

<hr />

<h1 id="2019-è§£å‡ºæ•°å­¦è¡¨è¾¾å¼çš„å­¦ç”Ÿåˆ†æ•°">2019. è§£å‡ºæ•°å­¦è¡¨è¾¾å¼çš„å­¦ç”Ÿåˆ†æ•°</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: æ ˆ, è®°å¿†åŒ–, æ•°ç»„, å“ˆå¸Œè¡¨, æ•°å­¦, å­—ç¬¦ä¸², åŠ¨æ€è§„åˆ’</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/the-score-of-students-solving-math-expression/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-4">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²&nbsp;<code>s</code>&nbsp;ï¼Œå®ƒ <strong>åª</strong> åŒ…å«æ•°å­—&nbsp;<code>0-9</code>&nbsp;ï¼ŒåŠ æ³•è¿ç®—ç¬¦&nbsp;<code>'+'</code>&nbsp;å’Œä¹˜æ³•è¿ç®—ç¬¦&nbsp;<code>'*'</code>&nbsp;ï¼Œè¿™ä¸ªå­—ç¬¦ä¸²è¡¨ç¤ºä¸€ä¸ª&nbsp;<strong>åˆæ³•</strong>&nbsp;çš„åªå«æœ‰&nbsp;<strong>ä¸ªä½æ•°</strong><strong>æ•°å­—</strong>&nbsp;çš„æ•°å­¦è¡¨è¾¾å¼ï¼ˆæ¯”æ–¹è¯´&nbsp;<code>3+5*2</code>ï¼‰ã€‚æœ‰ <code>n</code>&nbsp;ä½å°å­¦ç”Ÿå°†è®¡ç®—è¿™ä¸ªæ•°å­¦è¡¨è¾¾å¼ï¼Œå¹¶éµå¾ªå¦‚ä¸‹ <strong>è¿ç®—é¡ºåº</strong>&nbsp;ï¼š</p>

<ol>
    <li>æŒ‰ç…§ <strong>ä»å·¦åˆ°å³</strong>&nbsp;çš„é¡ºåºè®¡ç®— <strong>ä¹˜æ³•</strong>&nbsp;ï¼Œç„¶å</li>
    <li>æŒ‰ç…§ <strong>ä»å·¦åˆ°å³</strong>&nbsp;çš„é¡ºåºè®¡ç®— <strong>åŠ æ³•</strong>&nbsp;ã€‚</li>
</ol>

<p>ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º <code>n</code>&nbsp;çš„æ•´æ•°æ•°ç»„&nbsp;<code>answers</code>&nbsp;ï¼Œè¡¨ç¤ºæ¯ä½å­¦ç”Ÿæäº¤çš„ç­”æ¡ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯ç»™ <code>answer</code>&nbsp;æ•°ç»„æŒ‰ç…§å¦‚ä¸‹ <strong>è§„åˆ™</strong>&nbsp;æ‰“åˆ†ï¼š</p>

<ul>
    <li>å¦‚æœä¸€ä½å­¦ç”Ÿçš„ç­”æ¡ˆ <strong>ç­‰äº</strong>&nbsp;è¡¨è¾¾å¼çš„æ­£ç¡®ç»“æœï¼Œè¿™ä½å­¦ç”Ÿå°†å¾—åˆ° <code>5</code>&nbsp;åˆ†ã€‚</li>
    <li>å¦åˆ™ï¼Œå¦‚æœç­”æ¡ˆç”±&nbsp;<strong>ä¸€å¤„æˆ–å¤šå¤„é”™è¯¯çš„è¿ç®—é¡ºåº</strong>&nbsp;è®¡ç®—å¾—åˆ°ï¼Œé‚£ä¹ˆè¿™ä½å­¦ç”Ÿèƒ½å¾—åˆ° <code>2</code>&nbsp;åˆ†ã€‚</li>
    <li>å¦åˆ™ï¼Œè¿™ä½å­¦ç”Ÿå°†å¾—åˆ° <code>0</code>&nbsp;åˆ†ã€‚</li>
</ul>

<p>è¯·ä½ è¿”å›æ‰€æœ‰å­¦ç”Ÿçš„åˆ†æ•°å’Œã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png" style="width: 678px; height: 109px;" /></p>

<pre>
<b>è¾“å…¥ï¼š</b>s = "7+3*1*2", answers = [20,13,42]
<b>è¾“å‡ºï¼š</b>7
<b>è§£é‡Šï¼š</b>å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ­£ç¡®ç­”æ¡ˆä¸º 13 ï¼Œå› æ­¤æœ‰ä¸€ä½å­¦ç”Ÿå¾—åˆ†ä¸º 5 åˆ†ï¼š[20,<em><strong>13</strong></em>,42] ã€‚
ä¸€ä½å­¦ç”Ÿå¯èƒ½é€šè¿‡é”™è¯¯çš„è¿ç®—é¡ºåºå¾—åˆ°ç»“æœ 20 ï¼š7+3=10ï¼Œ10*1=10ï¼Œ10*2=20 ã€‚æ‰€ä»¥è¿™ä½å­¦ç”Ÿå¾—åˆ†ä¸º 2 åˆ†ï¼š[<em><strong>20</strong></em>,13,42] ã€‚
æ‰€æœ‰å­¦ç”Ÿå¾—åˆ†åˆ†åˆ«ä¸ºï¼š[2,5,0] ã€‚æ‰€æœ‰å¾—åˆ†ä¹‹å’Œä¸º 2+5+0=7 ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>s = "3+5*2", answers = [13,0,10,13,13,16,16]
<b>è¾“å‡ºï¼š</b>19
<b>è§£é‡Šï¼š</b>è¡¨è¾¾å¼çš„æ­£ç¡®ç»“æœä¸º 13 ï¼Œæ‰€ä»¥æœ‰ 3 ä½å­¦ç”Ÿå¾—åˆ° 5 åˆ†ï¼š[<em><strong>13</strong></em>,0,10,<em><strong>13</strong></em>,<em><strong>13</strong></em>,16,16] ã€‚
å­¦ç”Ÿå¯èƒ½é€šè¿‡é”™è¯¯çš„è¿ç®—é¡ºåºå¾—åˆ°ç»“æœ 16 ï¼š3+5=8ï¼Œ8*2=16 ã€‚æ‰€ä»¥ä¸¤ä½å­¦ç”Ÿå¾—åˆ° 2 åˆ†ï¼š[13,0,10,13,13,<em><strong>16</strong></em>,<em><strong>16</strong></em>] ã€‚
æ‰€æœ‰å­¦ç”Ÿå¾—åˆ†åˆ†åˆ«ä¸ºï¼š[5,0,0,5,5,2,2] ã€‚æ‰€æœ‰å¾—åˆ†ä¹‹å’Œä¸º 5+0+0+5+5+2+2=19 ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>s = "6+0*1", answers = [12,9,6,4,8,6]
<b>è¾“å‡ºï¼š</b>10
<b>è§£é‡Šï¼š</b>è¡¨è¾¾å¼çš„æ­£ç¡®ç»“æœä¸º 6 ã€‚
å¦‚æœä¸€ä½å­¦ç”Ÿé€šè¿‡é”™è¯¯çš„è¿ç®—é¡ºåºè®¡ç®—è¯¥è¡¨è¾¾å¼ï¼Œç»“æœä»ä¸º 6 ã€‚
æ ¹æ®æ‰“åˆ†è§„åˆ™ï¼Œè¿ç®—é¡ºåºé”™è¯¯çš„å­¦ç”Ÿä¹Ÿå°†å¾—åˆ° 5 åˆ†ï¼ˆå› ä¸ºä»–ä»¬ä»ç„¶å¾—åˆ°äº†æ­£ç¡®çš„ç»“æœï¼‰ï¼Œè€Œä¸æ˜¯ 2 åˆ†ã€‚
æ‰€æœ‰å­¦ç”Ÿå¾—åˆ†åˆ†åˆ«ä¸ºï¼š[0,0,5,0,0,5] ã€‚æ‰€æœ‰å¾—åˆ†ä¹‹å’Œä¸º 10 åˆ†ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>3 &lt;= s.length &lt;= 31</code></li>
    <li><code>s</code>&nbsp;è¡¨ç¤ºä¸€ä¸ªåªåŒ…å«&nbsp;<code>0-9</code>&nbsp;ï¼Œ<code>'+'</code>&nbsp;å’Œ&nbsp;<code>'*'</code>&nbsp;çš„åˆæ³•è¡¨è¾¾å¼ã€‚</li>
    <li>è¡¨è¾¾å¼ä¸­æ‰€æœ‰æ•´æ•°è¿ç®—æ•°å­—éƒ½åœ¨é—­åŒºé—´&nbsp;<code>[0, 9]</code>&nbsp;ä»¥å†…ã€‚</li>
    <li><code>1 &lt;=</code>&nbsp;æ•°å­¦è¡¨è¾¾å¼ä¸­æ‰€æœ‰è¿ç®—ç¬¦æ•°ç›®ï¼ˆ<code>'+'</code> å’Œ&nbsp;<code>'*'</code>ï¼‰&nbsp;<code>&lt;= 15</code></li>
    <li>æµ‹è¯•æ•°æ®ä¿è¯æ­£ç¡®è¡¨è¾¾å¼ç»“æœåœ¨èŒƒå›´&nbsp;<code>[0, 1000]</code>&nbsp;ä»¥å†…ã€‚</li>
    <li>æµ‹è¯•ç”¨ä¾‹ä¿è¯ä¹˜æ³•ä¸­é—´æ­¥éª¤ä¸­çš„å€¼æ°¸è¿œä¸ä¼šè¶…è¿‡ <code>10<sup>9</sup></code>ã€‚</li>
    <li><code>n == answers.length</code></li>
    <li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
    <li><code>0 &lt;= answers[i] &lt;= 1000</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-4">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-9">C++</h3>

<pre><code>class Solution {
public:
    int scoreOfStudents(string s, vector&lt;int&gt;&amp; answers) {

    }
};
</code></pre>

<h3 id="java-3">Java</h3>

<pre><code>class Solution {
    public int scoreOfStudents(String s, int[] answers) {

    }
}
</code></pre>

<h3 id="python3-3">Python3</h3>

<pre><code>class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -&gt; int:

</code></pre>

<h3 id="javascript-3">JavaScript</h3>

<pre><code>/**
 * @param {string} s
 * @param {number[]} answers
 * @return {number}
 */
var scoreOfStudents = function(s, answers) {

};
</code></pre>

<h3 id="go-9">Go</h3>

<pre><code>func scoreOfStudents(s string, answers []int) int {

}
</code></pre>

<hr />

<h2 id="æç¤º-3">æç¤º</h2>

<ol>
<li>The number of operators in the equation is less. Could you find the right answer then generate all possible answers using different orders of operations?</li>
<li>Divide the equation into blocks separated by the operators, and use memoization on the results of blocks for optimization.</li>
<li>Use set and the max limit of the answer for further optimization.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-4">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>"7+3*1*2"
[20,13,42]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-4">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-3">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ªå…³äºæ•°å­¦è¡¨è¾¾å¼è®¡ç®—å’Œé”™è¯¯è¿ç®—é¡ºåºå¾—åˆ†çš„é¢˜ç›®ã€‚å…³é”®ç‚¹å¦‚ä¸‹ï¼š</p>

<ol>
<li><strong>åˆæ³•è¡¨è¾¾å¼</strong>ï¼šåªåŒ…å«æ•°å­— 0-9ã€'+' å’Œ '*'ï¼Œæ•°å­—éƒ½æ˜¯ä¸ªä½æ•°</li>
<li><strong>æ­£ç¡®è®¡ç®—é¡ºåº</strong>ï¼šå…ˆè®¡ç®—æ‰€æœ‰ä¹˜æ³•ï¼ˆä»å·¦åˆ°å³ï¼‰ï¼Œå†è®¡ç®—æ‰€æœ‰åŠ æ³•ï¼ˆä»å·¦åˆ°å³ï¼‰</li>
<li><strong>å¾—åˆ†è§„åˆ™</strong>ï¼š
<ul>
<li>ç­”æ¡ˆç­‰äºæ­£ç¡®ç»“æœï¼š5åˆ†</li>
<li>ç­”æ¡ˆé€šè¿‡é”™è¯¯è¿ç®—é¡ºåºå¾—åˆ°ï¼ˆä½†ç»“æœæ­£ç¡®æ—¶ä»å¾—5åˆ†ï¼‰ï¼š2åˆ†</li>
<li>å…¶ä»–ï¼š0åˆ†</li>
</ul></li>
<li><strong>éœ€è¦è®¡ç®—</strong>ï¼šæ‰€æœ‰å­¦ç”Ÿå¾—åˆ†æ€»å’Œ</li>
</ol>

<p><strong>æ ¸å¿ƒæŒ‘æˆ˜</strong>ï¼šéœ€è¦æ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„è¿ç®—é¡ºåºï¼ˆåŒ…æ‹¬æ­£ç¡®å’Œé”™è¯¯çš„ï¼‰èƒ½äº§ç”Ÿçš„ç»“æœé›†åˆã€‚</p>

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="å…³é”®è§‚å¯Ÿ-2">å…³é”®è§‚å¯Ÿ</h3>

<ol>
<li>è¡¨è¾¾å¼ä¸­çš„æ•°å­—éƒ½æ˜¯ä¸ªä½æ•°ï¼ˆ0-9ï¼‰</li>
<li>è¿ç®—ç¬¦åªæœ‰ '+' å’Œ '*'</li>
<li>é”™è¯¯è¿ç®—é¡ºåºæ„å‘³ç€å¯ä»¥ä»»æ„é€‰æ‹©å…ˆè®¡ç®—å“ªä¸ªè¿ç®—ï¼Œè€Œä¸æ˜¯ä¸¥æ ¼æŒ‰ç…§å…ˆä¹˜ååŠ </li>
<li>è¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ª<strong>è¡¨è¾¾å¼æ‰€æœ‰å¯èƒ½æ±‚å€¼ç»“æœ</strong>çš„é—®é¢˜</li>
</ol>

<h3 id="é—®é¢˜è½¬åŒ–">é—®é¢˜è½¬åŒ–</h3>

<p>é¢˜ç›®ç­‰ä»·äºï¼šç»™å®šä¸€ä¸ªç”±æ•°å­—å’Œ '+'ã€'*' ç»„æˆçš„è¡¨è¾¾å¼ï¼Œæ±‚ï¼š
1. æŒ‰ç…§å…ˆä¹˜ååŠ è§„åˆ™çš„æ­£ç¡®ç»“æœ
2. æ‰€æœ‰å¯èƒ½çš„è¿ç®—é¡ºåºï¼ˆä»»æ„ç»“åˆé¡ºåºï¼‰èƒ½äº§ç”Ÿçš„ç»“æœé›†åˆ</p>

<p>ç„¶åå¯¹æ¯ä¸ªå­¦ç”Ÿçš„ç­”æ¡ˆï¼š
- å¦‚æœç­‰äºæ­£ç¡®ç»“æœï¼š5åˆ†
- å¦åˆ™å¦‚æœåœ¨æ‰€æœ‰å¯èƒ½ç»“æœé›†åˆä¸­ï¼š2åˆ†
- å¦åˆ™ï¼š0åˆ†</p>

<h2 id="è§£æ³•ä¸€åŒºé—´dpåŠ¨æ€è§„åˆ’">è§£æ³•ä¸€ï¼šåŒºé—´DPï¼ˆåŠ¨æ€è§„åˆ’ï¼‰</h2>

<h3 id="æ€è·¯-4">æ€è·¯</h3>

<p>ä½¿ç”¨åŠ¨æ€è§„åˆ’è®¡ç®—æ¯ä¸ªå­è¡¨è¾¾å¼çš„æ‰€æœ‰å¯èƒ½ç»“æœï¼š
- <code>dp[i][j]</code> è¡¨ç¤ºä»ç¬¬ i ä¸ªæ•°å­—åˆ°ç¬¬ j ä¸ªæ•°å­—ï¼ˆæŒ‰æ•°å­—ç´¢å¼•ï¼‰çš„æ‰€æœ‰å¯èƒ½ç»“æœé›†åˆ
- é€šè¿‡æšä¸¾åˆ†å‰²ç‚¹ kï¼Œå°†è¡¨è¾¾å¼åˆ†ä¸ºå·¦å³ä¸¤éƒ¨åˆ†ï¼Œç„¶åæ ¹æ®è¿ç®—ç¬¦ç»„åˆç»“æœ</p>

<h3 id="è¯¦ç»†æ­¥éª¤">è¯¦ç»†æ­¥éª¤</h3>

<ol>
<li>æå–æ‰€æœ‰æ•°å­—å’Œè¿ç®—ç¬¦</li>
<li>å®šä¹‰ <code>dp[i][j]</code> ä¸ºé›†åˆï¼Œå­˜å‚¨å­è¡¨è¾¾å¼ <code>nums[i..j]</code> çš„æ‰€æœ‰å¯èƒ½ç»“æœ</li>
<li>çŠ¶æ€è½¬ç§»ï¼š
<ul>
<li>å¦‚æœ i == jï¼š<code>dp[i][j] = {nums[i]}</code></li>
<li>å¦åˆ™ï¼šæšä¸¾åˆ†å‰²ç‚¹ k (i â‰¤ k &lt; j)
<ul>
<li>è¿ç®—ç¬¦ä¸º '+'ï¼š<code>dp[i][j] âˆª= {a+b | aâˆˆdp[i][k], bâˆˆdp[k+1][j]}</code></li>
<li>è¿ç®—ç¬¦ä¸º '*'ï¼š<code>dp[i][j] âˆª= {a*b | aâˆˆdp[i][k], bâˆˆdp[k+1][j]}</code></li>
</ul></li>
</ul></li>
<li>è®¡ç®—æ‰€æœ‰å¯èƒ½ç»“æœé›†åˆ</li>
<li>è®¡ç®—æ­£ç¡®ç»“æœï¼ˆå…ˆä¹˜ååŠ ï¼‰</li>
<li>æ ¹æ®è§„åˆ™è®¡ç®—å¾—åˆ†</li>
</ol>

<h3 id="ä»£ç å®ç°-7">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>func scoreOfStudents(s string, answers []int) int {
    n := len(s)
    // æå–æ•°å­—å’Œè¿ç®—ç¬¦
    nums := []int{}
    ops := []byte{}
    for i := 0; i &lt; n; i++ {
        if i%2 == 0 {
            nums = append(nums, int(s[i]-'0'))
        } else {
            ops = append(ops, s[i])
        }
    }

    m := len(nums)
    // dp[i][j] å­˜å‚¨æ‰€æœ‰å¯èƒ½ç»“æœ
    dp := make([][]map[int]bool, m)
    for i := range dp {
        dp[i] = make([]map[int]bool, m)
        for j := range dp[i] {
            dp[i][j] = make(map[int]bool)
        }
    }

    // åˆå§‹åŒ–ï¼šå•ä¸ªæ•°å­—
    for i := 0; i &lt; m; i++ {
        dp[i][i][nums[i]] = true
    }

    // åŒºé—´DP
    for length := 2; length &lt;= m; length++ {
        for i := 0; i+length-1 &lt; m; i++ {
            j := i + length - 1
            for k := i; k &lt; j; k++ {
                op := ops[k]
                for a := range dp[i][k] {
                    for b := range dp[k+1][j] {
                        if op == '+' {
                            sum := a + b
                            if sum &lt;= 1000 {
                                dp[i][j][sum] = true
                            }
                        } else { // '*'
                            prod := a * b
                            if prod &lt;= 1000 {
                                dp[i][j][prod] = true
                            }
                        }
                    }
                }
            }
        }
    }

    // æ‰€æœ‰å¯èƒ½ç»“æœ
    allResults := dp[0][m-1]

    // è®¡ç®—æ­£ç¡®ç»“æœï¼ˆå…ˆä¹˜ååŠ ï¼‰
    correctResult := calculateCorrect(s)

    // è®¡ç®—æ€»åˆ†
    totalScore := 0
    for _, ans := range answers {
        if ans == correctResult {
            totalScore += 5
        } else if allResults[ans] {
            totalScore += 2
        }
    }

    return totalScore
}

func calculateCorrect(s string) int {
    // å…ˆå¤„ç†ä¹˜æ³•
    nums := []int{}
    ops := []byte{}

    // ç¬¬ä¸€éï¼šå¤„ç†ä¹˜æ³•
    i := 0
    for i &lt; len(s) {
        if s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9' {
            num := int(s[i] - '0')
            // æŸ¥çœ‹åé¢æ˜¯å¦æ˜¯ä¹˜æ³•
            for i+1 &lt; len(s) &amp;&amp; s[i+1] == '*' {
                i += 2
                nextNum := int(s[i] - '0')
                num *= nextNum
            }
            nums = append(nums, num)
        } else if s[i] == '+' {
            ops = append(ops, '+')
        }
        i++
    }

    // ç¬¬äºŒéï¼šå¤„ç†åŠ æ³•
    result := nums[0]
    for j := 1; j &lt; len(nums); j++ {
        result += nums[j]
    }

    return result
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int scoreOfStudents(string s, vector&lt;int&gt;&amp; answers) {
        int n = s.length();
        // æå–æ•°å­—å’Œè¿ç®—ç¬¦
        vector&lt;int&gt; nums;
        vector&lt;char&gt; ops;
        for (int i = 0; i &lt; n; i++) {
            if (i % 2 == 0) {
                nums.push_back(s[i] - '0');
            } else {
                ops.push_back(s[i]);
            }
        }

        int m = nums.size();
        // dp[i][j] å­˜å‚¨æ‰€æœ‰å¯èƒ½ç»“æœ
        vector&lt;vector&lt;unordered_set&lt;int&gt;&gt;&gt; dp(m, vector&lt;unordered_set&lt;int&gt;&gt;(m));

        // åˆå§‹åŒ–ï¼šå•ä¸ªæ•°å­—
        for (int i = 0; i &lt; m; i++) {
            dp[i][i].insert(nums[i]);
        }

        // åŒºé—´DP
        for (int len = 2; len &lt;= m; len++) {
            for (int i = 0; i + len - 1 &lt; m; i++) {
                int j = i + len - 1;
                for (int k = i; k &lt; j; k++) {
                    char op = ops[k];
                    for (int a : dp[i][k]) {
                        for (int b : dp[k+1][j]) {
                            if (op == '+') {
                                int sum = a + b;
                                if (sum &lt;= 1000) {
                                    dp[i][j].insert(sum);
                                }
                            } else { // '*'
                                int prod = a * b;
                                if (prod &lt;= 1000) {
                                    dp[i][j].insert(prod);
                                }
                            }
                        }
                    }
                }
            }
        }

        // æ‰€æœ‰å¯èƒ½ç»“æœ
        unordered_set&lt;int&gt; allResults = dp[0][m-1];

        // è®¡ç®—æ­£ç¡®ç»“æœ
        int correctResult = calculateCorrect(s);

        // è®¡ç®—æ€»åˆ†
        int totalScore = 0;
        for (int ans : answers) {
            if (ans == correctResult) {
                totalScore += 5;
            } else if (allResults.count(ans)) {
                totalScore += 2;
            }
        }

        return totalScore;
    }

private:
    int calculateCorrect(string s) {
        vector&lt;int&gt; nums;
        int i = 0;

        // ç¬¬ä¸€éï¼šå¤„ç†ä¹˜æ³•
        while (i &lt; s.length()) {
            if (isdigit(s[i])) {
                int num = s[i] - '0';
                // å¤„ç†è¿ç»­çš„ä¹˜æ³•
                while (i + 1 &lt; s.length() &amp;&amp; s[i+1] == '*') {
                    i += 2;
                    int nextNum = s[i] - '0';
                    num *= nextNum;
                }
                nums.push_back(num);
            }
            i++;
        }

        // ç¬¬äºŒéï¼šå¤„ç†åŠ æ³•
        int result = 0;
        for (int num : nums) {
            result += num;
        }

        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-4">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(mÂ³ Ã— RÂ²)ï¼Œå…¶ä¸­ m æ˜¯æ•°å­—ä¸ªæ•°ï¼ŒR æ˜¯å¯èƒ½ç»“æœçš„æ•°é‡ï¼ˆæœ€å¤§ 1000ï¼‰</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(mÂ² Ã— R)ï¼Œå­˜å‚¨ DP è¡¨</li>
</ul>

<h2 id="è§£æ³•äºŒè®°å¿†åŒ–æœç´¢-å‰ªæ">è§£æ³•äºŒï¼šè®°å¿†åŒ–æœç´¢ + å‰ªæ</h2>

<h3 id="æ€è·¯-5">æ€è·¯</h3>

<p>ä½¿ç”¨é€’å½’+è®°å¿†åŒ–æœç´¢ï¼Œé€šè¿‡å‰ªæå‡å°‘ä¸å¿…è¦çš„è®¡ç®—ï¼š
1. é€’å½’è®¡ç®—æ¯ä¸ªå­è¡¨è¾¾å¼çš„æ‰€æœ‰å¯èƒ½ç»“æœ
2. ä½¿ç”¨å¤‡å¿˜å½•é¿å…é‡å¤è®¡ç®—
3. å‰ªæï¼šè¶…è¿‡ 1000 çš„ç»“æœä¸å­˜å‚¨</p>

<h3 id="ä»£ç å®ç°-8">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-2">Go å®ç°</h4>

<pre><code>func scoreOfStudents(s string, answers []int) int {
    n := len(s)
    // æå–æ•°å­—å’Œè¿ç®—ç¬¦
    nums := make([]int, (n+1)/2)
    ops := make([]byte, (n-1)/2)

    for i := 0; i &lt; n; i++ {
        if i%2 == 0 {
            nums[i/2] = int(s[i] - '0')
        } else {
            ops[i/2] = s[i]
        }
    }

    m := len(nums)
    memo := make([][]map[int]bool, m)
    for i := range memo {
        memo[i] = make([]map[int]bool, m)
    }

    // è®¡ç®—æ‰€æœ‰å¯èƒ½ç»“æœ
    allResults := dfs(nums, ops, 0, m-1, memo)

    // è®¡ç®—æ­£ç¡®ç»“æœ
    correctResult := calculateCorrect(s)

    // è®¡ç®—æ€»åˆ†
    totalScore := 0
    for _, ans := range answers {
        if ans == correctResult {
            totalScore += 5
        } else if allResults[ans] {
            totalScore += 2
        }
    }

    return totalScore
}

func dfs(nums []int, ops []byte, l, r int, memo [][]map[int]bool) map[int]bool {
    if memo[l][r] != nil {
        return memo[l][r]
    }

    result := make(map[int]bool)

    if l == r {
        result[nums[l]] = true
        memo[l][r] = result
        return result
    }

    for i := l; i &lt; r; i++ {
        leftResults := dfs(nums, ops, l, i, memo)
        rightResults := dfs(nums, ops, i+1, r, memo)

        op := ops[i]
        for a := range leftResults {
            for b := range rightResults {
                var val int
                if op == '+' {
                    val = a + b
                } else {
                    val = a * b
                }
                if val &lt;= 1000 {
                    result[val] = true
                }
            }
        }
    }

    memo[l][r] = result
    return result
}

// calculateCorrect å‡½æ•°åŒè§£æ³•ä¸€
</code></pre>

<h4 id="c-å®ç°-2">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int scoreOfStudents(string s, vector&lt;int&gt;&amp; answers) {
        int n = s.length();
        int m = (n + 1) / 2;
        vector&lt;int&gt; nums(m);
        vector&lt;char&gt; ops(m - 1);

        for (int i = 0; i &lt; n; i++) {
            if (i % 2 == 0) {
                nums[i / 2] = s[i] - '0';
            } else {
                ops[i / 2] = s[i];
            }
        }

        vector&lt;vector&lt;unordered_set&lt;int&gt;&gt;&gt; memo(m, vector&lt;unordered_set&lt;int&gt;&gt;(m));
        unordered_set&lt;int&gt; allResults = dfs(nums, ops, 0, m - 1, memo);

        int correctResult = calculateCorrect(s);

        int totalScore = 0;
        for (int ans : answers) {
            if (ans == correctResult) {
                totalScore += 5;
            } else if (allResults.count(ans)) {
                totalScore += 2;
            }
        }

        return totalScore;
    }

private:
    unordered_set&lt;int&gt; dfs(vector&lt;int&gt;&amp; nums, vector&lt;char&gt;&amp; ops, int l, int r, 
                          vector&lt;vector&lt;unordered_set&lt;int&gt;&gt;&gt;&amp; memo) {
        if (!memo[l][r].empty()) {
            return memo[l][r];
        }

        unordered_set&lt;int&gt; result;

        if (l == r) {
            result.insert(nums[l]);
            memo[l][r] = result;
            return result;
        }

        for (int i = l; i &lt; r; i++) {
            auto leftResults = dfs(nums, ops, l, i, memo);
            auto rightResults = dfs(nums, ops, i + 1, r, memo);

            char op = ops[i];
            for (int a : leftResults) {
                for (int b : rightResults) {
                    int val;
                    if (op == '+') {
                        val = a + b;
                    } else {
                        val = a * b;
                    }
                    if (val &lt;= 1000) {
                        result.insert(val);
                    }
                }
            }
        }

        memo[l][r] = result;
        return result;
    }

    // calculateCorrect å‡½æ•°åŒè§£æ³•ä¸€
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-5">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(mÂ³ Ã— RÂ²)ï¼Œä¸ DP ç›¸åŒï¼Œä½†å®é™…è¿è¡Œå¯èƒ½æ›´å¿«ï¼ˆå‰ªæï¼‰</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(mÂ² Ã— R)</li>
</ul>

<h2 id="è§£æ³•ä¸‰ä¼˜åŒ–ç‰ˆdpæŒ‰è¿ç®—ç¬¦dp">è§£æ³•ä¸‰ï¼šä¼˜åŒ–ç‰ˆDPï¼ˆæŒ‰è¿ç®—ç¬¦DPï¼‰</h2>

<h3 id="æ€è·¯-6">æ€è·¯</h3>

<p>è§‚å¯Ÿåˆ°è¡¨è¾¾å¼æ˜¯æ•°å­—å’Œè¿ç®—ç¬¦äº¤æ›¿çš„ï¼Œå¯ä»¥æŒ‰è¿ç®—ç¬¦è¿›è¡ŒDPï¼š
1. <code>dp[i][j]</code> è¡¨ç¤ºä»ç¬¬ i ä¸ªè¿ç®—ç¬¦åˆ°ç¬¬ j ä¸ªè¿ç®—ç¬¦ä¹‹é—´çš„è¡¨è¾¾å¼æ‰€æœ‰å¯èƒ½ç»“æœ
2. å‡å°‘çŠ¶æ€æ•°é‡ï¼Œæé«˜æ•ˆç‡</p>

<h3 id="ä»£ç å®ç°-9">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-3">Go å®ç°</h4>

<pre><code>func scoreOfStudents(s string, answers []int) int {
    n := len(s)
    // æå–æ•°å­—
    nums := []int{}
    for i := 0; i &lt; n; i += 2 {
        nums = append(nums, int(s[i]-'0'))
    }

    m := len(nums)
    if m == 1 {
        // åªæœ‰ä¸€ä¸ªæ•°å­—
        correct := nums[0]
        total := 0
        for _, ans := range answers {
            if ans == correct {
                total += 5
            }
        }
        return total
    }

    // æå–è¿ç®—ç¬¦
    ops := []byte{}
    for i := 1; i &lt; n; i += 2 {
        ops = append(ops, s[i])
    }

    // dp[i][j] è¡¨ç¤º nums[i..j] çš„æ‰€æœ‰å¯èƒ½ç»“æœ
    dp := make([][]map[int]bool, m)
    for i := range dp {
        dp[i] = make([]map[int]bool, m)
        for j := range dp[i] {
            dp[i][j] = make(map[int]bool)
        }
    }

    // åˆå§‹åŒ–
    for i := 0; i &lt; m; i++ {
        dp[i][i][nums[i]] = true
    }

    // æŒ‰é•¿åº¦DP
    for length := 2; length &lt;= m; length++ {
        for i := 0; i+length-1 &lt; m; i++ {
            j := i + length - 1
            // æšä¸¾æœ€åä¸€ä¸ªè¿ç®—ç¬¦ä½ç½®
            for k := i; k &lt; j; k++ {
                leftSet := dp[i][k]
                rightSet := dp[k+1][j]
                op := ops[k]

                for a := range leftSet {
                    for b := range rightSet {
                        var val int
                        if op == '+' {
                            val = a + b
                        } else {
                            val = a * b
                        }
                        if val &lt;= 1000 {
                            dp[i][j][val] = true
                        }
                    }
                }
            }
        }
    }

    allResults := dp[0][m-1]
    correctResult := calculateCorrect(s)

    totalScore := 0
    for _, ans := range answers {
        if ans == correctResult {
            totalScore += 5
        } else if allResults[ans] {
            totalScore += 2
        }
    }

    return totalScore
}

// calculateCorrect å‡½æ•°åŒè§£æ³•ä¸€
</code></pre>

<h4 id="c-å®ç°-3">C++ å®ç°</h4>

<p>```cpp
class Solution {
public:
    int scoreOfStudents(string s, vector<int>&amp; answers) {
        int n = s.length();
        vector<int> nums;
        for (int i = 0; i &lt; n; i += 2) {
            nums.push_back(s[i] - '0');
        }</p>

<pre><code>    int m = nums.size();
    if (m == 1) {
        int correct = nums[0];
        int total = 0;
        for (int ans : answers) {
            if (ans == correct) total += 5;
        }
        return total;
    }

    vector&lt;char&gt; ops;
    for (int i = 1; i &lt; n; i += 2) {
        ops.push_back(s[i]);
    }

    vector&lt;vector&lt;unordered_set&lt;int&gt;&gt;&gt; dp(m, vector&lt;unordered_set&lt;int&gt;&gt;(m));

    // åˆå§‹åŒ–
    for (int i = 0; i &lt; m; i++) {
        dp[i][i].insert(nums[i]);
    }

    // DP
    for
</code></pre>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 18:48:40</em></p>

        </div>
    </div>
</body>
</html>