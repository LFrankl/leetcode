<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1408. æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é… - LeetCode</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="top-bar">
        <button class="menu-button" onclick="history.back()" aria-label="è¿”å›">
            <div class="menu-icon">
                <span style="transform: rotate(-45deg) translateY(-2px);"></span>
                <span style="transform: rotate(45deg) translateY(2px);"></span>
            </div>
        </button>
        <div class="logo">
            <span class="logo-emoji">ğŸ“š</span>
            LeetCode æ¯æ—¥é¢˜ç›®
        </div>
        <div class="update-time">2026-02-26 00:00:00</div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content" style="margin-left: 0;">
        <div class="content-wrapper">
            <button class="back-button" onclick="history.back()">
                â† è¿”å›é¢˜ç›®åˆ—è¡¨
            </button>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-number">1408. æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é…</span>
                    <span class="difficulty-badge difficulty-easy">
                        ç®€å•
                    </span>
                    <a href="https://leetcode.cn/problems/string-matching-in-an-array/" target="_blank" class="question-link">åœ¨ LeetCode æ‰“å¼€</a>
                </div>
                <div class="markdown-content">
                    <h1 id="1408-æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é…">1408. æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é…</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, å­—ç¬¦ä¸², å­—ç¬¦ä¸²åŒ¹é…</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/string-matching-in-an-array/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ <code>words</code> ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªå•è¯ã€‚è¯·ä½ æŒ‰ <strong>ä»»æ„</strong> é¡ºåºè¿”å› <code>words</code> ä¸­æ˜¯å…¶ä»–å•è¯çš„ <span data-keyword="substring-nonempty">å­å­—ç¬¦ä¸²</span> çš„æ‰€æœ‰å•è¯ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["mass","as","hero","superhero"]
<strong>è¾“å‡ºï¼š</strong>["as","hero"]
<strong>è§£é‡Šï¼š</strong>"as" æ˜¯ "mass" çš„å­å­—ç¬¦ä¸²ï¼Œ"hero" æ˜¯ "superhero" çš„å­å­—ç¬¦ä¸²ã€‚
["hero","as"] ä¹Ÿæ˜¯æœ‰æ•ˆçš„ç­”æ¡ˆã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["leetcode","et","code"]
<strong>è¾“å‡ºï¼š</strong>["et","code"]
<strong>è§£é‡Šï¼š</strong>"et" å’Œ "code" éƒ½æ˜¯ "leetcode" çš„å­å­—ç¬¦ä¸²ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["blue","green","bu"]
<strong>è¾“å‡ºï¼š</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= words.length &lt;= 100</code></li>
    <li><code>1 &lt;= words[i].length &lt;= 30</code></li>
    <li><code>words[i]</code> ä»…åŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚</li>
    <li>é¢˜ç›®æ•°æ® <strong>ä¿è¯</strong> <code>words</code>&nbsp;çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public List&lt;String&gt; stringMatching(String[] words) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def stringMatching(self, words: List[str]) -&gt; List[str]:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {string[]} words
 * @return {string[]}
 */
var stringMatching = function(words) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func stringMatching(words []string) []string {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Bruteforce to find if one string is substring of another or use KMP algorithm.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>["mass","as","hero","superhero"]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>é¢˜ç›®è¦æ±‚æ‰¾å‡ºå­—ç¬¦ä¸²æ•°ç»„ä¸­ï¼Œé‚£äº›æ˜¯å…¶ä»–å•è¯å­å­—ç¬¦ä¸²çš„å•è¯ã€‚éœ€è¦è¿”å›æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„å•è¯ï¼Œé¡ºåºä»»æ„ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- ä¸€ä¸ªå•è¯æ˜¯å…¶ä»–å•è¯çš„å­å­—ç¬¦ä¸²ï¼ˆä¸èƒ½æ˜¯è‡ªèº«ï¼‰
- æ‰€æœ‰å•è¯éƒ½æ˜¯å”¯ä¸€çš„
- éœ€è¦æ£€æŸ¥æ¯ä¸ªå•è¯æ˜¯å¦æ˜¯å…¶ä»–ä»»æ„å•è¯çš„å­ä¸²</p>

<h2 id="è§£æ³•ä¸€æš´åŠ›æšä¸¾æ³•">è§£æ³•ä¸€ï¼šæš´åŠ›æšä¸¾æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h3>

<p>æœ€ç›´æ¥çš„æ–¹æ³•ï¼šå¯¹äºæ¯ä¸ªå•è¯ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯å…¶ä»–ä»»æ„å•è¯çš„å­ä¸²ã€‚ä½¿ç”¨åŒé‡å¾ªç¯å®ç°ã€‚</p>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    var result []string
    n := len(words)

    for i := 0; i &lt; n; i++ {
        for j := 0; j &lt; n; j++ {
            if i != j &amp;&amp; len(words[i]) &lt;= len(words[j]) {
                // æ£€æŸ¥ words[i] æ˜¯å¦æ˜¯ words[j] çš„å­ä¸²
                if strings.Contains(words[j], words[i]) {
                    result = append(result, words[i])
                    break  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                }
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        vector&lt;string&gt; result;
        int n = words.size();

        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i != j &amp;&amp; words[i].length() &lt;= words[j].length()) {
                    // æ£€æŸ¥ words[i] æ˜¯å¦æ˜¯ words[j] çš„å­ä¸²
                    if (words[j].find(words[i]) != string::npos) {
                        result.push_back(words[i]);
                        break;  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                    }
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(nÂ² * L)ï¼Œå…¶ä¸­ n æ˜¯å•è¯æ•°é‡ï¼ŒL æ˜¯å•è¯å¹³å‡é•¿åº¦ã€‚æœ€åæƒ…å†µä¸‹éœ€è¦æ¯”è¾ƒæ‰€æœ‰å•è¯å¯¹ã€‚</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼ˆä¸è€ƒè™‘è¾“å‡ºç»“æœçš„ç©ºé—´ï¼‰</li>
</ul>

<h2 id="è§£æ³•äºŒæ’åº-åç¼€æ£€æŸ¥æ³•">è§£æ³•äºŒï¼šæ’åº + åç¼€æ£€æŸ¥æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-2">è§£é¢˜æ€è·¯</h3>

<ol>
<li>æŒ‰é•¿åº¦å¯¹å•è¯æ’åºï¼Œè¾ƒçŸ­çš„å•è¯æ›´å¯èƒ½æ˜¯è¾ƒé•¿å•è¯çš„å­ä¸²</li>
<li>å¯¹äºæ¯ä¸ªå•è¯ï¼Œåªæ£€æŸ¥å®ƒåé¢çš„å•è¯ï¼ˆå› ä¸ºåé¢çš„å•è¯æ›´é•¿ï¼‰</li>
<li>è¿™æ ·å¯ä»¥å‡å°‘ä¸å¿…è¦çš„æ¯”è¾ƒ</li>
</ol>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-2">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    // æŒ‰é•¿åº¦æ’åº
    sortedWords := make([]string, len(words))
    copy(sortedWords, words)
    sort.Slice(sortedWords, func(i, j int) bool {
        return len(sortedWords[i]) &lt; len(sortedWords[j])
    })

    var result []string
    n := len(sortedWords)

    for i := 0; i &lt; n; i++ {
        for j := i + 1; j &lt; n; j++ {
            // åªæ£€æŸ¥æ›´é•¿çš„å•è¯
            if strings.Contains(sortedWords[j], sortedWords[i]) {
                result = append(result, sortedWords[i])
                break  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°-2">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        // æŒ‰é•¿åº¦æ’åº
        vector&lt;string&gt; sortedWords = words;
        sort(sortedWords.begin(), sortedWords.end(), 
             [](const string&amp; a, const string&amp; b) {
                 return a.length() &lt; b.length();
             });

        vector&lt;string&gt; result;
        int n = sortedWords.size();

        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                // åªæ£€æŸ¥æ›´é•¿çš„å•è¯
                if (sortedWords[j].find(sortedWords[i]) != string::npos) {
                    result.push_back(sortedWords[i]);
                    break;  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-2">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n log n + nÂ² * L)ï¼Œæ’åºéœ€è¦ O(n log n)ï¼Œæ¯”è¾ƒéœ€è¦ O(nÂ² * L)</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œéœ€è¦é¢å¤–çš„æ•°ç»„å­˜å‚¨æ’åºåçš„å•è¯</li>
</ul>

<h2 id="è§£æ³•ä¸‰è¿æ¥å­—ç¬¦ä¸²æ³•">è§£æ³•ä¸‰ï¼šè¿æ¥å­—ç¬¦ä¸²æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-3">è§£é¢˜æ€è·¯</h3>

<ol>
<li>å°†æ‰€æœ‰å•è¯ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æˆä¸€ä¸ªé•¿å­—ç¬¦ä¸²</li>
<li>å¯¹äºæ¯ä¸ªå•è¯ï¼Œæ£€æŸ¥å®ƒåœ¨è¿™ä¸ªé•¿å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°</li>
<li>å¦‚æœå‡ºç°æ¬¡æ•°å¤§äº1ï¼Œè¯´æ˜å®ƒæ˜¯å…¶ä»–å•è¯çš„å­ä¸²</li>
</ol>

<h3 id="ä»£ç å®ç°-3">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-3">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    // ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æ‰€æœ‰å•è¯
    joined := strings.Join(words, "#")

    var result []string
    for _, word := range words {
        // åœ¨è¿æ¥åçš„å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾è¯¥å•è¯
        // éœ€è¦ç¡®ä¿æ‰¾åˆ°çš„ä½ç½®ä¸æ˜¯å•è¯æœ¬èº«çš„ä¸€éƒ¨åˆ†
        count := 0
        pos := 0
        for {
            idx := strings.Index(joined[pos:], word)
            if idx == -1 {
                break
            }
            count++
            pos += idx + 1
            if count &gt;= 2 {
                // å‡ºç°è‡³å°‘2æ¬¡ï¼Œè¯´æ˜æ˜¯å…¶ä»–å•è¯çš„å­ä¸²
                result = append(result, word)
                break
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°-3">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        // ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æ‰€æœ‰å•è¯
        string joined;
        for (const string&amp; word : words) {
            joined += word + "#";
        }

        vector&lt;string&gt; result;
        for (const string&amp; word : words) {
            // ç»Ÿè®¡å•è¯åœ¨è¿æ¥å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°
            int count = 0;
            size_t pos = 0;

            while ((pos = joined.find(word, pos)) != string::npos) {
                count++;
                pos += 1;  // ç§»åŠ¨ä½ç½®ç»§ç»­æŸ¥æ‰¾
                if (count &gt;= 2) {
                    // å‡ºç°è‡³å°‘2æ¬¡ï¼Œè¯´æ˜æ˜¯å…¶ä»–å•è¯çš„å­ä¸²
                    result.push_back(word);
                    break;
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-3">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n * L * S)ï¼Œå…¶ä¸­ S æ˜¯è¿æ¥åå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œæœ€åæƒ…å†µä¸‹æ¥è¿‘ n*L</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n * L)ï¼Œéœ€è¦å­˜å‚¨è¿æ¥åçš„å­—ç¬¦ä¸²</li>
</ul>

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
  <th>é€‚ç”¨åœºæ™¯</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æš´åŠ›æšä¸¾</td>
  <td>å®ç°ç®€å•ï¼Œæ— éœ€é¢å¤–ç©ºé—´</td>
  <td>æ—¶é—´å¤æ‚åº¦é«˜ï¼ŒO(nÂ² * L)</td>
  <td>æ•°æ®è§„æ¨¡å°ï¼ˆn â‰¤ 100ï¼‰</td>
</tr>
<tr>
  <td>æ’åº+åç¼€æ£€æŸ¥</td>
  <td>å‡å°‘æ¯”è¾ƒæ¬¡æ•°ï¼Œæ•ˆç‡è¾ƒé«˜</td>
  <td>éœ€è¦æ’åºï¼Œæ”¹å˜åŸå§‹é¡ºåº</td>
  <td>é€šç”¨åœºæ™¯ï¼Œæ€§èƒ½è¾ƒå¥½</td>
</tr>
<tr>
  <td>è¿æ¥å­—ç¬¦ä¸²</td>
  <td>æ€è·¯å·§å¦™ï¼Œä»£ç ç®€æ´</td>
  <td>å¯èƒ½è¯¯åˆ¤ï¼ˆå¦‚"a"åœ¨"ab"ä¸­å‡ºç°ï¼‰ï¼Œéœ€è¦ç‰¹æ®Šåˆ†éš”ç¬¦</td>
  <td>éœ€è¦å¿«é€Ÿå®ç°ï¼Œå¯¹æ€§èƒ½è¦æ±‚ä¸é«˜</td>
</tr>
</tbody>
</table>

<h2 id="æ¨èè§£æ³•">æ¨èè§£æ³•</h2>

<p>å¯¹äºæœ¬é¢˜çš„æ•°æ®è§„æ¨¡ï¼ˆn â‰¤ 100ï¼ŒL â‰¤ 30ï¼‰ï¼Œ<strong>è§£æ³•ä¸€ï¼ˆæš´åŠ›æšä¸¾ï¼‰</strong> æ˜¯æœ€ç®€å•ç›´æ¥çš„é€‰æ‹©ï¼Œä»£ç æ¸…æ™°æ˜“æ‡‚ï¼Œæ€§èƒ½ä¹Ÿå®Œå…¨è¶³å¤Ÿã€‚</p>

<p><strong>è§£æ³•äºŒï¼ˆæ’åº+åç¼€æ£€æŸ¥ï¼‰</strong> åœ¨æ€§èƒ½ä¸Šæ›´ä¼˜ï¼Œç‰¹åˆ«æ˜¯å½“å•è¯æ•°é‡è¾ƒå¤šæ—¶ï¼Œæ˜¯æ›´é€šç”¨çš„è§£å†³æ–¹æ¡ˆã€‚</p>

<p><strong>è§£æ³•ä¸‰ï¼ˆè¿æ¥å­—ç¬¦ä¸²ï¼‰</strong> è™½ç„¶æ€è·¯å·§å¦™ï¼Œä½†éœ€è¦æ³¨æ„å¤„ç†è¾¹ç•Œæƒ…å†µï¼Œå®é™…åº”ç”¨ä¸­è¾ƒå°‘ä½¿ç”¨ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:47:40</em></p>

                </div>
            </div>

            <div class="footer">
                <p>ç”± <a href="https://github.com/LFrankl/leetcode" target="_blank">LeetCode Daily Script</a> è‡ªåŠ¨ç”Ÿæˆ</p>
                <p>AI è§£ç­”ç”± <a href="https://www.deepseek.com/" target="_blank">DeepSeek</a> æä¾›</p>
            </div>
        </div>
    </div>
</body>
</html>