<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 2026-02-26</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
        <div class="content">
            <h1>ğŸ“… 2026-02-26 æ¯æ—¥é¢˜ç›®</h1>
            <h1 id="1408-æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é…">1408. æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²åŒ¹é…</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, å­—ç¬¦ä¸², å­—ç¬¦ä¸²åŒ¹é…</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/string-matching-in-an-array/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ <code>words</code> ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªå•è¯ã€‚è¯·ä½ æŒ‰ <strong>ä»»æ„</strong> é¡ºåºè¿”å› <code>words</code> ä¸­æ˜¯å…¶ä»–å•è¯çš„ <span data-keyword="substring-nonempty">å­å­—ç¬¦ä¸²</span> çš„æ‰€æœ‰å•è¯ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["mass","as","hero","superhero"]
<strong>è¾“å‡ºï¼š</strong>["as","hero"]
<strong>è§£é‡Šï¼š</strong>"as" æ˜¯ "mass" çš„å­å­—ç¬¦ä¸²ï¼Œ"hero" æ˜¯ "superhero" çš„å­å­—ç¬¦ä¸²ã€‚
["hero","as"] ä¹Ÿæ˜¯æœ‰æ•ˆçš„ç­”æ¡ˆã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["leetcode","et","code"]
<strong>è¾“å‡ºï¼š</strong>["et","code"]
<strong>è§£é‡Šï¼š</strong>"et" å’Œ "code" éƒ½æ˜¯ "leetcode" çš„å­å­—ç¬¦ä¸²ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>words = ["blue","green","bu"]
<strong>è¾“å‡ºï¼š</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= words.length &lt;= 100</code></li>
    <li><code>1 &lt;= words[i].length &lt;= 30</code></li>
    <li><code>words[i]</code> ä»…åŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚</li>
    <li>é¢˜ç›®æ•°æ® <strong>ä¿è¯</strong> <code>words</code>&nbsp;çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public List&lt;String&gt; stringMatching(String[] words) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def stringMatching(self, words: List[str]) -&gt; List[str]:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {string[]} words
 * @return {string[]}
 */
var stringMatching = function(words) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func stringMatching(words []string) []string {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Bruteforce to find if one string is substring of another or use KMP algorithm.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>["mass","as","hero","superhero"]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>é¢˜ç›®è¦æ±‚æ‰¾å‡ºå­—ç¬¦ä¸²æ•°ç»„ä¸­ï¼Œé‚£äº›æ˜¯å…¶ä»–å•è¯å­å­—ç¬¦ä¸²çš„å•è¯ã€‚éœ€è¦è¿”å›æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„å•è¯ï¼Œé¡ºåºä»»æ„ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- ä¸€ä¸ªå•è¯æ˜¯å…¶ä»–å•è¯çš„å­å­—ç¬¦ä¸²ï¼ˆä¸èƒ½æ˜¯è‡ªèº«ï¼‰
- æ‰€æœ‰å•è¯éƒ½æ˜¯å”¯ä¸€çš„
- éœ€è¦æ£€æŸ¥æ¯ä¸ªå•è¯æ˜¯å¦æ˜¯å…¶ä»–ä»»æ„å•è¯çš„å­ä¸²</p>

<h2 id="è§£æ³•ä¸€æš´åŠ›æšä¸¾æ³•">è§£æ³•ä¸€ï¼šæš´åŠ›æšä¸¾æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h3>

<p>æœ€ç›´æ¥çš„æ–¹æ³•ï¼šå¯¹äºæ¯ä¸ªå•è¯ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯å…¶ä»–ä»»æ„å•è¯çš„å­ä¸²ã€‚ä½¿ç”¨åŒé‡å¾ªç¯å®ç°ã€‚</p>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    var result []string
    n := len(words)

    for i := 0; i &lt; n; i++ {
        for j := 0; j &lt; n; j++ {
            if i != j &amp;&amp; len(words[i]) &lt;= len(words[j]) {
                // æ£€æŸ¥ words[i] æ˜¯å¦æ˜¯ words[j] çš„å­ä¸²
                if strings.Contains(words[j], words[i]) {
                    result = append(result, words[i])
                    break  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                }
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        vector&lt;string&gt; result;
        int n = words.size();

        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i != j &amp;&amp; words[i].length() &lt;= words[j].length()) {
                    // æ£€æŸ¥ words[i] æ˜¯å¦æ˜¯ words[j] çš„å­ä¸²
                    if (words[j].find(words[i]) != string::npos) {
                        result.push_back(words[i]);
                        break;  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                    }
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(nÂ² * L)ï¼Œå…¶ä¸­ n æ˜¯å•è¯æ•°é‡ï¼ŒL æ˜¯å•è¯å¹³å‡é•¿åº¦ã€‚æœ€åæƒ…å†µä¸‹éœ€è¦æ¯”è¾ƒæ‰€æœ‰å•è¯å¯¹ã€‚</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼ˆä¸è€ƒè™‘è¾“å‡ºç»“æœçš„ç©ºé—´ï¼‰</li>
</ul>

<h2 id="è§£æ³•äºŒæ’åº-åç¼€æ£€æŸ¥æ³•">è§£æ³•äºŒï¼šæ’åº + åç¼€æ£€æŸ¥æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-2">è§£é¢˜æ€è·¯</h3>

<ol>
<li>æŒ‰é•¿åº¦å¯¹å•è¯æ’åºï¼Œè¾ƒçŸ­çš„å•è¯æ›´å¯èƒ½æ˜¯è¾ƒé•¿å•è¯çš„å­ä¸²</li>
<li>å¯¹äºæ¯ä¸ªå•è¯ï¼Œåªæ£€æŸ¥å®ƒåé¢çš„å•è¯ï¼ˆå› ä¸ºåé¢çš„å•è¯æ›´é•¿ï¼‰</li>
<li>è¿™æ ·å¯ä»¥å‡å°‘ä¸å¿…è¦çš„æ¯”è¾ƒ</li>
</ol>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-2">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    // æŒ‰é•¿åº¦æ’åº
    sortedWords := make([]string, len(words))
    copy(sortedWords, words)
    sort.Slice(sortedWords, func(i, j int) bool {
        return len(sortedWords[i]) &lt; len(sortedWords[j])
    })

    var result []string
    n := len(sortedWords)

    for i := 0; i &lt; n; i++ {
        for j := i + 1; j &lt; n; j++ {
            // åªæ£€æŸ¥æ›´é•¿çš„å•è¯
            if strings.Contains(sortedWords[j], sortedWords[i]) {
                result = append(result, sortedWords[i])
                break  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°-2">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        // æŒ‰é•¿åº¦æ’åº
        vector&lt;string&gt; sortedWords = words;
        sort(sortedWords.begin(), sortedWords.end(), 
             [](const string&amp; a, const string&amp; b) {
                 return a.length() &lt; b.length();
             });

        vector&lt;string&gt; result;
        int n = sortedWords.size();

        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                // åªæ£€æŸ¥æ›´é•¿çš„å•è¯
                if (sortedWords[j].find(sortedWords[i]) != string::npos) {
                    result.push_back(sortedWords[i]);
                    break;  // æ‰¾åˆ°ä¸€ä¸ªåŒ…å«å®ƒçš„å•è¯å³å¯
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-2">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n log n + nÂ² * L)ï¼Œæ’åºéœ€è¦ O(n log n)ï¼Œæ¯”è¾ƒéœ€è¦ O(nÂ² * L)</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)ï¼Œéœ€è¦é¢å¤–çš„æ•°ç»„å­˜å‚¨æ’åºåçš„å•è¯</li>
</ul>

<h2 id="è§£æ³•ä¸‰è¿æ¥å­—ç¬¦ä¸²æ³•">è§£æ³•ä¸‰ï¼šè¿æ¥å­—ç¬¦ä¸²æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-3">è§£é¢˜æ€è·¯</h3>

<ol>
<li>å°†æ‰€æœ‰å•è¯ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æˆä¸€ä¸ªé•¿å­—ç¬¦ä¸²</li>
<li>å¯¹äºæ¯ä¸ªå•è¯ï¼Œæ£€æŸ¥å®ƒåœ¨è¿™ä¸ªé•¿å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°</li>
<li>å¦‚æœå‡ºç°æ¬¡æ•°å¤§äº1ï¼Œè¯´æ˜å®ƒæ˜¯å…¶ä»–å•è¯çš„å­ä¸²</li>
</ol>

<h3 id="ä»£ç å®ç°-3">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-3">Go å®ç°</h4>

<pre><code>func stringMatching(words []string) []string {
    // ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æ‰€æœ‰å•è¯
    joined := strings.Join(words, "#")

    var result []string
    for _, word := range words {
        // åœ¨è¿æ¥åçš„å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾è¯¥å•è¯
        // éœ€è¦ç¡®ä¿æ‰¾åˆ°çš„ä½ç½®ä¸æ˜¯å•è¯æœ¬èº«çš„ä¸€éƒ¨åˆ†
        count := 0
        pos := 0
        for {
            idx := strings.Index(joined[pos:], word)
            if idx == -1 {
                break
            }
            count++
            pos += idx + 1
            if count &gt;= 2 {
                // å‡ºç°è‡³å°‘2æ¬¡ï¼Œè¯´æ˜æ˜¯å…¶ä»–å•è¯çš„å­ä¸²
                result = append(result, word)
                break
            }
        }
    }
    return result
}
</code></pre>

<h4 id="c-å®ç°-3">C++ å®ç°</h4>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {
        // ç”¨ç‰¹æ®Šå­—ç¬¦è¿æ¥æ‰€æœ‰å•è¯
        string joined;
        for (const string&amp; word : words) {
            joined += word + "#";
        }

        vector&lt;string&gt; result;
        for (const string&amp; word : words) {
            // ç»Ÿè®¡å•è¯åœ¨è¿æ¥å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°
            int count = 0;
            size_t pos = 0;

            while ((pos = joined.find(word, pos)) != string::npos) {
                count++;
                pos += 1;  // ç§»åŠ¨ä½ç½®ç»§ç»­æŸ¥æ‰¾
                if (count &gt;= 2) {
                    // å‡ºç°è‡³å°‘2æ¬¡ï¼Œè¯´æ˜æ˜¯å…¶ä»–å•è¯çš„å­ä¸²
                    result.push_back(word);
                    break;
                }
            }
        }
        return result;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-3">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(n * L * S)ï¼Œå…¶ä¸­ S æ˜¯è¿æ¥åå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œæœ€åæƒ…å†µä¸‹æ¥è¿‘ n*L</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n * L)ï¼Œéœ€è¦å­˜å‚¨è¿æ¥åçš„å­—ç¬¦ä¸²</li>
</ul>

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
  <th>é€‚ç”¨åœºæ™¯</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æš´åŠ›æšä¸¾</td>
  <td>å®ç°ç®€å•ï¼Œæ— éœ€é¢å¤–ç©ºé—´</td>
  <td>æ—¶é—´å¤æ‚åº¦é«˜ï¼ŒO(nÂ² * L)</td>
  <td>æ•°æ®è§„æ¨¡å°ï¼ˆn â‰¤ 100ï¼‰</td>
</tr>
<tr>
  <td>æ’åº+åç¼€æ£€æŸ¥</td>
  <td>å‡å°‘æ¯”è¾ƒæ¬¡æ•°ï¼Œæ•ˆç‡è¾ƒé«˜</td>
  <td>éœ€è¦æ’åºï¼Œæ”¹å˜åŸå§‹é¡ºåº</td>
  <td>é€šç”¨åœºæ™¯ï¼Œæ€§èƒ½è¾ƒå¥½</td>
</tr>
<tr>
  <td>è¿æ¥å­—ç¬¦ä¸²</td>
  <td>æ€è·¯å·§å¦™ï¼Œä»£ç ç®€æ´</td>
  <td>å¯èƒ½è¯¯åˆ¤ï¼ˆå¦‚"a"åœ¨"ab"ä¸­å‡ºç°ï¼‰ï¼Œéœ€è¦ç‰¹æ®Šåˆ†éš”ç¬¦</td>
  <td>éœ€è¦å¿«é€Ÿå®ç°ï¼Œå¯¹æ€§èƒ½è¦æ±‚ä¸é«˜</td>
</tr>
</tbody>
</table>

<h2 id="æ¨èè§£æ³•">æ¨èè§£æ³•</h2>

<p>å¯¹äºæœ¬é¢˜çš„æ•°æ®è§„æ¨¡ï¼ˆn â‰¤ 100ï¼ŒL â‰¤ 30ï¼‰ï¼Œ<strong>è§£æ³•ä¸€ï¼ˆæš´åŠ›æšä¸¾ï¼‰</strong> æ˜¯æœ€ç®€å•ç›´æ¥çš„é€‰æ‹©ï¼Œä»£ç æ¸…æ™°æ˜“æ‡‚ï¼Œæ€§èƒ½ä¹Ÿå®Œå…¨è¶³å¤Ÿã€‚</p>

<p><strong>è§£æ³•äºŒï¼ˆæ’åº+åç¼€æ£€æŸ¥ï¼‰</strong> åœ¨æ€§èƒ½ä¸Šæ›´ä¼˜ï¼Œç‰¹åˆ«æ˜¯å½“å•è¯æ•°é‡è¾ƒå¤šæ—¶ï¼Œæ˜¯æ›´é€šç”¨çš„è§£å†³æ–¹æ¡ˆã€‚</p>

<p><strong>è§£æ³•ä¸‰ï¼ˆè¿æ¥å­—ç¬¦ä¸²ï¼‰</strong> è™½ç„¶æ€è·¯å·§å¦™ï¼Œä½†éœ€è¦æ³¨æ„å¤„ç†è¾¹ç•Œæƒ…å†µï¼Œå®é™…åº”ç”¨ä¸­è¾ƒå°‘ä½¿ç”¨ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:47:40</em></p>

<hr />

<h1 id="3290-æœ€é«˜ä¹˜æ³•å¾—åˆ†">3290. æœ€é«˜ä¹˜æ³•å¾—åˆ†</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, åŠ¨æ€è§„åˆ’</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/maximum-multiplication-score/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-2">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º 4 çš„æ•´æ•°æ•°ç»„ <code>a</code> å’Œä¸€ä¸ªå¤§å° <strong>è‡³å°‘</strong>ä¸º 4 çš„æ•´æ•°æ•°ç»„ <code>b</code>ã€‚</p>

<p>ä½ éœ€è¦ä»æ•°ç»„ <code>b</code> ä¸­é€‰æ‹©å››ä¸ªä¸‹æ ‡ <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, å’Œ <code>i<sub>3</sub></code>ï¼Œå¹¶æ»¡è¶³ <code>i<sub>0</sub> &lt; i<sub>1</sub> &lt; i<sub>2</sub> &lt; i<sub>3</sub></code>ã€‚ä½ çš„å¾—åˆ†å°†æ˜¯ <code>a[0] * b[i<sub>0</sub>] + a[1] * b[i<sub>1</sub>] + a[2] * b[i<sub>2</sub>] + a[3] * b[i<sub>3</sub>]</code> çš„å€¼ã€‚</p>

<p>è¿”å›ä½ èƒ½å¤Ÿè·å¾—çš„ <strong>æœ€å¤§ </strong>å¾—åˆ†ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<div class="example-block">
<p><strong>è¾“å…¥ï¼š</strong> <span class="example-io">a = [3,2,5,6], b = [2,-6,4,-5,-3,2,-7]</span></p>

<p><strong>è¾“å‡ºï¼š</strong> <span class="example-io">26</span></p>

<p><strong>è§£é‡Šï¼š</strong><br />
é€‰æ‹©ä¸‹æ ‡ 0, 1, 2 å’Œ 5ã€‚å¾—åˆ†ä¸º <code>3 * 2 + 2 * (-6) + 5 * 4 + 6 * 2 = 26</code>ã€‚</p>
</div>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<div class="example-block">
<p><strong>è¾“å…¥ï¼š</strong> <span class="example-io">a = [-1,4,5,-2], b = [-5,-1,-3,-2,-4]</span></p>

<p><strong>è¾“å‡ºï¼š</strong> <span class="example-io">-1</span></p>

<p><strong>è§£é‡Šï¼š</strong><br />
é€‰æ‹©ä¸‹æ ‡ 0, 1, 3 å’Œ 4ã€‚å¾—åˆ†ä¸º <code>(-1) * (-5) + 4 * (-1) + 5 * (-2) + (-2) * (-4) = -1</code>ã€‚</p>
</div>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>a.length == 4</code></li>
    <li><code>4 &lt;= b.length &lt;= 10<sup>5</sup></code></li>
    <li><code>-10<sup>5</sup> &lt;= a[i], b[i] &lt;= 10<sup>5</sup></code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-2">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-2">C++</h3>

<pre><code>class Solution {
public:
    long long maxScore(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {

    }
};
</code></pre>

<h3 id="java-2">Java</h3>

<pre><code>class Solution {
    public long maxScore(int[] a, int[] b) {

    }
}
</code></pre>

<h3 id="python3-2">Python3</h3>

<pre><code>class Solution:
    def maxScore(self, a: List[int], b: List[int]) -&gt; int:

</code></pre>

<h3 id="javascript-2">JavaScript</h3>

<pre><code>/**
 * @param {number[]} a
 * @param {number[]} b
 * @return {number}
 */
var maxScore = function(a, b) {

};
</code></pre>

<h3 id="go-2">Go</h3>

<pre><code>func maxScore(a []int, b []int) int64 {

}
</code></pre>

<hr />

<h2 id="æç¤º-2">æç¤º</h2>

<ol>
<li>Try using dynamic programming.</li>
<li>Consider a dp with the following states: The current position in the array b, and the number of indices considered.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-2">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>[3,2,5,6]
[2,-6,4,-5,-3,2,-7]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-2">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-2">é¢˜ç›®åˆ†æ</h2>

<p>æˆ‘ä»¬éœ€è¦ä»æ•°ç»„ <code>b</code> ä¸­é€‰æ‹© 4 ä¸ªç´¢å¼•ï¼ˆä¿æŒé¡ºåºï¼‰ï¼Œä¸å›ºå®šé•¿åº¦ä¸º 4 çš„æ•°ç»„ <code>a</code> å¯¹åº”ç›¸ä¹˜æ±‚å’Œï¼Œä½¿å¾—å¾—åˆ†æœ€å¤§ã€‚</p>

<p><strong>å…³é”®çº¦æŸ</strong>ï¼š
- <code>a</code> é•¿åº¦å›ºå®šä¸º 4
- <code>b</code> é•¿åº¦ <code>n â‰¥ 4</code>
- é€‰æ‹©çš„ 4 ä¸ªç´¢å¼•å¿…é¡»ä¸¥æ ¼é€’å¢ï¼š<code>i0 &lt; i1 &lt; i2 &lt; i3</code>
- ç›®æ ‡æ˜¯æœ€å¤§åŒ–ï¼š<code>a[0]*b[i0] + a[1]*b[i1] + a[2]*b[i2] + a[3]*b[i3]</code></p>

<hr />

<h2 id="è§£é¢˜æ€è·¯-4">è§£é¢˜æ€è·¯</h2>

<h3 id="æ€è·¯ä¸€åŠ¨æ€è§„åˆ’4-é˜¶æ®µ-dp">æ€è·¯ä¸€ï¼šåŠ¨æ€è§„åˆ’ï¼ˆ4 é˜¶æ®µ DPï¼‰</h3>

<p>å°†é—®é¢˜çœ‹ä½œåœ¨ <code>b</code> ä¸­æŒ‰é¡ºåºé€‰æ‹© 4 ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªé˜¶æ®µå¯¹åº”ä¸€ä¸ª <code>a[k]</code>ã€‚<br />
å®šä¹‰ <code>dp[k][i]</code> è¡¨ç¤ºä» <code>b[0..i]</code> ä¸­é€‰æ‹© <code>k+1</code> ä¸ªå…ƒç´ ï¼ˆå¯¹åº” <code>a[0..k]</code>ï¼‰çš„æœ€å¤§å¾—åˆ†ã€‚<br />
è½¬ç§»æ–¹ç¨‹ï¼š</p>

<pre><code>dp[k][i] = max(dp[k][i-1], dp[k-1][i-1] + a[k] * b[i])
</code></pre>

<p>å…¶ä¸­ <code>k = 0..3</code>ï¼Œ<code>i â‰¥ k</code>ï¼ˆå› ä¸ºè‡³å°‘éœ€è¦ k+1 ä¸ªå…ƒç´ ï¼‰ã€‚<br />
æœ€ç»ˆç­”æ¡ˆï¼š<code>dp[3][n-1]</code>ã€‚</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(4n) = O(n)<br />
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(4n) = O(n)ï¼Œå¯ä¼˜åŒ–åˆ° O(1)ï¼ˆæ»šåŠ¨æ•°ç»„ï¼‰</p>

<hr />

<h3 id="æ€è·¯äºŒåˆ†é˜¶æ®µè´ªå¿ƒåŸºäº-a-çš„ç¬¦å·">æ€è·¯äºŒï¼šåˆ†é˜¶æ®µè´ªå¿ƒï¼ˆåŸºäº a çš„ç¬¦å·ï¼‰</h3>

<p>ç”±äº <code>a</code> å›ºå®šä¸º 4 ä¸ªæ•°ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†é˜¶æ®µé€‰æ‹©ï¼š
- å¦‚æœ <code>a[k] &gt; 0</code>ï¼Œåˆ™åœ¨å¯é€‰èŒƒå›´å†…é€‰æ‹©æœ€å¤§çš„ <code>b[i]</code>
- å¦‚æœ <code>a[k] &lt; 0</code>ï¼Œåˆ™åœ¨å¯é€‰èŒƒå›´å†…é€‰æ‹©æœ€å°çš„ <code>b[i]</code>
ä½†å¿…é¡»ä¿è¯ç´¢å¼•é€’å¢ï¼Œæ‰€ä»¥æ¯ä¸ªé˜¶æ®µçš„å¯é€‰èŒƒå›´æ˜¯ <code>b</code> çš„å‰©ä½™éƒ¨åˆ†ã€‚</p>

<p>è¿™ç§æ–¹æ³•éœ€è¦ç»´æŠ¤å‰ç¼€/åç¼€çš„æœ€å¤§æœ€å°å€¼ï¼Œå®ç°è¾ƒå¤æ‚ï¼Œä¸”ä¸ä¸€å®šä¿è¯å…¨å±€æœ€ä¼˜ï¼ˆå› ä¸ºé€‰æ‹©å½“å‰æœ€ä¼˜å¯èƒ½å½±å“åç»­é€‰æ‹©ï¼‰ã€‚</p>

<hr />

<h3 id="æ€è·¯ä¸‰å››é‡å¾ªç¯ä¼˜åŒ–åç¼€æœ€å¤§å€¼">æ€è·¯ä¸‰ï¼šå››é‡å¾ªç¯ä¼˜åŒ–ï¼ˆåç¼€æœ€å¤§å€¼ï¼‰</h3>

<p>å¯¹äºå›ºå®š <code>i3</code>ï¼Œæˆ‘ä»¬éœ€è¦å‰ä¸‰ä¸ªç´¢å¼•çš„æœ€ä¼˜é€‰æ‹©ã€‚<br />
å¯ä»¥é¢„å¤„ç†ï¼š
- å¯¹äºæ¯ä¸ªä½ç½® <code>i</code>ï¼Œè®¡ç®— <code>a[3]*b[i]</code> åŠ ä¸Šä¹‹å‰ä¸‰ä¸ªé˜¶æ®µçš„æœ€å¤§å€¼ã€‚
- ç”¨ç±»ä¼¼ DP ä½†åå‘æˆ–æ­£å‘é€’æ¨çš„æ–¹å¼ï¼Œé¿å… O(nâ´) æš´åŠ›ã€‚</p>

<p>å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ <strong>åˆ†é˜¶æ®µåç¼€æœ€å¤§å€¼</strong> æ¥ä¼˜åŒ–ï¼š
1. ä»å³å¾€å·¦è®¡ç®— <code>max3[i] = max(a[3]*b[j])</code> å¯¹äº <code>j â‰¥ i</code>
2. ç„¶åè®¡ç®— <code>max2[i] = max(a[2]*b[i] + max3[i+1])</code> å¯¹äº <code>i</code>
3. ç±»ä¼¼å¾—åˆ° <code>max1</code> å’Œ <code>max0</code>ã€‚</p>

<p>è¿™æ ·æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´ O(n) æˆ– O(1)ã€‚</p>

<hr />

<h2 id="è§£æ³•å®ç°">è§£æ³•å®ç°</h2>

<h3 id="è§£æ³•ä¸€åŠ¨æ€è§„åˆ’4-é˜¶æ®µ-dpç©ºé—´ä¼˜åŒ–">è§£æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’ï¼ˆ4 é˜¶æ®µ DPï¼Œç©ºé—´ä¼˜åŒ–ï¼‰</h3>

<pre><code>func maxScore(a []int, b []int) int {
    n := len(b)
    // dpPrev å’Œ dpCurr åˆ†åˆ«è¡¨ç¤ºä¸Šä¸€é˜¶æ®µå’Œå½“å‰é˜¶æ®µ
    dpPrev := make([]int, n)
    dpCurr := make([]int, n)

    // åˆå§‹åŒ– k=0 é˜¶æ®µ
    dpCurr[0] = a[0] * b[0]
    for i := 1; i &lt; n; i++ {
        dpCurr[i] = max(dpCurr[i-1], a[0]*b[i])
    }

    // é˜¶æ®µ k=1,2,3
    for k := 1; k &lt; 4; k++ {
        dpPrev, dpCurr = dpCurr, dpPrev
        // i &lt; k æ—¶ä¸å¯èƒ½é€‰ k+1 ä¸ªå…ƒç´ ï¼Œè·³è¿‡
        dpCurr[k] = dpPrev[k-1] + a[k]*b[k]
        for i := k+1; i &lt; n; i++ {
            dpCurr[i] = max(dpCurr[i-1], dpPrev[i-1] + a[k]*b[i])
        }
    }
    return dpCurr[n-1]
}

func max(x, y int) int {
    if x &gt; y {
        return x
    }
    return y
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
using namespace std;

class Solution {
public:
    int maxScore(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {
        int n = b.size();
        vector&lt;long long&gt; dpPrev(n), dpCurr(n);
        // é˜¶æ®µ 0
        dpCurr[0] = (long long)a[0] * b[0];
        for (int i = 1; i &lt; n; i++) {
            dpCurr[i] = max(dpCurr[i-1], (long long)a[0] * b[i]);
        }
        // é˜¶æ®µ 1,2,3
        for (int k = 1; k &lt; 4; k++) {
            swap(dpPrev, dpCurr);
            dpCurr[k] = dpPrev[k-1] + (long long)a[k] * b[k];
            for (int i = k+1; i &lt; n; i++) {
                dpCurr[i] = max(dpCurr[i-1], dpPrev[i-1] + (long long)a[k] * b[i]);
            }
        }
        return dpCurr[n-1];
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(4n) = O(n)
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼ˆä¸¤ä¸ªæ•°ç»„ï¼‰</p>

<hr />

<h3 id="è§£æ³•äºŒåˆ†é˜¶æ®µåç¼€æœ€å¤§å€¼åå‘-dp">è§£æ³•äºŒï¼šåˆ†é˜¶æ®µåç¼€æœ€å¤§å€¼ï¼ˆåå‘ DPï¼‰</h3>

<p>å®šä¹‰ï¼š
- <code>suffix3[i]</code> = ä» <code>i</code> å¼€å§‹å¾€åé€‰ä¸€ä¸ªæ•°ä½œä¸ºç¬¬ 4 ä¸ªæ•°çš„æœ€å¤§ <code>a[3]*b[j]</code>
- <code>suffix2[i]</code> = ä» <code>i</code> å¼€å§‹å¾€åé€‰ä¸¤ä¸ªæ•°ï¼ˆç¬¬3ã€4ä¸ªï¼‰çš„æœ€å¤§å’Œ
- <code>suffix1[i]</code> = ä» <code>i</code> å¼€å§‹å¾€åé€‰ä¸‰ä¸ªæ•°çš„æœ€å¤§å’Œ
- <code>suffix0[i]</code> = ä» <code>i</code> å¼€å§‹å¾€åé€‰å››ä¸ªæ•°çš„æœ€å¤§å’Œï¼ˆå³æœ€ç»ˆç­”æ¡ˆï¼‰</p>

<p>é€’æ¨ï¼š</p>

<pre><code>suffix3[i] = max(a[3]*b[i], suffix3[i+1])
suffix2[i] = max(a[2]*b[i] + suffix3[i+1], suffix2[i+1])
suffix1[i] = max(a[1]*b[i] + suffix2[i+1], suffix1[i+1])
suffix0[i] = max(a[0]*b[i] + suffix1[i+1], suffix0[i+1])
</code></pre>

<p>ä»å³å¾€å·¦è®¡ç®—ã€‚</p>

<pre><code>func maxScore(a []int, b []int) int {
    n := len(b)
    suffix3 := make([]int64, n)
    suffix2 := make([]int64, n)
    suffix1 := make([]int64, n)
    suffix0 := make([]int64, n)

    // åˆå§‹åŒ–æœ€åä¸€ä¸ªä½ç½®
    suffix3[n-1] = int64(a[3]) * int64(b[n-1])
    suffix2[n-1] = -1 &lt;&lt; 62 // ä¸å¯èƒ½é€‰ä¸¤ä¸ªæ•°ï¼Œè®¾ä¸ºæå°
    suffix1[n-1] = -1 &lt;&lt; 62
    suffix0[n-1] = -1 &lt;&lt; 62

    for i := n-2; i &gt;= 0; i-- {
        // ç¬¬ 4 ä¸ªæ•°
        suffix3[i] = max(int64(a[3])*int64(b[i]), suffix3[i+1])
        // ç¬¬ 3ã€4 ä¸ªæ•°
        if i &lt;= n-2 {
            suffix2[i] = max(int64(a[2])*int64(b[i])+suffix3[i+1], suffix2[i+1])
        } else {
            suffix2[i] = -1 &lt;&lt; 62
        }
        // ç¬¬ 2ã€3ã€4 ä¸ªæ•°
        if i &lt;= n-3 {
            suffix1[i] = max(int64(a[1])*int64(b[i])+suffix2[i+1], suffix1[i+1])
        } else {
            suffix1[i] = -1 &lt;&lt; 62
        }
        // ç¬¬ 1ã€2ã€3ã€4 ä¸ªæ•°
        if i &lt;= n-4 {
            suffix0[i] = max(int64(a[0])*int64(b[i])+suffix1[i+1], suffix0[i+1])
        } else {
            suffix0[i] = -1 &lt;&lt; 62
        }
    }
    return int(suffix0[0])
}

func max(x, y int64) int64 {
    if x &gt; y {
        return x
    }
    return y
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
using namespace std;

class Solution {
public:
    int maxScore(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {
        int n = b.size();
        vector&lt;long long&gt; suffix3(n), suffix2(n), suffix1(n), suffix0(n);
        const long long INF = LLONG_MIN / 2;

        suffix3[n-1] = (long long)a[3] * b[n-1];
        suffix2[n-1] = INF;
        suffix1[n-1] = INF;
        suffix0[n-1] = INF;

        for (int i = n-2; i &gt;= 0; i--) {
            suffix3[i] = max((long long)a[3] * b[i], suffix3[i+1]);

            if (i &lt;= n-2) {
                suffix2[i] = max((long long)a[2] * b[i] + suffix3[i+1], suffix2[i+1]);
            } else {
                suffix2[i] = INF;
            }

            if (i &lt;= n-3) {
                suffix1[i] = max((long long)a[1] * b[i] + suffix2[i+1], suffix1[i+1]);
            } else {
                suffix1[i] = INF;
            }

            if (i &lt;= n-4) {
                suffix0[i] = max((long long)a[0] * b[i] + suffix1[i+1], suffix0[i+1]);
            } else {
                suffix0[i] = INF;
            }
        }
        return suffix0[0];
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼ˆå¯ä¼˜åŒ–åˆ° O(1)ï¼Œåªä¿ç•™æœ€è¿‘å‡ ä¸ªå€¼ï¼‰</p>

<hr />

<h3 id="è§£æ³•ä¸‰å››å˜é‡æ»šåŠ¨-dpæœ€ä¼˜ç©ºé—´">è§£æ³•ä¸‰ï¼šå››å˜é‡æ»šåŠ¨ DPï¼ˆæœ€ä¼˜ç©ºé—´ï¼‰</h3>

<p>ç”±äºåªä¾èµ–å‰ä¸€é˜¶æ®µï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ 4 ä¸ªå˜é‡åˆ†åˆ«è¡¨ç¤ºä»¥å½“å‰ä½ç½®ç»“å°¾çš„ 1ã€2ã€3ã€4 ä¸ªæ•°çš„æœ€å¤§å¾—åˆ†ã€‚</p>

<pre><code>func maxScore(a []int, b []int) int {
    n := len(b)
    // dp1, dp2, dp3, dp4 åˆ†åˆ«è¡¨ç¤ºé€‰æ‹© 1,2,3,4 ä¸ªæ•°çš„æœ€å¤§å¾—åˆ†
    dp1, dp2, dp3, dp4 := int64(-1e18), int64(-1e18), int64(-1e18), int64(-1e18)

    for i := 0; i &lt; n; i++ {
        val := int64(b[i])
        // æ³¨æ„æ›´æ–°é¡ºåºï¼šä»å¤šåˆ°å°‘ï¼Œé¿å…é‡å¤ä½¿ç”¨å½“å‰å…ƒç´ 
        dp4 = max(dp4, dp3 + int64(a[3])*val)
        dp3 = max(dp3, dp2 + int64(a[2])*val)
        dp2 = max(dp2, dp1 + int64(a[1])*val)
        dp1 = max(dp1, int64(a[0])*val)
    }
    return int(dp4)
}

func max(x, y int64) int64 {
    if x &gt; y {
        return x
    }
    return y
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
using namespace std;

class Solution {
public:
    int maxScore(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {
        int n = b.size();
        long long dp1 = LLONG_MIN, dp2 = LLONG_MIN, dp3 = LLONG_MIN, dp4 = LLONG_MIN;
        for (int i = 0; i &lt; n; i++) {
            long long val = b[i];
            dp4 = max(dp4, dp3 + a[3] * val);
            dp3 = max(dp3, dp2 + a[2] * val);
            dp2 = max(dp2, dp1 + a[1] * val);
            dp1 = max(dp1, a[0] * val);
        }
        return dp4;
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)</p>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”-2">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>åŠ¨æ€è§„åˆ’ï¼ˆ4é˜¶æ®µï¼‰</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>ç›´è§‚ï¼Œæ˜“äºç†è§£</td>
  <td>ç©ºé—´å¯ä¼˜åŒ–</td>
</tr>
<tr>
  <td>åç¼€æœ€å¤§å€¼</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>åå‘æ€ç»´ï¼Œé¿å…ç´¢å¼•è¶Šç•Œåˆ¤æ–­</td>
  <td>å®ç°ç¨å¤æ‚</td>
</tr>
<tr>
  <td>å››å˜é‡æ»šåŠ¨ DP</td>
  <td>O(n)</td>
  <td>O(1)</td>
  <td>æœ€ä¼˜ç©ºé—´ï¼Œä»£ç ç®€æ´</td>
  <td>éœ€è¦ä»”ç»†å¤„ç†æ›´æ–°é¡ºåº</td>
</tr>
</tbody>
</table>

<p><strong>æ¨èè§£æ³•</strong>ï¼šè§£æ³•ä¸‰ï¼ˆå››å˜é‡æ»šåŠ¨ DPï¼‰ï¼Œå› ä¸ºå®ƒåœ¨æ—¶é—´å’Œç©ºé—´ä¸Šéƒ½æ˜¯æœ€ä¼˜çš„ï¼Œä¸”ä»£ç ç®€æ´ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:48:47</em></p>

<hr />

<h1 id="2213-ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸²">2213. ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸²</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: çº¿æ®µæ ‘, æ•°ç»„, å­—ç¬¦ä¸², æœ‰åºé›†åˆ</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/longest-substring-of-one-repeating-character/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-3">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» <strong>0</strong> å¼€å§‹çš„å­—ç¬¦ä¸² <code>s</code> ã€‚å¦ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» <strong>0</strong> å¼€å§‹ã€é•¿åº¦ä¸º <code>k</code> çš„å­—ç¬¦ä¸² <code>queryCharacters</code> ï¼Œä¸€ä¸ªä¸‹æ ‡ä» <code>0</code> å¼€å§‹ã€é•¿åº¦ä¹Ÿæ˜¯ <code>k</code> çš„æ•´æ•° <strong>ä¸‹æ ‡</strong> æ•°ç»„&nbsp;<code>queryIndices</code> ï¼Œè¿™ä¸¤ä¸ªéƒ½ç”¨æ¥æè¿° <code>k</code> ä¸ªæŸ¥è¯¢ã€‚</p>

<p>ç¬¬ <code>i</code> ä¸ªæŸ¥è¯¢ä¼šå°† <code>s</code> ä¸­ä½äºä¸‹æ ‡ <code>queryIndices[i]</code> çš„å­—ç¬¦æ›´æ–°ä¸º <code>queryCharacters[i]</code> ã€‚</p>

<p>è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º <code>k</code> çš„æ•°ç»„ <code>lengths</code> ï¼Œå…¶ä¸­ <code>lengths[i]</code> æ˜¯åœ¨æ‰§è¡Œç¬¬ <code>i</code> ä¸ªæŸ¥è¯¢ <strong>ä¹‹å</strong> <code>s</code> ä¸­ä»…ç”± <strong>å•ä¸ªå­—ç¬¦é‡å¤</strong> ç»„æˆçš„ <strong>æœ€é•¿å­å­—ç¬¦ä¸²</strong> çš„ <strong>é•¿åº¦</strong> <em>ã€‚</em></p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]
<strong>è¾“å‡ºï¼š</strong>[3,3,4]
<strong>è§£é‡Šï¼š</strong>
- ç¬¬ 1 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>b<strong>b</strong>b</em>acc" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbb" ï¼Œé•¿åº¦ä¸º 3 ã€‚
- ç¬¬ 2 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "bbb<em><strong>c</strong>cc</em>" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbb" æˆ– "ccc"ï¼Œé•¿åº¦ä¸º 3 ã€‚
- ç¬¬ 3 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>bbb<strong>b</strong></em>cc" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbbb" ï¼Œé•¿åº¦ä¸º 4 ã€‚
å› æ­¤ï¼Œè¿”å› [3,3,4] ã€‚</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "abyzz", queryCharacters = "aa", queryIndices = [2,1]
<strong>è¾“å‡ºï¼š</strong>[2,3]
<strong>è§£é‡Šï¼š</strong>
- ç¬¬ 1 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "ab<strong>a</strong><em>zz</em>" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "zz" ï¼Œé•¿åº¦ä¸º 2 ã€‚
- ç¬¬ 2 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>a<strong>a</strong>a</em>zz" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "aaa" ï¼Œé•¿åº¦ä¸º 3 ã€‚
å› æ­¤ï¼Œè¿”å› [2,3] ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
    <li><code>s</code> ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ</li>
    <li><code>k == queryCharacters.length == queryIndices.length</code></li>
    <li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
    <li><code>queryCharacters</code> ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ</li>
    <li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-3">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-3">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {

    }
};
</code></pre>

<h3 id="java-3">Java</h3>

<pre><code>class Solution {
    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {

    }
}
</code></pre>

<h3 id="python3-3">Python3</h3>

<pre><code>class Solution:
    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -&gt; List[int]:

</code></pre>

<h3 id="javascript-3">JavaScript</h3>

<pre><code>/**
 * @param {string} s
 * @param {string} queryCharacters
 * @param {number[]} queryIndices
 * @return {number[]}
 */
var longestRepeating = function(s, queryCharacters, queryIndices) {

};
</code></pre>

<h3 id="go-3">Go</h3>

<pre><code>func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º-3">æç¤º</h2>

<ol>
<li>Use a segment tree to perform fast point updates and range queries.</li>
<li>We need each segment tree node to store the length of the longest substring of that segment consisting of only 1 repeating character.</li>
<li>We will also have each segment tree node store the leftmost and rightmost character of the segment, the max length of a prefix substring consisting of only 1 repeating character, and the max length of a suffix substring consisting of only 1 repeating character.</li>
<li>Use this information to properly merge the two segment tree nodes together.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-3">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>"babacc"
"bcb"
[1,3,3]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-3">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-3">é¢˜ç›®åˆ†æ</h2>

<p><strong>é—®é¢˜æ ¸å¿ƒ</strong>ï¼š
- åˆå§‹å­—ç¬¦ä¸² <code>s</code>ï¼Œé•¿åº¦ <code>n â‰¤ 1e5</code>
- æœ‰ <code>k â‰¤ 1e5</code> æ¬¡æŸ¥è¯¢ï¼Œæ¯æ¬¡æŸ¥è¯¢å°† <code>s[pos]</code> ä¿®æ”¹ä¸ºæŒ‡å®šå­—ç¬¦
- æ¯æ¬¡ä¿®æ”¹åï¼Œéœ€è¦è¿”å›å½“å‰å­—ç¬¦ä¸²ä¸­<strong>ç”±ç›¸åŒå­—ç¬¦ç»„æˆçš„è¿ç»­å­ä¸²çš„æœ€å¤§é•¿åº¦</strong></p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- æ¯æ¬¡ä¿®æ”¹åéœ€è¦å¿«é€Ÿè®¡ç®—æœ€é•¿è¿ç»­ç›¸åŒå­—ç¬¦çš„é•¿åº¦
- æš´åŠ›æ–¹æ³•ï¼ˆæ¯æ¬¡ O(n) æ‰«æï¼‰ä¼šè¶…æ—¶ï¼šO(nk) = 1e10
- éœ€è¦ç»´æŠ¤åŠ¨æ€ä¿¡æ¯ï¼Œæ”¯æŒå•ç‚¹æ›´æ–°å’Œå¿«é€ŸæŸ¥è¯¢å…¨å±€æœ€å¤§å€¼</p>

<hr />

<h2 id="è§£é¢˜æ€è·¯-5">è§£é¢˜æ€è·¯</h2>

<h3 id="æ€è·¯ä¸€çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ä¿¡æ¯æ¨è">æ€è·¯ä¸€ï¼šçº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ä¿¡æ¯ï¼ˆæ¨èï¼‰</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- ç”¨çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªåŒºé—´çš„æœ€é•¿è¿ç»­ç›¸åŒå­—ç¬¦ä¿¡æ¯
- æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ï¼š
  1. åŒºé—´é•¿åº¦ <code>len</code>
  2. å‰ç¼€æœ€é•¿è¿ç»­é•¿åº¦ <code>preLen</code>
  3. åç¼€æœ€é•¿è¿ç»­é•¿åº¦ <code>sufLen</code>
  4. åŒºé—´å†…æœ€é•¿è¿ç»­é•¿åº¦ <code>maxLen</code>
  5. åŒºé—´å·¦ç«¯å­—ç¬¦ <code>leftChar</code>
  6. åŒºé—´å³ç«¯å­—ç¬¦ <code>rightChar</code>
- åˆå¹¶ä¸¤ä¸ªå­åŒºé—´æ—¶ï¼š
  - å¦‚æœå·¦å­åŒºé—´çš„å³å­—ç¬¦ == å³å­åŒºé—´çš„å·¦å­—ç¬¦ï¼Œåˆ™å¯ä»¥åˆå¹¶
  - æ›´æ–° <code>preLen</code>, <code>sufLen</code>, <code>maxLen</code>
- æ¯æ¬¡ä¿®æ”¹æ›´æ–°å¶å­èŠ‚ç‚¹ï¼Œå‘ä¸Šåˆå¹¶
- æ ¹èŠ‚ç‚¹çš„ <code>maxLen</code> å°±æ˜¯ç­”æ¡ˆ</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- å»ºæ ‘ï¼šO(n)
- æ¯æ¬¡æŸ¥è¯¢æ›´æ–°ï¼šO(log n)
- æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h3 id="æ€è·¯äºŒåˆ†å—æ³•">æ€è·¯äºŒï¼šåˆ†å—æ³•</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- å°†å­—ç¬¦ä¸²åˆ†æˆè‹¥å¹²å—ï¼ˆæ¯å—å¤§å° â‰ˆ âˆšnï¼‰
- æ¯å—ç»´æŠ¤ï¼š
  - å—å†…æœ€é•¿è¿ç»­é•¿åº¦
  - å—å†…å‰ç¼€è¿ç»­é•¿åº¦
  - å—å†…åç¼€è¿ç»­é•¿åº¦
  - å—å†…å­—ç¬¦
- æ›´æ–°æ—¶åªæ›´æ–°æ‰€åœ¨å—
- æŸ¥è¯¢æ—¶ï¼š
  - å—å†…ç›´æ¥è®¡ç®—
  - å—é—´éœ€è¦è€ƒè™‘è¿æ¥å¤„</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- æ›´æ–°ï¼šO(âˆšn)
- æŸ¥è¯¢ï¼šO(âˆšn)
- æ€»å¤æ‚åº¦ï¼šO(kâˆšn)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h3 id="æ€è·¯ä¸‰å¹³è¡¡æ ‘treapsplayç»´æŠ¤è¿ç»­æ®µ">æ€è·¯ä¸‰ï¼šå¹³è¡¡æ ‘ï¼ˆTreap/Splayï¼‰ç»´æŠ¤è¿ç»­æ®µ</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- å°†å­—ç¬¦ä¸²è§†ä¸ºè‹¥å¹²è¿ç»­ç›¸åŒå­—ç¬¦çš„æ®µ
- ç”¨å¹³è¡¡æ ‘ç»´æŠ¤è¿™äº›æ®µï¼ˆæ¯æ®µè®°å½•å­—ç¬¦ã€é•¿åº¦ã€èµ·å§‹ä½ç½®ï¼‰
- ä¿®æ”¹æ—¶ï¼š
  - æ‰¾åˆ°åŒ…å«è¯¥ä½ç½®çš„æ®µ
  - å¯èƒ½åˆ†è£‚æ®µï¼ˆä¿®æ”¹ç‚¹åœ¨æ®µä¸­é—´ï¼‰
  - æ›´æ–°å­—ç¬¦
  - åˆå¹¶ç›¸é‚»ç›¸åŒå­—ç¬¦çš„æ®µ
- æŸ¥è¯¢æ—¶ï¼šå¹³è¡¡æ ‘ä¸­ç»´æŠ¤çš„æœ€å¤§é•¿åº¦</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- æ¯æ¬¡æ“ä½œï¼šO(log m)ï¼Œm ä¸ºæ®µæ•°
- æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h2 id="ä»£ç å®ç°-4">ä»£ç å®ç°</h2>

<h3 id="è§£æ³•ä¸€çº¿æ®µæ ‘æœ€ä¼˜è§£">è§£æ³•ä¸€ï¼šçº¿æ®µæ ‘ï¼ˆæœ€ä¼˜è§£ï¼‰</h3>

<pre><code>type Node struct {
    leftChar, rightChar byte
    preLen, sufLen, maxLen, size int
}

type SegmentTree struct {
    n int
    s []byte
    nodes []Node
}

func NewSegmentTree(str string) *SegmentTree {
    n := len(str)
    st := &amp;SegmentTree{
        n: n,
        s: []byte(str),
        nodes: make([]Node, 4*n),
    }
    st.build(1, 0, n-1)
    return st
}

func (st *SegmentTree) build(idx, l, r int) {
    if l == r {
        ch := st.s[l]
        st.nodes[idx] = Node{
            leftChar: ch,
            rightChar: ch,
            preLen: 1,
            sufLen: 1,
            maxLen: 1,
            size: 1,
        }
        return
    }
    mid := (l + r) / 2
    st.build(idx*2, l, mid)
    st.build(idx*2+1, mid+1, r)
    st.pushUp(idx)
}

func (st *SegmentTree) pushUp(idx int) {
    left := &amp;st.nodes[idx*2]
    right := &amp;st.nodes[idx*2+1]
    node := &amp;st.nodes[idx]

    node.leftChar = left.leftChar
    node.rightChar = right.rightChar
    node.size = left.size + right.size

    // å‰ç¼€é•¿åº¦
    node.preLen = left.preLen
    if left.preLen == left.size &amp;&amp; left.rightChar == right.leftChar {
        node.preLen = left.size + right.preLen
    }

    // åç¼€é•¿åº¦
    node.sufLen = right.sufLen
    if right.sufLen == right.size &amp;&amp; left.rightChar == right.leftChar {
        node.sufLen = right.size + left.sufLen
    }

    // æœ€å¤§é•¿åº¦
    node.maxLen = max(left.maxLen, right.maxLen)
    if left.rightChar == right.leftChar {
        node.maxLen = max(node.maxLen, left.sufLen+right.preLen)
    }
}

func (st *SegmentTree) update(pos int, ch byte) {
    st.updateHelper(1, 0, st.n-1, pos, ch)
}

func (st *SegmentTree) updateHelper(idx, l, r, pos int, ch byte) {
    if l == r {
        st.nodes[idx].leftChar = ch
        st.nodes[idx].rightChar = ch
        return
    }
    mid := (l + r) / 2
    if pos &lt;= mid {
        st.updateHelper(idx*2, l, mid, pos, ch)
    } else {
        st.updateHelper(idx*2+1, mid+1, r, pos, ch)
    }
    st.pushUp(idx)
}

func (st *SegmentTree) query() int {
    return st.nodes[1].maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    st := NewSegmentTree(s)
    k := len(queryIndices)
    ans := make([]int, k)

    for i := 0; i &lt; k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            st.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = st.query()
    }
    return ans
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Node {
    char leftChar, rightChar;
    int preLen, sufLen, maxLen, size;
};

class SegmentTree {
private:
    int n;
    string s;
    vector&lt;Node&gt; nodes;

    void build(int idx, int l, int r) {
        if (l == r) {
            char ch = s[l];
            nodes[idx] = {ch, ch, 1, 1, 1, 1};
            return;
        }
        int mid = (l + r) / 2;
        build(idx * 2, l, mid);
        build(idx * 2 + 1, mid + 1, r);
        pushUp(idx);
    }

    void pushUp(int idx) {
        Node&amp; left = nodes[idx * 2];
        Node&amp; right = nodes[idx * 2 + 1];
        Node&amp; node = nodes[idx];

        node.leftChar = left.leftChar;
        node.rightChar = right.rightChar;
        node.size = left.size + right.size;

        // å‰ç¼€é•¿åº¦
        node.preLen = left.preLen;
        if (left.preLen == left.size &amp;&amp; left.rightChar == right.leftChar) {
            node.preLen = left.size + right.preLen;
        }

        // åç¼€é•¿åº¦
        node.sufLen = right.sufLen;
        if (right.sufLen == right.size &amp;&amp; left.rightChar == right.leftChar) {
            node.sufLen = right.size + left.sufLen;
        }

        // æœ€å¤§é•¿åº¦
        node.maxLen = max(left.maxLen, right.maxLen);
        if (left.rightChar == right.leftChar) {
            node.maxLen = max(node.maxLen, left.sufLen + right.preLen);
        }
    }

    void updateHelper(int idx, int l, int r, int pos, char ch) {
        if (l == r) {
            nodes[idx].leftChar = ch;
            nodes[idx].rightChar = ch;
            return;
        }
        int mid = (l + r) / 2;
        if (pos &lt;= mid) {
            updateHelper(idx * 2, l, mid, pos, ch);
        } else {
            updateHelper(idx * 2 + 1, mid + 1, r, pos, ch);
        }
        pushUp(idx);
    }

public:
    SegmentTree(const string&amp; str) : s(str) {
        n = s.length();
        nodes.resize(4 * n);
        build(1, 0, n - 1);
    }

    void update(int pos, char ch) {
        updateHelper(1, 0, n - 1, pos, ch);
    }

    int query() {
        return nodes[1].maxLen;
    }
};

class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {
        SegmentTree st(s);
        int k = queryIndices.size();
        vector&lt;int&gt; ans(k);

        for (int i = 0; i &lt; k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                st.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = st.query();
        }
        return ans;
    }
};
</code></pre>

<hr />

<h3 id="è§£æ³•äºŒåˆ†å—æ³•">è§£æ³•äºŒï¼šåˆ†å—æ³•</h3>

<pre><code>type Block struct {
    start, end int
    chars []byte
    preLen, sufLen, maxLen int
}

func (b *Block) recalc() {
    n := len(b.chars)
    b.preLen = 1
    for i := 1; i &lt; n &amp;&amp; b.chars[i] == b.chars[0]; i++ {
        b.preLen++
    }

    b.sufLen = 1
    for i := n - 2; i &gt;= 0 &amp;&amp; b.chars[i] == b.chars[n-1]; i-- {
        b.sufLen++
    }

    b.maxLen = 1
    cur := 1
    for i := 1; i &lt; n; i++ {
        if b.chars[i] == b.chars[i-1] {
            cur++
            if cur &gt; b.maxLen {
                b.maxLen = cur
            }
        } else {
            cur = 1
        }
    }
}

type BlockArray struct {
    blocks []*Block
    blockSize int
    s []byte
}

func NewBlockArray(s string, blockSize int) *BlockArray {
    n := len(s)
    ba := &amp;BlockArray{
        s: []byte(s),
        blockSize: blockSize,
    }
    for i := 0; i &lt; n; i += blockSize {
        end := min(i+blockSize, n)
        block := &amp;Block{
            start: i,
            end: end,
            chars: []byte(s[i:end]),
        }
        block.recalc()
        ba.blocks = append(ba.blocks, block)
    }
    return ba
}

func (ba *BlockArray) update(pos int, ch byte) {
    ba.s[pos] = ch
    blockIdx := pos / ba.blockSize
    block := ba.blocks[blockIdx]
    localPos := pos % ba.blockSize
    block.chars[localPos] = ch
    block.recalc()
}

func (ba *BlockArray) query() int {
    maxLen := 0
    lastChar := byte(0)
    lastLen := 0

    for _, block := range ba.blocks {
        maxLen = max(maxLen, block.maxLen)

        // å¤„ç†å—é—´è¿æ¥
        if lastChar != 0 &amp;&amp; lastChar == block.chars[0] {
            total := lastLen + block.preLen
            maxLen = max(maxLen, total)
        }

        // æ›´æ–° lastChar å’Œ lastLen
        if block.sufLen == len(block.chars) {
            if lastChar == block.chars[0] {
                lastLen += len(block.chars)
            } else {
                lastLen = block.sufLen
                lastChar = block.chars[0]
            }
        } else {
            lastLen = block.sufLen
            lastChar = block.chars[len(block.chars)-1]
        }
    }
    return maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    n := len(s)
    blockSize := int(math.Sqrt(float64(n))) + 1
    ba := NewBlockArray(s, blockSize)

    k := len(queryIndices)
    ans := make([]int, k)

    for i := 0; i &lt; k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            ba.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = ba.query()
    }
    return ans
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Block {
    int start, end;
    vector&lt;char&gt; chars;
    int preLen, sufLen, maxLen;

    void recalc() {
        int n = chars.size();
        // è®¡ç®—å‰ç¼€é•¿åº¦
        preLen = 1;
        for (int i = 1; i &lt; n &amp;&amp; chars[i] == chars[0]; i++) {
            preLen++;
        }

        // è®¡ç®—åç¼€é•¿åº¦
        sufLen = 1;
        for (int i = n - 2; i &gt;= 0 &amp;&amp; chars[i] == chars[n-1]; i--) {
            sufLen++;
        }

        // è®¡ç®—æœ€å¤§é•¿åº¦
        maxLen = 1;
        int cur = 1;
        for (int i = 1; i &lt; n; i++) {
            if (chars[i] == chars[i-1]) {
                cur++;
                maxLen = max(maxLen, cur);
            } else {
                cur = 1;
            }
        }
    }
};

class BlockArray {
private:
    vector&lt;Block&gt; blocks;
    int blockSize;
    string s;

public:
    BlockArray(const string&amp; str, int bs) : s(str), blockSize(bs) {
        int n = s.length();
        for (int i = 0; i &lt; n; i += blockSize) {
            int end = min(i + blockSize, n);
            Block block;
            block.start = i;
            block.end = end;
            for (int j = i; j &lt; end; j++) {
                block.chars.push_back(s[j]);
            }
            block.recalc();
            blocks.push_back(block);
        }
    }

    void update(int pos, char ch) {
        s[pos] = ch;
        int blockIdx = pos / blockSize;
        int localPos = pos % blockSize;
        blocks[blockIdx].chars[localPos] = ch;
        blocks[blockIdx].recalc();
    }

    int query() {
        int maxLen = 0;
        char lastChar = 0;
        int lastLen = 0;

        for (auto&amp; block : blocks) {
            maxLen = max(maxLen, block.maxLen);

            // å¤„ç†å—é—´è¿æ¥
            if (lastChar != 0 &amp;&amp; lastChar == block.chars[0]) {
                int total = lastLen + block.preLen;
                maxLen = max(maxLen, total);
            }

            // æ›´æ–° lastChar å’Œ lastLen
            if (block.sufLen == (int)block.chars.size()) {
                if (lastChar == block.chars[0]) {
                    lastLen += block.chars.size();
                } else {
                    lastLen = block.sufLen;
                    lastChar = block.chars[0];
                }
            } else {
                lastLen = block.sufLen;
                lastChar = block.chars.back();
            }
        }
        return maxLen;
    }
};

class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {
        int n = s.length();
        int blockSize = sqrt(n) + 1;
        BlockArray ba(s, blockSize);

        int k = queryIndices.size();
        vector&lt;int&gt; ans(k);

        for (int i = 0; i &lt; k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                ba.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = ba.query();
        }
        return ans;
    }
};
</code></pre>

<hr />

<h2 id="å¤æ‚åº¦åˆ†æ-4">å¤æ‚åº¦åˆ†æ</h2>

<h3 id="è§£æ³•ä¸€çº¿æ®µæ ‘">è§£æ³•ä¸€ï¼šçº¿æ®µæ ‘</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
<ul>
<li>å»ºæ ‘ï¼šO(n)</li>
<li>æ¯æ¬¡æ›´æ–°ï¼šO(log n)</li>
<li>æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</li>
</ul>

<h3 id="è§£æ³•äºŒåˆ†å—æ³•-2">è§£æ³•äºŒï¼šåˆ†å—æ³•</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
<ul>
<li>åˆå§‹åŒ–ï¼šO(n)</li>
<li>æ¯æ¬¡æ›´æ–°ï¼šO(âˆšn)ï¼ˆæ›´æ–°ä¸€ä¸ªå—ï¼‰</li>
<li>æ¯æ¬¡æŸ¥è¯¢ï¼šO(âˆšn)ï¼ˆéå†æ‰€æœ‰å—ï¼‰</li>
<li>æ€»å¤æ‚åº¦ï¼šO(kâˆšn)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</li>
</ul>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”-3">è§£æ³•å¯¹æ¯”</h2>

<p>| ç‰¹æ€§</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:50:30</em></p>

        </div>
    </div>
</body>
</html>