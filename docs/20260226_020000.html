<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 2026-02-26 02:00:00</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
        <div class="content">
            <h1>ğŸ“… 2026-02-26 02:00:00 æ¯æ—¥é¢˜ç›® (ç¬¬ 3 ç»„)</h1>
            <h1 id="2092-æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶">2092. æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: æ·±åº¦ä¼˜å…ˆæœç´¢, å¹¿åº¦ä¼˜å…ˆæœç´¢, å¹¶æŸ¥é›†, å›¾, æ’åº</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/find-all-people-with-secret/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªæ•´æ•° <code>n</code> ï¼Œè¡¨ç¤ºæœ‰ <code>n</code> ä¸ªä¸“å®¶ä» <code>0</code> åˆ° <code>n - 1</code> ç¼–å·ã€‚å¦å¤–ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„äºŒç»´æ•´æ•°æ•°ç»„ <code>meetings</code> ï¼Œå…¶ä¸­ <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> è¡¨ç¤ºä¸“å®¶ <code>x<sub>i</sub></code> å’Œä¸“å®¶ <code>y<sub>i</sub></code> åœ¨æ—¶é—´ <code>time<sub>i</sub></code> è¦å¼€ä¸€åœºä¼šã€‚ä¸€ä¸ªä¸“å®¶å¯ä»¥åŒæ—¶å‚åŠ  <strong>å¤šåœºä¼šè®®</strong> ã€‚æœ€åï¼Œç»™ä½ ä¸€ä¸ªæ•´æ•° <code>firstPerson</code> ã€‚</p>

<p>ä¸“å®¶ <code>0</code> æœ‰ä¸€ä¸ª <strong>ç§˜å¯†</strong> ï¼Œæœ€åˆï¼Œä»–åœ¨æ—¶é—´&nbsp;<code>0</code> å°†è¿™ä¸ªç§˜å¯†åˆ†äº«ç»™äº†ä¸“å®¶ <code>firstPerson</code> ã€‚æ¥ç€ï¼Œè¿™ä¸ªç§˜å¯†ä¼šåœ¨æ¯æ¬¡æœ‰çŸ¥æ™“è¿™ä¸ªç§˜å¯†çš„ä¸“å®¶å‚åŠ ä¼šè®®æ—¶è¿›è¡Œä¼ æ’­ã€‚æ›´æ­£å¼çš„è¡¨è¾¾æ˜¯ï¼Œæ¯æ¬¡ä¼šè®®ï¼Œå¦‚æœä¸“å®¶ <code>x<sub>i</sub></code> åœ¨æ—¶é—´ <code>time<sub>i</sub></code> æ—¶çŸ¥æ™“è¿™ä¸ªç§˜å¯†ï¼Œé‚£ä¹ˆä»–å°†ä¼šä¸ä¸“å®¶ <code>y<sub>i</sub></code> åˆ†äº«è¿™ä¸ªç§˜å¯†ï¼Œåä¹‹äº¦ç„¶ã€‚</p>

<p>ç§˜å¯†å…±äº«æ˜¯ <strong>ç¬æ—¶å‘ç”Ÿ</strong> çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨åŒä¸€æ—¶é—´ï¼Œä¸€ä¸ªä¸“å®¶ä¸å…‰å¯ä»¥æ¥æ”¶åˆ°ç§˜å¯†ï¼Œè¿˜èƒ½åœ¨å…¶ä»–ä¼šè®®ä¸Šä¸å…¶ä»–ä¸“å®¶åˆ†äº«ã€‚</p>

<p>åœ¨æ‰€æœ‰ä¼šè®®éƒ½ç»“æŸä¹‹åï¼Œè¿”å›æ‰€æœ‰çŸ¥æ™“è¿™ä¸ªç§˜å¯†çš„ä¸“å®¶åˆ—è¡¨ã€‚ä½ å¯ä»¥æŒ‰ <strong>ä»»ä½•é¡ºåº</strong> è¿”å›ç­”æ¡ˆã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>è¾“å‡ºï¼š</strong>[0,1,2,3,5]
<strong>è§£é‡Šï¼š
</strong>æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 1 å…±äº«ã€‚
æ—¶é—´ 5 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 2 å…±äº«ã€‚
æ—¶é—´ 8 ï¼Œä¸“å®¶ 2 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ—¶é—´ 10 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 5 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1ã€2ã€3 å’Œ 5 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>è¾“å‡ºï¼š</strong>[0,1,3]
<strong>è§£é‡Šï¼š</strong>
æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ—¶é—´ 2 ï¼Œä¸“å®¶ 1 ä¸ä¸“å®¶ 2 éƒ½ä¸çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
æ—¶é—´ 3 ï¼Œä¸“å®¶ 3 å°†ç§˜å¯†ä¸ä¸“å®¶ 0 å’Œä¸“å®¶ 1 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1 å’Œ 3 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>è¾“å‡ºï¼š</strong>[0,1,2,3,4]
<strong>è§£é‡Šï¼š</strong>
æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 1 å…±äº«ã€‚
æ—¶é—´ 1 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 2 å…±äº«ï¼Œä¸“å®¶ 2 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ³¨æ„ï¼Œä¸“å®¶ 2 å¯ä»¥åœ¨æ”¶åˆ°ç§˜å¯†çš„åŒä¸€æ—¶é—´åˆ†äº«æ­¤ç§˜å¯†ã€‚
æ—¶é—´ 2 ï¼Œä¸“å®¶ 3 å°†ç§˜å¯†ä¸ä¸“å®¶ 4 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1ã€2ã€3 å’Œ 4 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
    <li><code>meetings[i].length == 3</code></li>
    <li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
    <li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
    <li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public List&lt;Integer&gt; findAllPeople(int n, int[][] meetings, int firstPerson) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -&gt; List[int]:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @param {number[][]} meetings
 * @param {number} firstPerson
 * @return {number[]}
 */
var findAllPeople = function(n, meetings, firstPerson) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Could you model all the meetings happening at the same time as a graph?</li>
<li>What data structure can you use to efficiently share the secret?</li>
<li>You can use the union-find data structure to quickly determine who knows the secret and share the secret.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>6
[[1,2,5],[2,3,8],[1,5,10]]
1
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ª<strong>æ—¶é—´ä¾èµ–çš„å›¾ä¼ æ’­é—®é¢˜</strong>ã€‚ä¸“å®¶æ˜¯èŠ‚ç‚¹ï¼Œä¼šè®®æ˜¯è¾¹ï¼Œä½†è¾¹åªåœ¨ç‰¹å®šæ—¶é—´ç‚¹æœ‰æ•ˆã€‚ç§˜å¯†ä»ä¸“å®¶0å’ŒfirstPersonå¼€å§‹ï¼Œé€šè¿‡ä¼šè®®åœ¨ä¸“å®¶é—´ä¼ æ’­ã€‚å…³é”®ç‚¹ï¼š
- ä¼šè®®æŒ‰æ—¶é—´é¡ºåºå‘ç”Ÿ
- åŒä¸€æ—¶é—´å¯èƒ½æœ‰å¤šä¸ªä¼šè®®åŒæ—¶è¿›è¡Œ
- ç§˜å¯†ä¼ æ’­æ˜¯ç¬æ—¶çš„ï¼ˆåŒä¸€æ—¶é—´å¯ä»¥ä¼ æ’­å¤šæ¬¡ï¼‰</p>

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<p>æ ¸å¿ƒæ€æƒ³ï¼š<strong>æŒ‰æ—¶é—´åˆ†ç»„å¤„ç†ä¼šè®®</strong>ï¼Œå¯¹æ¯ä¸ªæ—¶é—´ç‚¹çš„ä¼šè®®é›†åˆï¼Œä½¿ç”¨å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰æ¥åˆå¹¶çŸ¥æ™“ç§˜å¯†çš„ä¸“å®¶ã€‚</p>

<h3 id="å…³é”®è§‚å¯Ÿ">å…³é”®è§‚å¯Ÿ</h3>

<ol>
<li>åŒä¸€æ—¶é—´ç‚¹çš„ä¼šè®®å¯ä»¥ä»»æ„é¡ºåºå‘ç”Ÿï¼Œç§˜å¯†å¯ä»¥åœ¨è¿™äº›ä¼šè®®ä¸­ä¼ æ’­</li>
<li>ä¸åŒæ—¶é—´ç‚¹çš„ä¼šè®®éœ€è¦æŒ‰æ—¶é—´é¡ºåºå¤„ç†</li>
<li>å¦‚æœä¸€ç»„ä¸“å®¶åœ¨åŒä¸€æ—¶é—´é€šè¿‡ä¼šè®®è¿é€šï¼Œä¸”å…¶ä¸­è‡³å°‘ä¸€äººçŸ¥æ™“ç§˜å¯†ï¼Œåˆ™æ•´ç»„éƒ½ä¼šçŸ¥æ™“</li>
</ol>

<h2 id="è§£æ³•ä¸€æŒ‰æ—¶é—´åˆ†ç»„-å¹¶æŸ¥é›†æ¨è">è§£æ³•ä¸€ï¼šæŒ‰æ—¶é—´åˆ†ç»„ + å¹¶æŸ¥é›†ï¼ˆæ¨èï¼‰</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<ol>
<li>æŒ‰ä¼šè®®æ—¶é—´åˆ†ç»„</li>
<li>å¯¹æ¯ä¸ªæ—¶é—´ç‚¹çš„ä¼šè®®ï¼š
<ul>
<li>ç”¨å¹¶æŸ¥é›†è¿æ¥å‚ä¼šä¸“å®¶</li>
<li>æ£€æŸ¥æ¯ä¸ªè¿é€šåˆ†é‡ï¼šå¦‚æœåŒ…å«å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶ï¼Œæ ‡è®°æ•´ä¸ªåˆ†é‡ä¸ºçŸ¥æ™“ç§˜å¯†</li>
</ul></li>
<li>å¤„ç†å®Œä¸€ä¸ªæ—¶é—´ç‚¹åï¼Œé‡ç½®å¹¶æŸ¥é›†ï¼ˆåªä¿ç•™çŸ¥æ™“ç§˜å¯†çš„çŠ¶æ€ï¼‰</li>
</ol>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æŒ‰æ—¶é—´åˆ†ç»„ä¼šè®®
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        x, y, t := meeting[0], meeting[1], meeting[2]
        timeMap[t] = append(timeMap[t], [2]int{x, y})
    }

    // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true

    // è·å–æ‰€æœ‰æ—¶é—´ç‚¹å¹¶æ’åº
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)

    for _, t := range times {
        meetingsAtTime := timeMap[t]

        // æ„å»ºå½“å‰æ—¶é—´ç‚¹çš„å›¾
        graph := make(map[int][]int)
        experts := make(map[int]bool)

        for _, meeting := range meetingsAtTime {
            x, y := meeting[0], meeting[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
            experts[x] = true
            experts[y] = true
        }

        // BFSä¼ æ’­ç§˜å¯†
        queue := make([]int, 0)
        visited := make(map[int]bool)

        // å°†æ‰€æœ‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶åŠ å…¥é˜Ÿåˆ—
        for expert := range experts {
            if known[expert] &amp;&amp; !visited[expert] {
                queue = append(queue, expert)
                visited[expert] = true
            }
        }

        // BFSéå†
        for len(queue) &gt; 0 {
            curr := queue[0]
            queue = queue[1:]

            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }

    // æ”¶é›†ç»“æœ
    result := make([]int, 0)
    for i := 0; i &lt; n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
</code></pre>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æŒ‰æ—¶é—´åˆ†ç»„ä¼šè®®
        map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; timeMap;
        for (auto&amp; meeting : meetings) {
            int x = meeting[0], y = meeting[1], t = meeting[2];
            timeMap[t].push_back({x, y});
        }

        // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
        vector&lt;bool&gt; known(n, false);
        known[0] = true;
        known[firstPerson] = true;

        for (auto&amp; [time, meetingsAtTime] : timeMap) {
            // æ„å»ºå½“å‰æ—¶é—´ç‚¹çš„å›¾
            unordered_map&lt;int, vector&lt;int&gt;&gt; graph;
            unordered_set&lt;int&gt; experts;

            for (auto&amp; [x, y] : meetingsAtTime) {
                graph[x].push_back(y);
                graph[y].push_back(x);
                experts.insert(x);
                experts.insert(y);
            }

            // BFSä¼ æ’­ç§˜å¯†
            queue&lt;int&gt; q;
            unordered_set&lt;int&gt; visited;

            // å°†æ‰€æœ‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶åŠ å…¥é˜Ÿåˆ—
            for (int expert : experts) {
                if (known[expert] &amp;&amp; !visited.count(expert)) {
                    q.push(expert);
                    visited.insert(expert);
                }
            }

            // BFSéå†
            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }

        // æ”¶é›†ç»“æœ
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(T + M + N)ï¼Œå…¶ä¸­Tæ˜¯ä¸åŒæ—¶é—´ç‚¹æ•°é‡ï¼ŒMæ˜¯ä¼šè®®æ•°ï¼ŒNæ˜¯ä¸“å®¶æ•°
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N + M)</p>

<h2 id="è§£æ³•äºŒå¹¶æŸ¥é›†-æ—¶é—´æ’åºä¼˜åŒ–">è§£æ³•äºŒï¼šå¹¶æŸ¥é›† + æ—¶é—´æ’åºä¼˜åŒ–</h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<p>ä½¿ç”¨å¹¶æŸ¥é›†ï¼Œä½†åœ¨æ¯ä¸ªæ—¶é—´ç‚¹å¤„ç†å®Œåï¼Œéœ€è¦é‡ç½®é‚£äº›ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶çš„è¿æ¥çŠ¶æ€ã€‚</p>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æŒ‰æ—¶é—´æ’åºä¼šè®®
    sort.Slice(meetings, func(i, j int) bool {
        return meetings[i][2] &lt; meetings[j][2]
    })

    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    parent := make([]int, n)
    for i := range parent {
        parent[i] = i
    }

    // åˆå¹¶0å’ŒfirstPerson
    union(parent, 0, firstPerson)

    i := 0
    m := len(meetings)

    for i &lt; m {
        j := i
        // æ‰¾åˆ°ç›¸åŒæ—¶é—´çš„æ‰€æœ‰ä¼šè®®
        for j &lt; m &amp;&amp; meetings[j][2] == meetings[i][2] {
            j++
        }

        // è¿æ¥å½“å‰æ—¶é—´çš„æ‰€æœ‰ä¸“å®¶
        for k := i; k &lt; j; k++ {
            union(parent, meetings[k][0], meetings[k][1])
        }

        // æ£€æŸ¥å“ªäº›ä¸“å®¶çŸ¥é“äº†ç§˜å¯†
        for k := i; k &lt; j; k++ {
            x, y := meetings[k][0], meetings[k][1]
            if find(parent, x) == find(parent, 0) {
                // è¿™ä¸ªè¿é€šåˆ†é‡çŸ¥é“äº†ç§˜å¯†
            } else {
                // é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
                parent[x] = x
                parent[y] = y
            }
        }

        i = j
    }

    // æ”¶é›†çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
    result := []int{}
    for idx := 0; idx &lt; n; idx++ {
        if find(parent, idx) == find(parent, 0) {
            result = append(result, idx)
        }
    }
    return result
}

func find(parent []int, x int) int {
    if parent[x] != x {
        parent[x] = find(parent, parent[x])
    }
    return parent[x]
}

func union(parent []int, x, y int) {
    rootX := find(parent, x)
    rootY := find(parent, y)
    if rootX != rootY {
        parent[rootY] = rootX
    }
}
</code></pre>

<pre><code>class Solution {
private:
    vector&lt;int&gt; parent;

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootY] = rootX;
        }
    }

public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æŒ‰æ—¶é—´æ’åºä¼šè®®
        sort(meetings.begin(), meetings.end(), 
             [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
                 return a[2] &lt; b[2];
             });

        // åˆå§‹åŒ–å¹¶æŸ¥é›†
        parent.resize(n);
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
        }

        // åˆå¹¶0å’ŒfirstPerson
        unite(0, firstPerson);

        int m = meetings.size();
        for (int i = 0; i &lt; m; ) {
            int j = i;
            // æ‰¾åˆ°ç›¸åŒæ—¶é—´çš„æ‰€æœ‰ä¼šè®®
            while (j &lt; m &amp;&amp; meetings[j][2] == meetings[i][2]) {
                j++;
            }

            // è¿æ¥å½“å‰æ—¶é—´çš„æ‰€æœ‰ä¸“å®¶
            for (int k = i; k &lt; j; k++) {
                unite(meetings[k][0], meetings[k][1]);
            }

            // æ£€æŸ¥å¹¶é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
            for (int k = i; k &lt; j; k++) {
                int x = meetings[k][0], y = meetings[k][1];
                if (find(x) != find(0)) {
                    // é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
                    parent[x] = x;
                    parent[y] = y;
                }
            }

            i = j;
        }

        // æ”¶é›†çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (find(i) == find(0)) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(M log M + M Î±(N))ï¼Œå…¶ä¸­Î±æ˜¯åé˜¿å…‹æ›¼å‡½æ•°
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N)</p>

<h2 id="è§£æ³•ä¸‰bfsæŒ‰å±‚ä¼ æ’­">è§£æ³•ä¸‰ï¼šBFSæŒ‰å±‚ä¼ æ’­</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<p>å°†ä¼šè®®æŒ‰æ—¶é—´æ’åºï¼Œä½¿ç”¨BFSæŒ‰æ—¶é—´å±‚ä¼ æ’­ç§˜å¯†ã€‚</p>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æ„å»ºé‚»æ¥è¡¨ï¼šæ—¶é—´ -&gt; [ä¸“å®¶å¯¹]
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        timeMap[meeting[2]] = append(timeMap[meeting[2]], [2]int{meeting[0], meeting[1]})
    }

    // è·å–æ‰€æœ‰æ—¶é—´å¹¶æ’åº
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)

    // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true

    for _, t := range times {
        // æ„å»ºå½“å‰æ—¶é—´çš„å›¾
        graph := make(map[int][]int)
        for _, pair := range timeMap[t] {
            x, y := pair[0], pair[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
        }

        // BFSé˜Ÿåˆ—
        queue := make([]int, 0)
        visited := make(map[int]bool)

        // æ·»åŠ å½“å‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
        for node := range graph {
            if known[node] &amp;&amp; !visited[node] {
                queue = append(queue, node)
                visited[node] = true
            }
        }

        // BFSä¼ æ’­
        for len(queue) &gt; 0 {
            curr := queue[0]
            queue = queue[1:]

            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }

    // æ”¶é›†ç»“æœ
    result := make([]int, 0)
    for i := 0; i &lt; n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
</code></pre>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æ„å»ºæ—¶é—´æ˜ å°„
        map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; timeMap;
        for (auto&amp; meeting : meetings) {
            timeMap[meeting[2]].push_back({meeting[0], meeting[1]});
        }

        vector&lt;bool&gt; known(n, false);
        known[0] = true;
        known[firstPerson] = true;

        for (auto&amp; [time, pairs] : timeMap) {
            // æ„å»ºå½“å‰æ—¶é—´çš„å›¾
            unordered_map&lt;int, vector&lt;int&gt;&gt; graph;
            for (auto&amp; [x, y] : pairs) {
                graph[x].push_back(y);
                graph[y].push_back(x);
            }

            // BFSä¼ æ’­
            queue&lt;int&gt; q;
            unordered_set&lt;int&gt; visited;

            // æ·»åŠ å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
            for (auto&amp; [node, _] : graph) {
                if (known[node] &amp;&amp; !visited.count(node)) {
                    q.push(node);
                    visited.insert(node);
                }
            }

            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }

        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(T + M + N)
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N + M)</p>

<h2 id="å¤æ‚åº¦å¯¹æ¯”">å¤æ‚åº¦å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>è§£æ³•ä¸€</td>
  <td>O(T + M + N)</td>
  <td>O(N + M)</td>
  <td>é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£</td>
  <td>éœ€è¦é¢å¤–å­˜å‚¨æ—¶é—´åˆ†ç»„</td>
</tr>
<tr>
  <td>è§£æ³•äºŒ</td>
  <td>O(M log M + M Î±(N))</td>
  <td>O(N)</td>
  <td>ç©ºé—´æ•ˆç‡é«˜ï¼Œä½¿ç”¨å¹¶æŸ¥é›†</td>
  <td>éœ€è¦é‡ç½®å¹¶æŸ¥é›†çŠ¶æ€</td>
</tr>
<tr>
  <td>è§£æ³•ä¸‰</td>
  <td>O(T + M + N)</td>
  <td>O(N + M)</td>
  <td>BFSç›´è§‚ï¼Œé€‚åˆå›¾ä¼ æ’­</td>
  <td>éœ€è¦æ„å»ºæ—¶é—´æ˜ å°„</td>
</tr>
</tbody>
</table>

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<ol>
<li><strong>è§£æ³•ä¸€ï¼ˆåˆ†ç»„+BFSï¼‰</strong> æ˜¯æœ€ç›´è§‚çš„è§£æ³•ï¼Œé€‚åˆç†è§£å’Œå®ç°</li>
<li><strong>è§£æ³•äºŒï¼ˆå¹¶æŸ¥é›†ï¼‰</strong> ç©ºé—´æ•ˆç‡æœ€é«˜ï¼Œä½†éœ€è¦å°å¿ƒå¤„ç†çŠ¶æ€é‡ç½®</li>
<li><strong>è§£æ³•ä¸‰ï¼ˆBFSåˆ†å±‚ï¼‰</strong> ä¸è§£æ³•ä¸€ç±»ä¼¼ï¼Œä½†æ›´å¼ºè°ƒæ—¶é—´åˆ†å±‚</li>
</ol>

<p><strong>æ¨èä½¿ç”¨è§£æ³•ä¸€</strong>ï¼Œå› ä¸ºï¼š
- é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œè°ƒè¯•
- æ—¶é—´å¤æ‚åº¦ä¸æœ€ä¼˜è§£ç›¸åŒ
- é€‚åˆå¤„ç†å¤§è§„æ¨¡æ•°æ®
- ä»£ç å¯è¯»æ€§å¥½ï¼Œæ˜“äºç»´æŠ¤</p>

<p>åœ¨å®é™…LeetCodeæäº¤ä¸­ï¼Œè§£æ³•ä¸€å’Œè§£æ³•äºŒéƒ½æœ‰å¾ˆå¥½çš„æ€§èƒ½è¡¨ç°ï¼Œå¯ä»¥æ ¹æ®ä¸ªäººåå¥½é€‰æ‹©ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 19:08:03</em></p>

<hr />

<h1 id="2213-ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸²">2213. ç”±å•ä¸ªå­—ç¬¦é‡å¤çš„æœ€é•¿å­å­—ç¬¦ä¸²</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: çº¿æ®µæ ‘, æ•°ç»„, å­—ç¬¦ä¸², æœ‰åºé›†åˆ</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/longest-substring-of-one-repeating-character/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-2">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» <strong>0</strong> å¼€å§‹çš„å­—ç¬¦ä¸² <code>s</code> ã€‚å¦ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» <strong>0</strong> å¼€å§‹ã€é•¿åº¦ä¸º <code>k</code> çš„å­—ç¬¦ä¸² <code>queryCharacters</code> ï¼Œä¸€ä¸ªä¸‹æ ‡ä» <code>0</code> å¼€å§‹ã€é•¿åº¦ä¹Ÿæ˜¯ <code>k</code> çš„æ•´æ•° <strong>ä¸‹æ ‡</strong> æ•°ç»„&nbsp;<code>queryIndices</code> ï¼Œè¿™ä¸¤ä¸ªéƒ½ç”¨æ¥æè¿° <code>k</code> ä¸ªæŸ¥è¯¢ã€‚</p>

<p>ç¬¬ <code>i</code> ä¸ªæŸ¥è¯¢ä¼šå°† <code>s</code> ä¸­ä½äºä¸‹æ ‡ <code>queryIndices[i]</code> çš„å­—ç¬¦æ›´æ–°ä¸º <code>queryCharacters[i]</code> ã€‚</p>

<p>è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º <code>k</code> çš„æ•°ç»„ <code>lengths</code> ï¼Œå…¶ä¸­ <code>lengths[i]</code> æ˜¯åœ¨æ‰§è¡Œç¬¬ <code>i</code> ä¸ªæŸ¥è¯¢ <strong>ä¹‹å</strong> <code>s</code> ä¸­ä»…ç”± <strong>å•ä¸ªå­—ç¬¦é‡å¤</strong> ç»„æˆçš„ <strong>æœ€é•¿å­å­—ç¬¦ä¸²</strong> çš„ <strong>é•¿åº¦</strong> <em>ã€‚</em></p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]
<strong>è¾“å‡ºï¼š</strong>[3,3,4]
<strong>è§£é‡Šï¼š</strong>
- ç¬¬ 1 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>b<strong>b</strong>b</em>acc" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbb" ï¼Œé•¿åº¦ä¸º 3 ã€‚
- ç¬¬ 2 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "bbb<em><strong>c</strong>cc</em>" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbb" æˆ– "ccc"ï¼Œé•¿åº¦ä¸º 3 ã€‚
- ç¬¬ 3 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>bbb<strong>b</strong></em>cc" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "bbbb" ï¼Œé•¿åº¦ä¸º 4 ã€‚
å› æ­¤ï¼Œè¿”å› [3,3,4] ã€‚</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "abyzz", queryCharacters = "aa", queryIndices = [2,1]
<strong>è¾“å‡ºï¼š</strong>[2,3]
<strong>è§£é‡Šï¼š</strong>
- ç¬¬ 1 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "ab<strong>a</strong><em>zz</em>" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "zz" ï¼Œé•¿åº¦ä¸º 2 ã€‚
- ç¬¬ 2 æ¬¡æŸ¥è¯¢æ›´æ–°å s = "<em>a<strong>a</strong>a</em>zz" ã€‚ç”±å•ä¸ªå­—ç¬¦é‡å¤ç»„æˆçš„æœ€é•¿å­å­—ç¬¦ä¸²æ˜¯ "aaa" ï¼Œé•¿åº¦ä¸º 3 ã€‚
å› æ­¤ï¼Œè¿”å› [2,3] ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
    <li><code>s</code> ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ</li>
    <li><code>k == queryCharacters.length == queryIndices.length</code></li>
    <li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
    <li><code>queryCharacters</code> ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ</li>
    <li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-2">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-2">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {

    }
};
</code></pre>

<h3 id="java-2">Java</h3>

<pre><code>class Solution {
    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {

    }
}
</code></pre>

<h3 id="python3-2">Python3</h3>

<pre><code>class Solution:
    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -&gt; List[int]:

</code></pre>

<h3 id="javascript-2">JavaScript</h3>

<pre><code>/**
 * @param {string} s
 * @param {string} queryCharacters
 * @param {number[]} queryIndices
 * @return {number[]}
 */
var longestRepeating = function(s, queryCharacters, queryIndices) {

};
</code></pre>

<h3 id="go-2">Go</h3>

<pre><code>func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º-2">æç¤º</h2>

<ol>
<li>Use a segment tree to perform fast point updates and range queries.</li>
<li>We need each segment tree node to store the length of the longest substring of that segment consisting of only 1 repeating character.</li>
<li>We will also have each segment tree node store the leftmost and rightmost character of the segment, the max length of a prefix substring consisting of only 1 repeating character, and the max length of a suffix substring consisting of only 1 repeating character.</li>
<li>Use this information to properly merge the two segment tree nodes together.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-2">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>"babacc"
"bcb"
[1,3,3]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-2">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-2">é¢˜ç›®åˆ†æ</h2>

<p><strong>é—®é¢˜æ ¸å¿ƒ</strong>ï¼š
- åˆå§‹å­—ç¬¦ä¸² <code>s</code>ï¼Œé•¿åº¦ <code>n â‰¤ 1e5</code>
- æœ‰ <code>k â‰¤ 1e5</code> æ¬¡æŸ¥è¯¢ï¼Œæ¯æ¬¡æŸ¥è¯¢å°† <code>s[pos]</code> ä¿®æ”¹ä¸ºæŒ‡å®šå­—ç¬¦
- æ¯æ¬¡ä¿®æ”¹åï¼Œéœ€è¦è¿”å›å½“å‰å­—ç¬¦ä¸²ä¸­<strong>ç”±ç›¸åŒå­—ç¬¦ç»„æˆçš„è¿ç»­å­ä¸²çš„æœ€å¤§é•¿åº¦</strong></p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
- æ¯æ¬¡ä¿®æ”¹åéœ€è¦å¿«é€Ÿè®¡ç®—æœ€é•¿è¿ç»­ç›¸åŒå­—ç¬¦çš„é•¿åº¦
- æš´åŠ›æ–¹æ³•ï¼ˆæ¯æ¬¡ O(n) æ‰«æï¼‰ä¼šè¶…æ—¶ï¼šO(nk) = 1e10
- éœ€è¦ç»´æŠ¤åŠ¨æ€ä¿¡æ¯ï¼Œæ”¯æŒå•ç‚¹æ›´æ–°å’Œå¿«é€ŸæŸ¥è¯¢å…¨å±€æœ€å¤§å€¼</p>

<hr />

<h2 id="è§£é¢˜æ€è·¯-2">è§£é¢˜æ€è·¯</h2>

<h3 id="æ€è·¯ä¸€çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ä¿¡æ¯æ¨è">æ€è·¯ä¸€ï¼šçº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ä¿¡æ¯ï¼ˆæ¨èï¼‰</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- ç”¨çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªåŒºé—´çš„æœ€é•¿è¿ç»­ç›¸åŒå­—ç¬¦ä¿¡æ¯
- æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ï¼š
  1. åŒºé—´é•¿åº¦ <code>len</code>
  2. å‰ç¼€æœ€é•¿è¿ç»­é•¿åº¦ <code>preLen</code>
  3. åç¼€æœ€é•¿è¿ç»­é•¿åº¦ <code>sufLen</code>
  4. åŒºé—´å†…æœ€é•¿è¿ç»­é•¿åº¦ <code>maxLen</code>
  5. åŒºé—´å·¦ç«¯å­—ç¬¦ <code>leftChar</code>
  6. åŒºé—´å³ç«¯å­—ç¬¦ <code>rightChar</code>
- åˆå¹¶ä¸¤ä¸ªå­åŒºé—´æ—¶ï¼š
  - å¦‚æœå·¦å­åŒºé—´çš„å³å­—ç¬¦ == å³å­åŒºé—´çš„å·¦å­—ç¬¦ï¼Œåˆ™å¯ä»¥åˆå¹¶
  - æ›´æ–° <code>preLen</code>, <code>sufLen</code>, <code>maxLen</code>
- æ¯æ¬¡ä¿®æ”¹æ›´æ–°å¶å­èŠ‚ç‚¹ï¼Œå‘ä¸Šåˆå¹¶
- æ ¹èŠ‚ç‚¹çš„ <code>maxLen</code> å°±æ˜¯ç­”æ¡ˆ</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- å»ºæ ‘ï¼šO(n)
- æ¯æ¬¡æŸ¥è¯¢æ›´æ–°ï¼šO(log n)
- æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h3 id="æ€è·¯äºŒåˆ†å—æ³•">æ€è·¯äºŒï¼šåˆ†å—æ³•</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- å°†å­—ç¬¦ä¸²åˆ†æˆè‹¥å¹²å—ï¼ˆæ¯å—å¤§å° â‰ˆ âˆšnï¼‰
- æ¯å—ç»´æŠ¤ï¼š
  - å—å†…æœ€é•¿è¿ç»­é•¿åº¦
  - å—å†…å‰ç¼€è¿ç»­é•¿åº¦
  - å—å†…åç¼€è¿ç»­é•¿åº¦
  - å—å†…å­—ç¬¦
- æ›´æ–°æ—¶åªæ›´æ–°æ‰€åœ¨å—
- æŸ¥è¯¢æ—¶ï¼š
  - å—å†…ç›´æ¥è®¡ç®—
  - å—é—´éœ€è¦è€ƒè™‘è¿æ¥å¤„</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- æ›´æ–°ï¼šO(âˆšn)
- æŸ¥è¯¢ï¼šO(âˆšn)
- æ€»å¤æ‚åº¦ï¼šO(kâˆšn)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h3 id="æ€è·¯ä¸‰å¹³è¡¡æ ‘treapsplayç»´æŠ¤è¿ç»­æ®µ">æ€è·¯ä¸‰ï¼šå¹³è¡¡æ ‘ï¼ˆTreap/Splayï¼‰ç»´æŠ¤è¿ç»­æ®µ</h3>

<p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼š
- å°†å­—ç¬¦ä¸²è§†ä¸ºè‹¥å¹²è¿ç»­ç›¸åŒå­—ç¬¦çš„æ®µ
- ç”¨å¹³è¡¡æ ‘ç»´æŠ¤è¿™äº›æ®µï¼ˆæ¯æ®µè®°å½•å­—ç¬¦ã€é•¿åº¦ã€èµ·å§‹ä½ç½®ï¼‰
- ä¿®æ”¹æ—¶ï¼š
  - æ‰¾åˆ°åŒ…å«è¯¥ä½ç½®çš„æ®µ
  - å¯èƒ½åˆ†è£‚æ®µï¼ˆä¿®æ”¹ç‚¹åœ¨æ®µä¸­é—´ï¼‰
  - æ›´æ–°å­—ç¬¦
  - åˆå¹¶ç›¸é‚»ç›¸åŒå­—ç¬¦çš„æ®µ
- æŸ¥è¯¢æ—¶ï¼šå¹³è¡¡æ ‘ä¸­ç»´æŠ¤çš„æœ€å¤§é•¿åº¦</p>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
- æ¯æ¬¡æ“ä½œï¼šO(log m)ï¼Œm ä¸ºæ®µæ•°
- æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</p>

<p><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</p>

<hr />

<h2 id="ä»£ç å®ç°">ä»£ç å®ç°</h2>

<h3 id="è§£æ³•ä¸€çº¿æ®µæ ‘æœ€ä¼˜è§£">è§£æ³•ä¸€ï¼šçº¿æ®µæ ‘ï¼ˆæœ€ä¼˜è§£ï¼‰</h3>

<pre><code>type Node struct {
    leftChar, rightChar byte
    preLen, sufLen, maxLen, size int
}

type SegmentTree struct {
    n int
    s []byte
    nodes []Node
}

func NewSegmentTree(str string) *SegmentTree {
    n := len(str)
    st := &amp;SegmentTree{
        n: n,
        s: []byte(str),
        nodes: make([]Node, 4*n),
    }
    st.build(1, 0, n-1)
    return st
}

func (st *SegmentTree) build(idx, l, r int) {
    if l == r {
        ch := st.s[l]
        st.nodes[idx] = Node{
            leftChar: ch,
            rightChar: ch,
            preLen: 1,
            sufLen: 1,
            maxLen: 1,
            size: 1,
        }
        return
    }
    mid := (l + r) / 2
    st.build(idx*2, l, mid)
    st.build(idx*2+1, mid+1, r)
    st.pushUp(idx)
}

func (st *SegmentTree) pushUp(idx int) {
    left := &amp;st.nodes[idx*2]
    right := &amp;st.nodes[idx*2+1]
    node := &amp;st.nodes[idx]

    node.leftChar = left.leftChar
    node.rightChar = right.rightChar
    node.size = left.size + right.size

    // å‰ç¼€é•¿åº¦
    node.preLen = left.preLen
    if left.preLen == left.size &amp;&amp; left.rightChar == right.leftChar {
        node.preLen = left.size + right.preLen
    }

    // åç¼€é•¿åº¦
    node.sufLen = right.sufLen
    if right.sufLen == right.size &amp;&amp; left.rightChar == right.leftChar {
        node.sufLen = right.size + left.sufLen
    }

    // æœ€å¤§é•¿åº¦
    node.maxLen = max(left.maxLen, right.maxLen)
    if left.rightChar == right.leftChar {
        node.maxLen = max(node.maxLen, left.sufLen+right.preLen)
    }
}

func (st *SegmentTree) update(pos int, ch byte) {
    st.updateHelper(1, 0, st.n-1, pos, ch)
}

func (st *SegmentTree) updateHelper(idx, l, r, pos int, ch byte) {
    if l == r {
        st.nodes[idx].leftChar = ch
        st.nodes[idx].rightChar = ch
        return
    }
    mid := (l + r) / 2
    if pos &lt;= mid {
        st.updateHelper(idx*2, l, mid, pos, ch)
    } else {
        st.updateHelper(idx*2+1, mid+1, r, pos, ch)
    }
    st.pushUp(idx)
}

func (st *SegmentTree) query() int {
    return st.nodes[1].maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    st := NewSegmentTree(s)
    k := len(queryIndices)
    ans := make([]int, k)

    for i := 0; i &lt; k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            st.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = st.query()
    }
    return ans
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Node {
    char leftChar, rightChar;
    int preLen, sufLen, maxLen, size;
};

class SegmentTree {
private:
    int n;
    string s;
    vector&lt;Node&gt; nodes;

    void build(int idx, int l, int r) {
        if (l == r) {
            char ch = s[l];
            nodes[idx] = {ch, ch, 1, 1, 1, 1};
            return;
        }
        int mid = (l + r) / 2;
        build(idx * 2, l, mid);
        build(idx * 2 + 1, mid + 1, r);
        pushUp(idx);
    }

    void pushUp(int idx) {
        Node&amp; left = nodes[idx * 2];
        Node&amp; right = nodes[idx * 2 + 1];
        Node&amp; node = nodes[idx];

        node.leftChar = left.leftChar;
        node.rightChar = right.rightChar;
        node.size = left.size + right.size;

        // å‰ç¼€é•¿åº¦
        node.preLen = left.preLen;
        if (left.preLen == left.size &amp;&amp; left.rightChar == right.leftChar) {
            node.preLen = left.size + right.preLen;
        }

        // åç¼€é•¿åº¦
        node.sufLen = right.sufLen;
        if (right.sufLen == right.size &amp;&amp; left.rightChar == right.leftChar) {
            node.sufLen = right.size + left.sufLen;
        }

        // æœ€å¤§é•¿åº¦
        node.maxLen = max(left.maxLen, right.maxLen);
        if (left.rightChar == right.leftChar) {
            node.maxLen = max(node.maxLen, left.sufLen + right.preLen);
        }
    }

    void updateHelper(int idx, int l, int r, int pos, char ch) {
        if (l == r) {
            nodes[idx].leftChar = ch;
            nodes[idx].rightChar = ch;
            return;
        }
        int mid = (l + r) / 2;
        if (pos &lt;= mid) {
            updateHelper(idx * 2, l, mid, pos, ch);
        } else {
            updateHelper(idx * 2 + 1, mid + 1, r, pos, ch);
        }
        pushUp(idx);
    }

public:
    SegmentTree(const string&amp; str) : s(str) {
        n = s.length();
        nodes.resize(4 * n);
        build(1, 0, n - 1);
    }

    void update(int pos, char ch) {
        updateHelper(1, 0, n - 1, pos, ch);
    }

    int query() {
        return nodes[1].maxLen;
    }
};

class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {
        SegmentTree st(s);
        int k = queryIndices.size();
        vector&lt;int&gt; ans(k);

        for (int i = 0; i &lt; k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                st.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = st.query();
        }
        return ans;
    }
};
</code></pre>

<hr />

<h3 id="è§£æ³•äºŒåˆ†å—æ³•">è§£æ³•äºŒï¼šåˆ†å—æ³•</h3>

<pre><code>type Block struct {
    start, end int
    chars []byte
    preLen, sufLen, maxLen int
}

func (b *Block) recalc() {
    n := len(b.chars)
    b.preLen = 1
    for i := 1; i &lt; n &amp;&amp; b.chars[i] == b.chars[0]; i++ {
        b.preLen++
    }

    b.sufLen = 1
    for i := n - 2; i &gt;= 0 &amp;&amp; b.chars[i] == b.chars[n-1]; i-- {
        b.sufLen++
    }

    b.maxLen = 1
    cur := 1
    for i := 1; i &lt; n; i++ {
        if b.chars[i] == b.chars[i-1] {
            cur++
            if cur &gt; b.maxLen {
                b.maxLen = cur
            }
        } else {
            cur = 1
        }
    }
}

type BlockArray struct {
    blocks []*Block
    blockSize int
    s []byte
}

func NewBlockArray(s string, blockSize int) *BlockArray {
    n := len(s)
    ba := &amp;BlockArray{
        s: []byte(s),
        blockSize: blockSize,
    }
    for i := 0; i &lt; n; i += blockSize {
        end := min(i+blockSize, n)
        block := &amp;Block{
            start: i,
            end: end,
            chars: []byte(s[i:end]),
        }
        block.recalc()
        ba.blocks = append(ba.blocks, block)
    }
    return ba
}

func (ba *BlockArray) update(pos int, ch byte) {
    ba.s[pos] = ch
    blockIdx := pos / ba.blockSize
    block := ba.blocks[blockIdx]
    localPos := pos % ba.blockSize
    block.chars[localPos] = ch
    block.recalc()
}

func (ba *BlockArray) query() int {
    maxLen := 0
    lastChar := byte(0)
    lastLen := 0

    for _, block := range ba.blocks {
        maxLen = max(maxLen, block.maxLen)

        // å¤„ç†å—é—´è¿æ¥
        if lastChar != 0 &amp;&amp; lastChar == block.chars[0] {
            total := lastLen + block.preLen
            maxLen = max(maxLen, total)
        }

        // æ›´æ–° lastChar å’Œ lastLen
        if block.sufLen == len(block.chars) {
            if lastChar == block.chars[0] {
                lastLen += len(block.chars)
            } else {
                lastLen = block.sufLen
                lastChar = block.chars[0]
            }
        } else {
            lastLen = block.sufLen
            lastChar = block.chars[len(block.chars)-1]
        }
    }
    return maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    n := len(s)
    blockSize := int(math.Sqrt(float64(n))) + 1
    ba := NewBlockArray(s, blockSize)

    k := len(queryIndices)
    ans := make([]int, k)

    for i := 0; i &lt; k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            ba.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = ba.query()
    }
    return ans
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}
</code></pre>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Block {
    int start, end;
    vector&lt;char&gt; chars;
    int preLen, sufLen, maxLen;

    void recalc() {
        int n = chars.size();
        // è®¡ç®—å‰ç¼€é•¿åº¦
        preLen = 1;
        for (int i = 1; i &lt; n &amp;&amp; chars[i] == chars[0]; i++) {
            preLen++;
        }

        // è®¡ç®—åç¼€é•¿åº¦
        sufLen = 1;
        for (int i = n - 2; i &gt;= 0 &amp;&amp; chars[i] == chars[n-1]; i--) {
            sufLen++;
        }

        // è®¡ç®—æœ€å¤§é•¿åº¦
        maxLen = 1;
        int cur = 1;
        for (int i = 1; i &lt; n; i++) {
            if (chars[i] == chars[i-1]) {
                cur++;
                maxLen = max(maxLen, cur);
            } else {
                cur = 1;
            }
        }
    }
};

class BlockArray {
private:
    vector&lt;Block&gt; blocks;
    int blockSize;
    string s;

public:
    BlockArray(const string&amp; str, int bs) : s(str), blockSize(bs) {
        int n = s.length();
        for (int i = 0; i &lt; n; i += blockSize) {
            int end = min(i + blockSize, n);
            Block block;
            block.start = i;
            block.end = end;
            for (int j = i; j &lt; end; j++) {
                block.chars.push_back(s[j]);
            }
            block.recalc();
            blocks.push_back(block);
        }
    }

    void update(int pos, char ch) {
        s[pos] = ch;
        int blockIdx = pos / blockSize;
        int localPos = pos % blockSize;
        blocks[blockIdx].chars[localPos] = ch;
        blocks[blockIdx].recalc();
    }

    int query() {
        int maxLen = 0;
        char lastChar = 0;
        int lastLen = 0;

        for (auto&amp; block : blocks) {
            maxLen = max(maxLen, block.maxLen);

            // å¤„ç†å—é—´è¿æ¥
            if (lastChar != 0 &amp;&amp; lastChar == block.chars[0]) {
                int total = lastLen + block.preLen;
                maxLen = max(maxLen, total);
            }

            // æ›´æ–° lastChar å’Œ lastLen
            if (block.sufLen == (int)block.chars.size()) {
                if (lastChar == block.chars[0]) {
                    lastLen += block.chars.size();
                } else {
                    lastLen = block.sufLen;
                    lastChar = block.chars[0];
                }
            } else {
                lastLen = block.sufLen;
                lastChar = block.chars.back();
            }
        }
        return maxLen;
    }
};

class Solution {
public:
    vector&lt;int&gt; longestRepeating(string s, string queryCharacters, vector&lt;int&gt;&amp; queryIndices) {
        int n = s.length();
        int blockSize = sqrt(n) + 1;
        BlockArray ba(s, blockSize);

        int k = queryIndices.size();
        vector&lt;int&gt; ans(k);

        for (int i = 0; i &lt; k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                ba.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = ba.query();
        }
        return ans;
    }
};
</code></pre>

<hr />

<h2 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h2>

<h3 id="è§£æ³•ä¸€çº¿æ®µæ ‘">è§£æ³•ä¸€ï¼šçº¿æ®µæ ‘</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
<ul>
<li>å»ºæ ‘ï¼šO(n)</li>
<li>æ¯æ¬¡æ›´æ–°ï¼šO(log n)</li>
<li>æ€»å¤æ‚åº¦ï¼šO((n + k) log n)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</li>
</ul>

<h3 id="è§£æ³•äºŒåˆ†å—æ³•-2">è§£æ³•äºŒï¼šåˆ†å—æ³•</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼š
<ul>
<li>åˆå§‹åŒ–ï¼šO(n)</li>
<li>æ¯æ¬¡æ›´æ–°ï¼šO(âˆšn)ï¼ˆæ›´æ–°ä¸€ä¸ªå—ï¼‰</li>
<li>æ¯æ¬¡æŸ¥è¯¢ï¼šO(âˆšn)ï¼ˆéå†æ‰€æœ‰å—ï¼‰</li>
<li>æ€»å¤æ‚åº¦ï¼šO(kâˆšn)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(n)</li>
</ul>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<p>| ç‰¹æ€§</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 17:50:30</em></p>

<hr />

<h1 id="2525-æ ¹æ®è§„åˆ™å°†ç®±å­åˆ†ç±»">2525. æ ¹æ®è§„åˆ™å°†ç®±å­åˆ†ç±»</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°å­¦</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/categorize-box-according-to-criteria/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-3">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ å››ä¸ªæ•´æ•°&nbsp;<code>length</code>&nbsp;ï¼Œ<code>width</code>&nbsp;ï¼Œ<code>height</code>&nbsp;å’Œ&nbsp;<code>mass</code>&nbsp;ï¼Œåˆ†åˆ«è¡¨ç¤ºä¸€ä¸ªç®±å­çš„ä¸‰ä¸ªç»´åº¦å’Œè´¨é‡ï¼Œè¯·ä½ è¿”å›ä¸€ä¸ªè¡¨ç¤ºç®±å­ <strong>ç±»åˆ«</strong> çš„å­—ç¬¦ä¸²ã€‚</p>

<ul>
    <li>å¦‚æœæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œé‚£ä¹ˆç®±å­æ˜¯&nbsp;<code>"Bulky"</code>&nbsp;çš„ï¼š

    <ul>
        <li>ç®±å­ <strong>è‡³å°‘æœ‰ä¸€ä¸ª</strong> ç»´åº¦å¤§äºç­‰äº <code>10<sup>4</sup></code>&nbsp;ã€‚</li>
        <li>æˆ–è€…ç®±å­çš„ <strong>ä½“ç§¯</strong> å¤§äºç­‰äº&nbsp;<code>10<sup>9</sup></code>&nbsp;ã€‚</li>
    </ul>

<pre><code>&lt;/li&gt;
&lt;li&gt;å¦‚æœç®±å­çš„è´¨é‡å¤§äºç­‰äº&amp;nbsp;&lt;code&gt;100&lt;/code&gt;&amp;nbsp;ï¼Œé‚£ä¹ˆç®±å­æ˜¯&amp;nbsp;&lt;code&gt;"Heavy"&lt;/code&gt;&amp;nbsp;çš„ã€‚&lt;/li&gt;
&lt;li&gt;å¦‚æœç®±å­åŒæ—¶æ˜¯&amp;nbsp;&lt;code&gt;"Bulky"&lt;/code&gt; å’Œ&amp;nbsp;&lt;code&gt;"Heavy"&lt;/code&gt;&amp;nbsp;ï¼Œé‚£ä¹ˆè¿”å›ç±»åˆ«ä¸º&amp;nbsp;&lt;code&gt;"Both"&lt;/code&gt;&amp;nbsp;ã€‚&lt;/li&gt;
&lt;li&gt;å¦‚æœç®±å­æ—¢ä¸æ˜¯&amp;nbsp;&lt;code&gt;"Bulky"&lt;/code&gt;&amp;nbsp;ï¼Œä¹Ÿä¸æ˜¯&amp;nbsp;&lt;code&gt;"Heavy"&lt;/code&gt;&amp;nbsp;ï¼Œé‚£ä¹ˆè¿”å›ç±»åˆ«ä¸º&amp;nbsp;&lt;code&gt;"Neither"&lt;/code&gt;&amp;nbsp;ã€‚&lt;/li&gt;
&lt;li&gt;å¦‚æœç®±å­æ˜¯&amp;nbsp;&lt;code&gt;"Bulky"&lt;/code&gt;&amp;nbsp;ä½†ä¸æ˜¯&amp;nbsp;&lt;code&gt;"Heavy"&lt;/code&gt;&amp;nbsp;ï¼Œé‚£ä¹ˆè¿”å›ç±»åˆ«ä¸º&amp;nbsp;&lt;code&gt;"Bulky"&lt;/code&gt;&amp;nbsp;ã€‚&lt;/li&gt;
&lt;li&gt;å¦‚æœç®±å­æ˜¯&amp;nbsp;&lt;code&gt;"Heavy"&lt;/code&gt;&amp;nbsp;ä½†ä¸æ˜¯&amp;nbsp;&lt;code&gt;"Bulky"&lt;/code&gt;&amp;nbsp;ï¼Œé‚£ä¹ˆè¿”å›ç±»åˆ«ä¸º&amp;nbsp;&lt;code&gt;"Heavy"&lt;/code&gt;&amp;nbsp;ã€‚&lt;/li&gt;
</code></pre>

<p></ul></p>

<p><strong>æ³¨æ„</strong>ï¼Œç®±å­çš„ä½“ç§¯ç­‰äºç®±å­çš„é•¿åº¦ã€å®½åº¦å’Œé«˜åº¦çš„ä¹˜ç§¯ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>length = 1000, width = 35, height = 700, mass = 300
<b>è¾“å‡ºï¼š</b>"Heavy"
<b>è§£é‡Šï¼š</b>
ç®±å­æ²¡æœ‰ä»»ä½•ç»´åº¦å¤§äºç­‰äº 10<sup>4 </sup>ã€‚
ä½“ç§¯ä¸º 24500000 &lt;= 10<sup>9 </sup>ã€‚æ‰€ä»¥ä¸èƒ½å½’ç±»ä¸º "Bulky" ã€‚
ä½†æ˜¯è´¨é‡ &gt;= 100 ï¼Œæ‰€ä»¥ç®±å­æ˜¯ "Heavy" çš„ã€‚
ç”±äºç®±å­ä¸æ˜¯ "Bulky" ä½†æ˜¯æ˜¯ "Heavy" ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› "Heavy" ã€‚</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<b>è¾“å…¥ï¼š</b>length = 200, width = 50, height = 800, mass = 50
<b>è¾“å‡ºï¼š</b>"Neither"
<b>è§£é‡Šï¼š</b>
ç®±å­æ²¡æœ‰ä»»ä½•ç»´åº¦å¤§äºç­‰äº 10<sup>4</sup>&nbsp;ã€‚
ä½“ç§¯ä¸º 8 * 10<sup>6</sup> &lt;= 10<sup>9</sup>&nbsp;ã€‚æ‰€ä»¥ä¸èƒ½å½’ç±»ä¸º "Bulky" ã€‚
è´¨é‡å°äº 100 ï¼Œæ‰€ä»¥ä¸èƒ½å½’ç±»ä¸º "Heavy" ã€‚
ç”±äºä¸å±äºä¸Šè¿°ä¸¤è€…ä»»ä½•ä¸€ç±»ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› "Neither" ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= length, width, height &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= mass &lt;= 10<sup>3</sup></code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-3">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-3">C++</h3>

<pre><code>class Solution {
public:
    string categorizeBox(int length, int width, int height, int mass) {

    }
};
</code></pre>

<h3 id="java-3">Java</h3>

<pre><code>class Solution {
    public String categorizeBox(int length, int width, int height, int mass) {

    }
}
</code></pre>

<h3 id="python3-3">Python3</h3>

<pre><code>class Solution:
    def categorizeBox(self, length: int, width: int, height: int, mass: int) -&gt; str:

</code></pre>

<h3 id="javascript-3">JavaScript</h3>

<pre><code>/**
 * @param {number} length
 * @param {number} width
 * @param {number} height
 * @param {number} mass
 * @return {string}
 */
var categorizeBox = function(length, width, height, mass) {

};
</code></pre>

<h3 id="go-3">Go</h3>

<pre><code>func categorizeBox(length int, width int, height int, mass int) string {

}
</code></pre>

<hr />

<h2 id="æç¤º-3">æç¤º</h2>

<ol>
<li>Use conditional statements to find the right category of the box.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-3">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>1000
35
700
300
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-3">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-3">é¢˜ç›®åˆ†æ</h2>

<p>é¢˜ç›®è¦æ±‚æ ¹æ®ç®±å­çš„å°ºå¯¸ï¼ˆé•¿ã€å®½ã€é«˜ï¼‰å’Œè´¨é‡ï¼ˆmassï¼‰å°†å…¶åˆ†ç±»ä¸ºä»¥ä¸‹å››ç§æƒ…å†µä¹‹ä¸€ï¼š
1. <strong>Both</strong>ï¼šç®±å­æ—¢æ˜¯"Bulky"åˆæ˜¯"Heavy"
2. <strong>Bulky</strong>ï¼šç®±å­æ˜¯"Bulky"ä½†ä¸æ˜¯"Heavy"
3. <strong>Heavy</strong>ï¼šç®±å­æ˜¯"Heavy"ä½†ä¸æ˜¯"Bulky"
4. <strong>Neither</strong>ï¼šç®±å­æ—¢ä¸æ˜¯"Bulky"ä¹Ÿä¸æ˜¯"Heavy"</p>

<p><strong>åˆ¤æ–­æ¡ä»¶</strong>ï¼š
- <strong>Bulky</strong>ï¼šè‡³å°‘æœ‰ä¸€ä¸ªç»´åº¦ â‰¥ 10â´ <strong>æˆ–è€…</strong> ä½“ç§¯ â‰¥ 10â¹
- <strong>Heavy</strong>ï¼šè´¨é‡ â‰¥ 100</p>

<p><strong>æ³¨æ„</strong>ï¼š
- ä½“ç§¯ = length Ã— width Ã— height
- ç»´åº¦æ¯”è¾ƒæ—¶ï¼Œæ¯ä¸ªç»´åº¦å•ç‹¬ä¸ 10â´ æ¯”è¾ƒ
- ä½“ç§¯å¯èƒ½å¾ˆå¤§ï¼ˆæœ€å¤§ 10Â¹âµï¼‰ï¼Œéœ€è¦æ³¨æ„æ•´æ•°æº¢å‡ºé—®é¢˜</p>

<hr />

<h2 id="è§£æ³•ä¸€ç›´æ¥åˆ¤æ–­æ³•æ¨è">è§£æ³•ä¸€ï¼šç›´æ¥åˆ¤æ–­æ³•ï¼ˆæ¨èï¼‰</h2>

<h3 id="è§£é¢˜æ€è·¯-3">è§£é¢˜æ€è·¯</h3>

<p>ç›´æ¥æŒ‰ç…§é¢˜ç›®æè¿°çš„æ¡ä»¶è¿›è¡Œåˆ¤æ–­ï¼š
1. åˆ¤æ–­æ˜¯å¦ä¸º Bulkyï¼š
   - æ£€æŸ¥ lengthã€widthã€height æ˜¯å¦ â‰¥ 10â´
   - è®¡ç®—ä½“ç§¯å¹¶æ£€æŸ¥æ˜¯å¦ â‰¥ 10â¹
2. åˆ¤æ–­æ˜¯å¦ä¸º Heavyï¼š
   - æ£€æŸ¥ mass æ˜¯å¦ â‰¥ 100
3. æ ¹æ®ä¸¤ä¸ªå¸ƒå°”å€¼çš„ç»„åˆè¿”å›å¯¹åº”å­—ç¬¦ä¸²</p>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>func categorizeBox(length int, width int, height int, mass int) string {
    bulky := false
    heavy := mass &gt;= 100

    // æ£€æŸ¥ç»´åº¦
    if length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000 {
        bulky = true
    }

    // æ£€æŸ¥ä½“ç§¯ï¼ˆæ³¨æ„ç±»å‹è½¬æ¢é¿å…æº¢å‡ºï¼‰
    volume := int64(length) * int64(width) * int64(height)
    if volume &gt;= 1000000000 {
        bulky = true
    }

    // åˆ†ç±»
    if bulky &amp;&amp; heavy {
        return "Both"
    } else if bulky &amp;&amp; !heavy {
        return "Bulky"
    } else if !bulky &amp;&amp; heavy {
        return "Heavy"
    } else {
        return "Neither"
    }
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    string categorizeBox(int length, int width, int height, int mass) {
        bool bulky = false;
        bool heavy = mass &gt;= 100;

        // æ£€æŸ¥ç»´åº¦
        if (length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000) {
            bulky = true;
        }

        // æ£€æŸ¥ä½“ç§¯ï¼ˆä½¿ç”¨ long long é¿å…æº¢å‡ºï¼‰
        long long volume = (long long)length * width * height;
        if (volume &gt;= 1000000000) {
            bulky = true;
        }

        // åˆ†ç±»
        if (bulky &amp;&amp; heavy) return "Both";
        if (bulky &amp;&amp; !heavy) return "Bulky";
        if (!bulky &amp;&amp; heavy) return "Heavy";
        return "Neither";
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-2">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼Œåªæœ‰å¸¸æ•°æ¬¡æ¯”è¾ƒå’Œä¹˜æ³•è¿ç®—</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å‡ ä¸ªå˜é‡</li>
</ul>

<hr />

<h2 id="è§£æ³•äºŒä½è¿ç®—æ ‡è®°æ³•">è§£æ³•äºŒï¼šä½è¿ç®—æ ‡è®°æ³•</h2>

<h3 id="è§£é¢˜æ€è·¯-4">è§£é¢˜æ€è·¯</h3>

<p>ä½¿ç”¨ä¸¤ä¸ªäºŒè¿›åˆ¶ä½æ¥æ ‡è®°çŠ¶æ€ï¼š
- ç¬¬ 0 ä½ï¼šæ˜¯å¦ä¸º Bulky
- ç¬¬ 1 ä½ï¼šæ˜¯å¦ä¸º Heavy
ç„¶åé€šè¿‡çŠ¶æ€å€¼ç›´æ¥æ˜ å°„åˆ°ç»“æœ</p>

<h3 id="ä»£ç å®ç°-3">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-2">Go å®ç°</h4>

<pre><code>func categorizeBox(length int, width int, height int, mass int) string {
    status := 0

    // è®¾ç½® Heavy ä½
    if mass &gt;= 100 {
        status |= 2  // äºŒè¿›åˆ¶ 10
    }

    // è®¾ç½® Bulky ä½
    if length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000 {
        status |= 1  // äºŒè¿›åˆ¶ 01
    } else {
        volume := int64(length) * int64(width) * int64(height)
        if volume &gt;= 1000000000 {
            status |= 1
        }
    }

    // æ˜ å°„ç»“æœ
    switch status {
    case 0: return "Neither"
    case 1: return "Bulky"
    case 2: return "Heavy"
    case 3: return "Both"
    }
    return "" // ä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œ
}
</code></pre>

<h4 id="c-å®ç°-2">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    string categorizeBox(int length, int width, int height, int mass) {
        int status = 0;

        // è®¾ç½® Heavy ä½
        if (mass &gt;= 100) {
            status |= 2;  // äºŒè¿›åˆ¶ 10
        }

        // è®¾ç½® Bulky ä½
        if (length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000) {
            status |= 1;  // äºŒè¿›åˆ¶ 01
        } else {
            long long volume = (long long)length * width * height;
            if (volume &gt;= 1000000000) {
                status |= 1;
            }
        }

        // æ˜ å°„ç»“æœ
        switch (status) {
            case 0: return "Neither";
            case 1: return "Bulky";
            case 2: return "Heavy";
            case 3: return "Both";
        }
        return "";
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-3">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)</li>
</ul>

<hr />

<h2 id="è§£æ³•ä¸‰æå‰è®¡ç®—ä½“ç§¯ä¼˜åŒ–ç‰ˆ">è§£æ³•ä¸‰ï¼šæå‰è®¡ç®—ä½“ç§¯ï¼ˆä¼˜åŒ–ç‰ˆï¼‰</h2>

<h3 id="è§£é¢˜æ€è·¯-5">è§£é¢˜æ€è·¯</h3>

<p>å…ˆè®¡ç®—ä½“ç§¯ï¼Œç„¶åä¸€æ¬¡æ€§åˆ¤æ–­æ‰€æœ‰ Bulky æ¡ä»¶ï¼Œå‡å°‘æ¡ä»¶åˆ¤æ–­æ¬¡æ•°</p>

<h3 id="ä»£ç å®ç°-4">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-3">Go å®ç°</h4>

<pre><code>func categorizeBox(length int, width int, height int, mass int) string {
    // æå‰è®¡ç®—ä½“ç§¯
    volume := int64(length) * int64(width) * int64(height)

    // åˆ¤æ–­ Bulky
    bulky := length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000 || volume &gt;= 1000000000

    // åˆ¤æ–­ Heavy
    heavy := mass &gt;= 100

    // ä½¿ç”¨äºŒç»´æ•°ç»„æ˜ å°„ç»“æœ
    results := [2][2]string{
        {"Neither", "Bulky"},
        {"Heavy", "Both"},
    }

    bulkyIdx := 0
    if bulky {
        bulkyIdx = 1
    }

    heavyIdx := 0
    if heavy {
        heavyIdx = 1
    }

    return results[heavyIdx][bulkyIdx]
}
</code></pre>

<h4 id="c-å®ç°-3">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    string categorizeBox(int length, int width, int height, int mass) {
        // æå‰è®¡ç®—ä½“ç§¯
        long long volume = (long long)length * width * height;

        // åˆ¤æ–­ Bulky
        bool bulky = (length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000 || volume &gt;= 1000000000);

        // åˆ¤æ–­ Heavy
        bool heavy = mass &gt;= 100;

        // ä½¿ç”¨äºŒç»´æ•°ç»„æ˜ å°„ç»“æœ
        string results[2][2] = {
            {"Neither", "Bulky"},
            {"Heavy", "Both"}
        };

        return results[heavy][bulky];
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-4">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(1)</li>
</ul>

<hr />

<h2 id="ä¸åŒè§£æ³•å¯¹æ¯”">ä¸åŒè§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
  <th>é€‚ç”¨åœºæ™¯</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>è§£æ³•ä¸€ï¼šç›´æ¥åˆ¤æ–­æ³•</strong></td>
  <td>é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤</td>
  <td>æœ‰å¤šä¸ªæ¡ä»¶åˆ¤æ–­åˆ†æ”¯</td>
  <td>é€šç”¨åœºæ™¯ï¼Œæ¨èä½¿ç”¨</td>
</tr>
<tr>
  <td><strong>è§£æ³•äºŒï¼šä½è¿ç®—æ ‡è®°æ³•</strong></td>
  <td>ä»£ç ç®€æ´ï¼ŒçŠ¶æ€æ˜ å°„é«˜æ•ˆ</td>
  <td>å¯è¯»æ€§ç¨å·®</td>
  <td>å¯¹æ€§èƒ½æœ‰æè‡´è¦æ±‚çš„åœºæ™¯</td>
</tr>
<tr>
  <td><strong>è§£æ³•ä¸‰ï¼šæå‰è®¡ç®—ä½“ç§¯</strong></td>
  <td>å‡å°‘æ¡ä»¶åˆ¤æ–­æ¬¡æ•°</td>
  <td>å¯èƒ½æå‰è®¡ç®—ä¸å¿…è¦çš„ä½“ç§¯</td>
  <td>ç»´åº¦ç»å¸¸æ»¡è¶³æ¡ä»¶çš„æƒ…å†µ</td>
</tr>
</tbody>
</table>

<h3 id="æ¨è">æ¨è</h3>

<p>å¯¹äº LeetCode é¢˜ç›®ï¼Œ<strong>è§£æ³•ä¸€ï¼ˆç›´æ¥åˆ¤æ–­æ³•ï¼‰</strong> æ˜¯æœ€ä½³é€‰æ‹©ï¼Œå› ä¸ºï¼š
1. é€»è¾‘æœ€æ¸…æ™°ï¼Œç¬¦åˆé¢˜ç›®æè¿°
2. æ˜“äºç†è§£å’Œç»´æŠ¤
3. æ€§èƒ½å·²ç»è¶³å¤Ÿï¼ˆO(1) æ—¶é—´å¤æ‚åº¦ï¼‰
4. é¿å…äº†ä¸å¿…è¦çš„ä¼˜åŒ–å¸¦æ¥çš„å¤æ‚æ€§</p>

<h3 id="æ³¨æ„äº‹é¡¹">æ³¨æ„äº‹é¡¹</h3>

<ol>
<li><strong>æ•´æ•°æº¢å‡ºé—®é¢˜</strong>ï¼šè®¡ç®—ä½“ç§¯æ—¶ï¼Œä¸‰ä¸ª int ç›¸ä¹˜å¯èƒ½æº¢å‡ºï¼Œéœ€è¦è½¬æ¢ä¸º long longï¼ˆC++ï¼‰æˆ– int64ï¼ˆGoï¼‰</li>
<li><strong>è¾¹ç•Œæ¡ä»¶</strong>ï¼šæ³¨æ„ â‰¥ å’Œ &gt; çš„åŒºåˆ«ï¼Œé¢˜ç›®ä½¿ç”¨çš„æ˜¯ â‰¥</li>
<li><strong>æ¡ä»¶é¡ºåº</strong>ï¼šBulky çš„ä¸¤ä¸ªæ¡ä»¶æ˜¯"æˆ–"å…³ç³»ï¼Œåªè¦æ»¡è¶³ä¸€ä¸ªå°±æ˜¯ Bulky</li>
</ol>

<h3 id="æ‰©å±•æ€è€ƒ">æ‰©å±•æ€è€ƒ</h3>

<p>å¦‚æœç»´åº¦æ•°é‡å¢åŠ åˆ° n ä¸ªï¼Œå¯ä»¥ä½¿ç”¨å¾ªç¯æ£€æŸ¥æ¯ä¸ªç»´åº¦æ˜¯å¦ â‰¥ 10â´ï¼Œä½†æ ¸å¿ƒé€»è¾‘ä¸å˜ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 15:48:56</em></p>

<hr />

<h1 id="3106-æ»¡è¶³è·ç¦»çº¦æŸä¸”å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²">3106. æ»¡è¶³è·ç¦»çº¦æŸä¸”å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: è´ªå¿ƒ, å­—ç¬¦ä¸²</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/lexicographically-smallest-string-after-operations-with-constraint/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-4">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² <code>s</code> å’Œä¸€ä¸ªæ•´æ•° <code>k</code> ã€‚</p>

<p>å®šä¹‰å‡½æ•° <code>distance(s<sub>1</sub>, s<sub>2</sub>)</code> ï¼Œç”¨äºè¡¡é‡ä¸¤ä¸ªé•¿åº¦ä¸º <code>n</code> çš„å­—ç¬¦ä¸² <code>s<sub>1</sub></code> å’Œ <code>s<sub>2</sub></code> ä¹‹é—´çš„è·ç¦»ï¼Œå³ï¼š</p>

<ul>
    <li>å­—ç¬¦ <code>'a'</code> åˆ° <code>'z'</code> æŒ‰ <strong>å¾ªç¯ </strong>é¡ºåºæ’åˆ—ï¼Œå¯¹äºåŒºé—´ <code>[0, n - 1]</code> ä¸­çš„ <code>i</code> ï¼Œè®¡ç®—æ‰€æœ‰ã€Œ <code>s<sub>1</sub>[i]</code> å’Œ <code>s<sub>2</sub>[i]</code> ä¹‹é—´<strong> æœ€å°è·ç¦»</strong>ã€çš„ <strong>å’Œ </strong>ã€‚</li>
</ul>

<p>ä¾‹å¦‚ï¼Œ<code>distance("ab", "cd") == 4</code> ï¼Œä¸” <code>distance("a", "z") == 1</code> ã€‚</p>

<p>ä½ å¯ä»¥å¯¹å­—ç¬¦ä¸² <code>s</code> æ‰§è¡Œ<strong> ä»»æ„æ¬¡ </strong>æ“ä½œã€‚åœ¨æ¯æ¬¡æ“ä½œä¸­ï¼Œå¯ä»¥å°† <code>s</code> ä¸­çš„ä¸€ä¸ªå­—æ¯ <strong>æ”¹å˜ </strong>ä¸º<strong> ä»»æ„ </strong>å…¶ä»–å°å†™è‹±æ–‡å­—æ¯ã€‚</p>

<p>è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºåœ¨æ‰§è¡Œä¸€äº›æ“ä½œåä½ å¯ä»¥å¾—åˆ°çš„ <strong>å­—å…¸åºæœ€å°</strong> çš„å­—ç¬¦ä¸² <code>t</code> ï¼Œä¸”æ»¡è¶³ <code>distance(s, t) &lt;= k</code> ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "zbbz", k = 3
<strong>è¾“å‡ºï¼š</strong>"aaaz"
<strong>è§£é‡Šï¼š</strong>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¯ä»¥æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
å°† s[0] æ”¹ä¸º 'a' ï¼Œs å˜ä¸º "abbz" ã€‚
å°† s[1] æ”¹ä¸º 'a' ï¼Œs å˜ä¸º "aabz" ã€‚
å°† s[2] æ”¹ä¸º 'a' ï¼Œs å˜ä¸º "aaaz" ã€‚
"zbbz" å’Œ "aaaz" ä¹‹é—´çš„è·ç¦»ç­‰äº k = 3 ã€‚
å¯ä»¥è¯æ˜ "aaaz" æ˜¯åœ¨ä»»æ„æ¬¡æ“ä½œåèƒ½å¤Ÿå¾—åˆ°çš„å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²ã€‚
å› æ­¤ï¼Œç­”æ¡ˆæ˜¯ "aaaz" ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "xaxcd", k = 4
<strong>è¾“å‡ºï¼š</strong>"aawcd"
<strong>è§£é‡Šï¼š</strong>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¯ä»¥æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
å°† s[0] æ”¹ä¸º 'a' ï¼Œs å˜ä¸º "aaxcd" ã€‚
å°† s[2] æ”¹ä¸º 'w' ï¼Œs å˜ä¸º "aawcd" ã€‚
"xaxcd" å’Œ "aawcd" ä¹‹é—´çš„è·ç¦»ç­‰äº k = 4 ã€‚
å¯ä»¥è¯æ˜ "aawcd" æ˜¯åœ¨ä»»æ„æ¬¡æ“ä½œåèƒ½å¤Ÿå¾—åˆ°çš„å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²ã€‚
å› æ­¤ï¼Œç­”æ¡ˆæ˜¯ "aawcd" ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>s = "lol", k = 0
<strong>è¾“å‡ºï¼š</strong>"lol"
<strong>è§£é‡Šï¼š</strong>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œk = 0ï¼Œæ›´æ”¹ä»»ä½•å­—ç¬¦éƒ½ä¼šä½¿å¾—è·ç¦»å¤§äº 0 ã€‚
å› æ­¤ï¼Œç­”æ¡ˆæ˜¯ "lol" ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 100</code></li>
    <li><code>0 &lt;= k &lt;= 2000</code></li>
    <li><code>s</code> åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-4">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-4">C++</h3>

<pre><code>class Solution {
public:
    string getSmallestString(string s, int k) {

    }
};
</code></pre>

<h3 id="java-4">Java</h3>

<pre><code>class Solution {
    public String getSmallestString(String s, int k) {

    }
}
</code></pre>

<h3 id="python3-4">Python3</h3>

<pre><code>class Solution:
    def getSmallestString(self, s: str, k: int) -&gt; str:

</code></pre>

<h3 id="javascript-4">JavaScript</h3>

<pre><code>/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var getSmallestString = function(s, k) {

};
</code></pre>

<h3 id="go-4">Go</h3>

<pre><code>func getSmallestString(s string, k int) string {

}
</code></pre>

<hr />

<h2 id="æç¤º-4">æç¤º</h2>

<ol>
<li>The problem can be approached greedily.</li>
<li>For each index in order from <code>0</code> to <code>n - 1</code>, we try all letters from <code>'a'</code> to <code>'z'</code>, selecting the first one as long as the current total distance accumulated is not larger than <code>k</code>.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-4">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>"zbbz"
3
</code></pre>

<hr />

<h2 id="ai-è§£ç­”">AI è§£ç­”</h2>

<p><em>DeepSeek API æœªé…ç½®æˆ–è°ƒç”¨å¤±è´¥</em></p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 15:43:52</em></p>

        </div>
    </div>
</body>
</html>