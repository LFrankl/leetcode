<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unknown. æœªçŸ¥é¢˜ç›® - LeetCode</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="top-bar">
        <button class="menu-button" onclick="history.back()" aria-label="è¿”å›">
            <div class="menu-icon">
                <span style="transform: rotate(-45deg) translateY(-2px);"></span>
                <span style="transform: rotate(45deg) translateY(2px);"></span>
            </div>
        </button>
        <div class="logo">
            <span class="logo-emoji">ğŸ“š</span>
            LeetCode æ¯æ—¥é¢˜ç›®
        </div>
        <div class="update-time">2026-02-26 06:00:00</div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content" style="margin-left: 0;">
        <div class="content-wrapper">
            <button class="back-button" onclick="history.back()">
                â† è¿”å›é¢˜ç›®åˆ—è¡¨
            </button>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-number">Unknown. æœªçŸ¥é¢˜ç›®</span>
                    <span class="difficulty-badge difficulty-medium">
                        ä¸­ç­‰
                    </span>
                    <a href="https://leetcode.cn/problems/OrIXps/" target="_blank" class="question-link">åœ¨ LeetCode æ‰“å¼€</a>
                </div>
                <div class="markdown-content">
                    <h1 id="lcr-031-lru-ç¼“å­˜">LCR 031. LRU ç¼“å­˜</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: è®¾è®¡, å“ˆå¸Œè¡¨, é“¾è¡¨, åŒå‘é“¾è¡¨</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/OrIXps/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<div class="title__3Vvk">
<p>è¿ç”¨æ‰€æŒæ¡çš„æ•°æ®ç»“æ„ï¼Œè®¾è®¡å’Œå®ç°ä¸€ä¸ª&nbsp; <a href="https://baike.baidu.com/item/LRU" target="_blank">LRU (Least Recently Usedï¼Œæœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜æœºåˆ¶</a> ã€‚</p>

<p>å®ç° <code>LRUCache</code> ç±»ï¼š</p>

<ul>
    <li><code>LRUCache(int capacity)</code> ä»¥æ­£æ•´æ•°ä½œä¸ºå®¹é‡&nbsp;<code>capacity</code> åˆå§‹åŒ– LRU ç¼“å­˜</li>
    <li><code>int get(int key)</code> å¦‚æœå…³é”®å­— <code>key</code> å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› <code>-1</code> ã€‚</li>
    <li><code>void put(int key, int value)</code>&nbsp;å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ï¼›å¦‚æœå…³é”®å­—ä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥è¯¥ç»„ã€Œå…³é”®å­—-å€¼ã€ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ã€‚</li>
</ul>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ï¼š</strong></p>

<pre>
<strong>è¾“å…¥</strong>
[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>è¾“å‡º</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>è§£é‡Š</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // ç¼“å­˜æ˜¯ {1=1}
lRUCache.put(2, 2); // ç¼“å­˜æ˜¯ {1=1, 2=2}
lRUCache.get(1);    // è¿”å› 1
lRUCache.put(3, 3); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {1=1, 3=3}
lRUCache.get(2);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.put(4, 4); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {4=4, 3=3}
lRUCache.get(1);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.get(3);    // è¿”å› 3
lRUCache.get(4);    // è¿”å› 4
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= capacity &lt;= 3000</code></li>
    <li><code>0 &lt;= key &lt;= 10000</code></li>
    <li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
    <li>æœ€å¤šè°ƒç”¨ <code>2 * 10<sup>5</sup></code> æ¬¡ <code>get</code> å’Œ <code>put</code></li>
</ul>
</div>

<p>&nbsp;</p>

<p><strong>è¿›é˜¶</strong>ï¼šæ˜¯å¦å¯ä»¥åœ¨&nbsp;<code>O(1)</code> æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸¤ç§æ“ä½œï¼Ÿ</p>

<p>&nbsp;</p>

<p><meta charset="UTF-8" />æ³¨æ„ï¼šæœ¬é¢˜ä¸ä¸»ç«™ 146&nbsp;é¢˜ç›¸åŒï¼š<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a>&nbsp;</p>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class LRUCache {
public:
    LRUCache(int capacity) {

    }

    int get(int key) {

    }

    void put(int key, int value) {

    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class LRUCache {

    public LRUCache(int capacity) {

    }

    public int get(int key) {

    }

    public void put(int key, int value) {

    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class LRUCache:

    def __init__(self, capacity: int):


    def get(self, key: int) -&gt; int:


    def put(self, key: int, value: int) -&gt; None:



# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {

};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {

};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {

};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
</code></pre>

<h3 id="go">Go</h3>

<pre><code>type LRUCache struct {

}


func Constructor(capacity int) LRUCache {

}


func (this *LRUCache) Get(key int) int {

}


func (this *LRUCache) Put(key int, value int)  {

}


/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
</code></pre>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>["LRUCache","put","put","get","put","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>LRUï¼ˆLeast Recently Usedï¼‰ç¼“å­˜æ˜¯ä¸€ç§å¸¸è§çš„ç¼“å­˜æ·˜æ±°ç­–ç•¥ï¼Œè¦æ±‚ï¼š
1. <strong>å¿«é€ŸæŸ¥æ‰¾</strong>ï¼šé€šè¿‡ key å¿«é€Ÿæ‰¾åˆ°å¯¹åº”çš„ value
2. <strong>å¿«é€Ÿæ’å…¥/åˆ é™¤</strong>ï¼šæ’å…¥æ–°æ•°æ®æˆ–åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®
3. <strong>ç»´æŠ¤è®¿é—®é¡ºåº</strong>ï¼šéœ€è¦çŸ¥é“å“ªä¸ªæ•°æ®æ˜¯æœ€è¿‘ä½¿ç”¨çš„ï¼Œå“ªä¸ªæ˜¯æœ€ä¹…æœªä½¿ç”¨çš„</p>

<p><strong>æ ¸å¿ƒéœ€æ±‚</strong>ï¼š
- <code>get(key)</code>ï¼šå¦‚æœ key å­˜åœ¨ï¼Œè¿”å› valueï¼Œå¹¶å°†è¯¥ key æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨
- <code>put(key, value)</code>ï¼š
  - å¦‚æœ key å­˜åœ¨ï¼Œæ›´æ–° valueï¼Œå¹¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨
  - å¦‚æœ key ä¸å­˜åœ¨ï¼Œæ’å…¥æ–°æ•°æ®
    - å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®
    - æ’å…¥æ–°æ•°æ®å¹¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨</p>

<p><strong>æ—¶é—´å¤æ‚åº¦è¦æ±‚</strong>ï¼šO(1) å®Œæˆ get å’Œ put æ“ä½œ</p>

<hr />

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="å…³é”®æ•°æ®ç»“æ„é€‰æ‹©">å…³é”®æ•°æ®ç»“æ„é€‰æ‹©</h3>

<ol>
<li><strong>å“ˆå¸Œè¡¨</strong>ï¼šæä¾› O(1) çš„æŸ¥æ‰¾èƒ½åŠ›</li>
<li><strong>åŒå‘é“¾è¡¨</strong>ï¼šç»´æŠ¤è®¿é—®é¡ºåºï¼Œå¤´éƒ¨æ˜¯æœ€è¿‘ä½¿ç”¨çš„ï¼Œå°¾éƒ¨æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„
<ul>
<li>åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥æ–°èŠ‚ç‚¹æˆ–ç§»åŠ¨èŠ‚ç‚¹</li>
<li>ä»é“¾è¡¨å°¾éƒ¨åˆ é™¤èŠ‚ç‚¹</li>
<li>ç§»åŠ¨èŠ‚ç‚¹åˆ°å¤´éƒ¨éœ€è¦ O(1) æ—¶é—´</li>
</ul></li>
</ol>

<h3 id="æ•°æ®ç»“æ„ç»„åˆ">æ•°æ®ç»“æ„ç»„åˆ</h3>

<ul>
<li><strong>å“ˆå¸Œè¡¨</strong>ï¼š<code>map[key] -&gt; é“¾è¡¨èŠ‚ç‚¹æŒ‡é’ˆ</code></li>
<li><strong>åŒå‘é“¾è¡¨</strong>ï¼šèŠ‚ç‚¹åŒ…å« <code>key, value, prev, next</code></li>
<li>æ“ä½œï¼š
<ul>
<li><code>get(key)</code>ï¼šé€šè¿‡å“ˆå¸Œè¡¨æ‰¾åˆ°èŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨</li>
<li><code>put(key, value)</code>ï¼š
<ul>
<li>å¦‚æœ key å­˜åœ¨ï¼šæ›´æ–° valueï¼ŒèŠ‚ç‚¹ç§»åˆ°å¤´éƒ¨</li>
<li>å¦‚æœ key ä¸å­˜åœ¨ï¼š
<ul>
<li>å¦‚æœå®¹é‡å·²æ»¡ï¼šåˆ é™¤é“¾è¡¨å°¾éƒ¨èŠ‚ç‚¹ï¼Œä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤å¯¹åº” key</li>
<li>åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œæ’å…¥é“¾è¡¨å¤´éƒ¨ï¼ŒåŠ å…¥å“ˆå¸Œè¡¨</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<hr />

<h2 id="è§£æ³•ä¸€å“ˆå¸Œè¡¨-è‡ªå®šä¹‰åŒå‘é“¾è¡¨">è§£æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + è‡ªå®šä¹‰åŒå‘é“¾è¡¨</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<p>æ‰‹åŠ¨å®ç°åŒå‘é“¾è¡¨ï¼Œæ˜ç¡®æ§åˆ¶èŠ‚ç‚¹çš„æ’å…¥ã€åˆ é™¤å’Œç§»åŠ¨æ“ä½œã€‚</p>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>type LRUCache struct {
    capacity int
    cache    map[int]*DLinkedNode
    head     *DLinkedNode
    tail     *DLinkedNode
}

type DLinkedNode struct {
    key   int
    value int
    prev  *DLinkedNode
    next  *DLinkedNode
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*DLinkedNode),
        head:     &amp;DLinkedNode{key: 0, value: 0},
        tail:     &amp;DLinkedNode{key: 0, value: 0},
    }
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
        return
    }

    if len(this.cache) &gt;= this.capacity {
        removed := this.removeTail()
        delete(this.cache, removed.key)
    }

    newNode := &amp;DLinkedNode{key: key, value: value}
    this.cache[key] = newNode
    this.addToHead(newNode)
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
    node := this.tail.prev
    this.removeNode(node)
    return node
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>class LRUCache {
private:
    struct DLinkedNode {
        int key, value;
        DLinkedNode* prev;
        DLinkedNode* next;
        DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
        DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
    };

    unordered_map&lt;int, DLinkedNode*&gt; cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int capacity;
    int size;

    void addToHead(DLinkedNode* node) {
        node-&gt;prev = head;
        node-&gt;next = head-&gt;next;
        head-&gt;next-&gt;prev = node;
        head-&gt;next = node;
    }

    void removeNode(DLinkedNode* node) {
        node-&gt;prev-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = node-&gt;prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail-&gt;prev;
        removeNode(node);
        return node;
    }

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }

    int get(int key) {
        if (!cache.count(key)) return -1;
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node-&gt;value;
    }

    void put(int key, int value) {
        if (cache.count(key)) {
            DLinkedNode* node = cache[key];
            node-&gt;value = value;
            moveToHead(node);
            return;
        }

        if (size == capacity) {
            DLinkedNode* removed = removeTail();
            cache.erase(removed-&gt;key);
            delete removed;
            size--;
        }

        DLinkedNode* newNode = new DLinkedNode(key, value);
        cache[key] = newNode;
        addToHead(newNode);
        size++;
    }

    ~LRUCache() {
        for (auto&amp; pair : cache) {
            delete pair.second;
        }
        delete head;
        delete tail;
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)
<ul>
<li>get å’Œ put æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´</li>
<li>å“ˆå¸Œè¡¨æ“ä½œ O(1)ï¼Œé“¾è¡¨æ“ä½œ O(1)</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(capacity)
<ul>
<li>å“ˆå¸Œè¡¨å’Œé“¾è¡¨å­˜å‚¨ capacity ä¸ªå…ƒç´ </li>
</ul></li>
</ul>

<hr />

<h2 id="è§£æ³•äºŒä½¿ç”¨-stlcæˆ–-containerlistgo">è§£æ³•äºŒï¼šä½¿ç”¨ STLï¼ˆC++ï¼‰æˆ– container/listï¼ˆGoï¼‰</h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<p>åˆ©ç”¨è¯­è¨€æ ‡å‡†åº“ä¸­çš„åŒå‘é“¾è¡¨å’Œå“ˆå¸Œè¡¨ï¼Œå‡å°‘æ‰‹åŠ¨é“¾è¡¨æ“ä½œã€‚</p>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°ä½¿ç”¨-containerlist">Go å®ç°ï¼ˆä½¿ç”¨ container/listï¼‰</h4>

<pre><code>import "container/list"

type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
}

type entry struct {
    key   int
    value int
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (this *LRUCache) Get(key int) int {
    if elem, ok := this.cache[key]; ok {
        this.list.MoveToFront(elem)
        return elem.Value.(*entry).value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if elem, ok := this.cache[key]; ok {
        elem.Value.(*entry).value = value
        this.list.MoveToFront(elem)
        return
    }

    if this.list.Len() &gt;= this.capacity {
        back := this.list.Back()
        delete(this.cache, back.Value.(*entry).key)
        this.list.Remove(back)
    }

    newEntry := &amp;entry{key: key, value: value}
    elem := this.list.PushFront(newEntry)
    this.cache[key] = elem
}
</code></pre>

<h4 id="c-å®ç°ä½¿ç”¨-stl">C++ å®ç°ï¼ˆä½¿ç”¨ STLï¼‰</h4>

<pre><code>class LRUCache {
private:
    int capacity;
    list&lt;pair&lt;int, int&gt;&gt; cacheList;
    unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cacheMap;

public:
    LRUCache(int _capacity): capacity(_capacity) {}

    int get(int key) {
        if (cacheMap.find(key) == cacheMap.end()) return -1;

        auto it = cacheMap[key];
        int value = it-&gt;second;

        cacheList.erase(it);
        cacheList.push_front({key, value});
        cacheMap[key] = cacheList.begin();

        return value;
    }

    void put(int key, int value) {
        if (cacheMap.find(key) != cacheMap.end()) {
            cacheList.erase(cacheMap[key]);
        } else if (cacheList.size() == capacity) {
            auto last = cacheList.back();
            cacheMap.erase(last.first);
            cacheList.pop_back();
        }

        cacheList.push_front({key, value});
        cacheMap[key] = cacheList.begin();
    }
};
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-2">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)
<ul>
<li>æ‰€æœ‰æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´</li>
</ul></li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(capacity)
<ul>
<li>å­˜å‚¨ capacity ä¸ªå…ƒç´ </li>
</ul></li>
</ul>

<hr />

<h2 id="è§£æ³•ä¸‰ä½¿ç”¨-linkedhashmapjava-é£æ ¼æ€è·¯">è§£æ³•ä¸‰ï¼šä½¿ç”¨ LinkedHashMapï¼ˆJava é£æ ¼æ€è·¯ï¼‰</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<p>æŸäº›è¯­è¨€ï¼ˆå¦‚ Javaï¼‰æœ‰å†…ç½®çš„ LinkedHashMap å¯ä»¥ç›´æ¥å®ç° LRUã€‚è¿™é‡Œç”¨ Go æ¨¡æ‹Ÿç±»ä¼¼ç»“æ„ã€‚</p>

<h3 id="go-å®ç°ç®€åŒ–ç‰ˆ">Go å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰</h3>

<pre><code>type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
    mu       sync.RWMutex // å¦‚æœè€ƒè™‘å¹¶å‘
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (lru *LRUCache) Get(key int) int {
    lru.mu.RLock()
    elem, ok := lru.cache[key]
    lru.mu.RUnlock()

    if !ok {
        return -1
    }

    lru.mu.Lock()
    lru.list.MoveToFront(elem)
    value := elem.Value.(*entry).value
    lru.mu.Unlock()

    return value
}

func (lru *LRUCache) Put(key int, value int) {
    lru.mu.Lock()
    defer lru.mu.Unlock()

    if elem, ok := lru.cache[key]; ok {
        elem.Value.(*entry).value = value
        lru.list.MoveToFront(elem)
        return
    }

    if lru.list.Len() &gt;= lru.capacity {
        back := lru.list.Back()
        delete(lru.cache, back.Value.(*entry).key)
        lru.list.Remove(back)
    }

    newEntry := &amp;entry{key: key, value: value}
    elem := lru.list.PushFront(newEntry)
    lru.cache[key] = elem
}
</code></pre>

<h3 id="å¤æ‚åº¦åˆ†æ-3">å¤æ‚åº¦åˆ†æ</h3>

<ul>
<li><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(1)</li>
<li><strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(capacity)</li>
</ul>

<hr />

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>ç‰¹æ€§</th>
  <th>è§£æ³•ä¸€ï¼ˆè‡ªå®šä¹‰é“¾è¡¨ï¼‰</th>
  <th>è§£æ³•äºŒï¼ˆæ ‡å‡†åº“ï¼‰</th>
  <th>è§£æ³•ä¸‰ï¼ˆå¹¶å‘å®‰å…¨ï¼‰</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>å®ç°å¤æ‚åº¦</strong></td>
  <td>è¾ƒé«˜ï¼Œéœ€è¦æ‰‹åŠ¨ç®¡ç†é“¾è¡¨</td>
  <td>è¾ƒä½ï¼Œåˆ©ç”¨æ ‡å‡†åº“</td>
  <td>ä¸­ç­‰ï¼Œæ·»åŠ é”æœºåˆ¶</td>
</tr>
<tr>
  <td><strong>æ€§èƒ½</strong></td>
  <td>æœ€ä¼˜ï¼Œæ— é¢å¤–å¼€é”€</td>
  <td>ç¨æ…¢ï¼Œæœ‰æ¥å£è°ƒç”¨å¼€é”€</td>
  <td>æœ€æ…¢ï¼Œæœ‰é”å¼€é”€</td>
</tr>
<tr>
  <td><strong>å¯è¯»æ€§</strong></td>
  <td>è¾ƒä½ï¼Œä»£ç é‡å¤§</td>
  <td>è¾ƒé«˜ï¼Œä»£ç ç®€æ´</td>
  <td>ä¸­ç­‰</td>
</tr>
<tr>
  <td><strong>æ‰©å±•æ€§</strong></td>
  <td>é«˜ï¼Œå®Œå…¨å¯æ§</td>
  <td>ä½ï¼Œå—é™äºåº“åŠŸèƒ½</td>
  <td>é«˜ï¼Œå¯æ‰©å±•å¹¶å‘</td>
</tr>
<tr>
  <td><strong>é€‚ç”¨åœºæ™¯</strong></td>
  <td>æ€§èƒ½è¦æ±‚æé«˜</td>
  <td>å¿«é€Ÿå®ç°ï¼Œä»£ç ç®€æ´</td>
  <td>å¹¶å‘ç¯å¢ƒ</td>
</tr>
</tbody>
</table>

<h3 id="æ¨èæ–¹æ¡ˆ">æ¨èæ–¹æ¡ˆ</h3>

<ol>
<li><strong>é¢è¯•/ç«èµ›</strong>ï¼šè§£æ³•ä¸€ï¼Œå±•ç¤ºå¯¹æ•°æ®ç»“æ„çš„æ·±å…¥ç†è§£</li>
<li><strong>ç”Ÿäº§ç¯å¢ƒ</strong>ï¼šè§£æ³•äºŒï¼Œä»£ç ç®€æ´æ˜“ç»´æŠ¤</li>
<li><strong>å¹¶å‘ç¯å¢ƒ</strong>ï¼šè§£æ³•ä¸‰ï¼Œæ·»åŠ é€‚å½“çš„åŒæ­¥æœºåˆ¶</li>
</ol>

<h3 id="å…³é”®ç‚¹æ€»ç»“">å…³é”®ç‚¹æ€»ç»“</h3>

<ol>
<li><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼šå“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨</li>
<li><strong>O(1) æ“ä½œ</strong>ï¼šå“ˆå¸Œè¡¨æŸ¥æ‰¾ O(1)ï¼Œé“¾è¡¨æ’å…¥/åˆ é™¤ O(1)</li>
<li><strong>ç»´æŠ¤é¡ºåº</strong>ï¼šæœ€è¿‘ä½¿ç”¨çš„æ”¾å¤´éƒ¨ï¼Œæœ€ä¹…æœªä½¿ç”¨çš„åœ¨å°¾éƒ¨</li>
<li><strong>å®¹é‡ç®¡ç†</strong>ï¼šæ’å…¥æ—¶æ£€æŸ¥å®¹é‡ï¼Œæ»¡åˆ™åˆ é™¤å°¾éƒ¨èŠ‚ç‚¹</li>
</ol>

<p>æ‰€æœ‰è§£æ³•éƒ½èƒ½æ»¡è¶³ O(1) æ—¶é—´å¤æ‚åº¦è¦æ±‚ï¼Œé€‰æ‹©å“ªç§å–å†³äºå…·ä½“éœ€æ±‚å’Œç¯å¢ƒã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 15:50:14</em></p>

                </div>
            </div>

            <div class="footer">
                <p>ç”± <a href="https://github.com/LFrankl/leetcode" target="_blank">LeetCode Daily Script</a> è‡ªåŠ¨ç”Ÿæˆ</p>
                <p>AI è§£ç­”ç”± <a href="https://www.deepseek.com/" target="_blank">DeepSeek</a> æä¾›</p>
            </div>
        </div>
    </div>
</body>
</html>