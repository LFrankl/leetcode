<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2092. æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶ - LeetCode</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="top-bar">
        <button class="menu-button" onclick="history.back()" aria-label="è¿”å›">
            <div class="menu-icon">
                <span style="transform: rotate(-45deg) translateY(-2px);"></span>
                <span style="transform: rotate(45deg) translateY(2px);"></span>
            </div>
        </button>
        <div class="logo">
            <span class="logo-emoji">ğŸ“š</span>
            LeetCode æ¯æ—¥é¢˜ç›®
        </div>
        <div class="update-time">2026-02-26 02:00:00</div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content" style="margin-left: 0;">
        <div class="content-wrapper">
            <button class="back-button" onclick="history.back()">
                â† è¿”å›é¢˜ç›®åˆ—è¡¨
            </button>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-number">2092. æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶</span>
                    <span class="difficulty-badge difficulty-hard">
                        å›°éš¾
                    </span>
                    <a href="https://leetcode.cn/problems/find-all-people-with-secret/" target="_blank" class="question-link">åœ¨ LeetCode æ‰“å¼€</a>
                </div>
                <div class="markdown-content">
                    <h1 id="2092-æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶">2092. æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: æ·±åº¦ä¼˜å…ˆæœç´¢, å¹¿åº¦ä¼˜å…ˆæœç´¢, å¹¶æŸ¥é›†, å›¾, æ’åº</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/find-all-people-with-secret/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªæ•´æ•° <code>n</code> ï¼Œè¡¨ç¤ºæœ‰ <code>n</code> ä¸ªä¸“å®¶ä» <code>0</code> åˆ° <code>n - 1</code> ç¼–å·ã€‚å¦å¤–ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„äºŒç»´æ•´æ•°æ•°ç»„ <code>meetings</code> ï¼Œå…¶ä¸­ <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> è¡¨ç¤ºä¸“å®¶ <code>x<sub>i</sub></code> å’Œä¸“å®¶ <code>y<sub>i</sub></code> åœ¨æ—¶é—´ <code>time<sub>i</sub></code> è¦å¼€ä¸€åœºä¼šã€‚ä¸€ä¸ªä¸“å®¶å¯ä»¥åŒæ—¶å‚åŠ  <strong>å¤šåœºä¼šè®®</strong> ã€‚æœ€åï¼Œç»™ä½ ä¸€ä¸ªæ•´æ•° <code>firstPerson</code> ã€‚</p>

<p>ä¸“å®¶ <code>0</code> æœ‰ä¸€ä¸ª <strong>ç§˜å¯†</strong> ï¼Œæœ€åˆï¼Œä»–åœ¨æ—¶é—´&nbsp;<code>0</code> å°†è¿™ä¸ªç§˜å¯†åˆ†äº«ç»™äº†ä¸“å®¶ <code>firstPerson</code> ã€‚æ¥ç€ï¼Œè¿™ä¸ªç§˜å¯†ä¼šåœ¨æ¯æ¬¡æœ‰çŸ¥æ™“è¿™ä¸ªç§˜å¯†çš„ä¸“å®¶å‚åŠ ä¼šè®®æ—¶è¿›è¡Œä¼ æ’­ã€‚æ›´æ­£å¼çš„è¡¨è¾¾æ˜¯ï¼Œæ¯æ¬¡ä¼šè®®ï¼Œå¦‚æœä¸“å®¶ <code>x<sub>i</sub></code> åœ¨æ—¶é—´ <code>time<sub>i</sub></code> æ—¶çŸ¥æ™“è¿™ä¸ªç§˜å¯†ï¼Œé‚£ä¹ˆä»–å°†ä¼šä¸ä¸“å®¶ <code>y<sub>i</sub></code> åˆ†äº«è¿™ä¸ªç§˜å¯†ï¼Œåä¹‹äº¦ç„¶ã€‚</p>

<p>ç§˜å¯†å…±äº«æ˜¯ <strong>ç¬æ—¶å‘ç”Ÿ</strong> çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨åŒä¸€æ—¶é—´ï¼Œä¸€ä¸ªä¸“å®¶ä¸å…‰å¯ä»¥æ¥æ”¶åˆ°ç§˜å¯†ï¼Œè¿˜èƒ½åœ¨å…¶ä»–ä¼šè®®ä¸Šä¸å…¶ä»–ä¸“å®¶åˆ†äº«ã€‚</p>

<p>åœ¨æ‰€æœ‰ä¼šè®®éƒ½ç»“æŸä¹‹åï¼Œè¿”å›æ‰€æœ‰çŸ¥æ™“è¿™ä¸ªç§˜å¯†çš„ä¸“å®¶åˆ—è¡¨ã€‚ä½ å¯ä»¥æŒ‰ <strong>ä»»ä½•é¡ºåº</strong> è¿”å›ç­”æ¡ˆã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>è¾“å‡ºï¼š</strong>[0,1,2,3,5]
<strong>è§£é‡Šï¼š
</strong>æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 1 å…±äº«ã€‚
æ—¶é—´ 5 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 2 å…±äº«ã€‚
æ—¶é—´ 8 ï¼Œä¸“å®¶ 2 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ—¶é—´ 10 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 5 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1ã€2ã€3 å’Œ 5 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>è¾“å‡ºï¼š</strong>[0,1,3]
<strong>è§£é‡Šï¼š</strong>
æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ—¶é—´ 2 ï¼Œä¸“å®¶ 1 ä¸ä¸“å®¶ 2 éƒ½ä¸çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
æ—¶é—´ 3 ï¼Œä¸“å®¶ 3 å°†ç§˜å¯†ä¸ä¸“å®¶ 0 å’Œä¸“å®¶ 1 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1 å’Œ 3 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>è¾“å‡ºï¼š</strong>[0,1,2,3,4]
<strong>è§£é‡Šï¼š</strong>
æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 1 å…±äº«ã€‚
æ—¶é—´ 1 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 2 å…±äº«ï¼Œä¸“å®¶ 2 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ³¨æ„ï¼Œä¸“å®¶ 2 å¯ä»¥åœ¨æ”¶åˆ°ç§˜å¯†çš„åŒä¸€æ—¶é—´åˆ†äº«æ­¤ç§˜å¯†ã€‚
æ—¶é—´ 2 ï¼Œä¸“å®¶ 3 å°†ç§˜å¯†ä¸ä¸“å®¶ 4 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1ã€2ã€3 å’Œ 4 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
    <li><code>meetings[i].length == 3</code></li>
    <li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
    <li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
    <li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public List&lt;Integer&gt; findAllPeople(int n, int[][] meetings, int firstPerson) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -&gt; List[int]:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @param {number[][]} meetings
 * @param {number} firstPerson
 * @return {number[]}
 */
var findAllPeople = function(n, meetings, firstPerson) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>Could you model all the meetings happening at the same time as a graph?</li>
<li>What data structure can you use to efficiently share the secret?</li>
<li>You can use the union-find data structure to quickly determine who knows the secret and share the secret.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>6
[[1,2,5],[2,3,8],[1,5,10]]
1
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ª<strong>æ—¶é—´ä¾èµ–çš„å›¾ä¼ æ’­é—®é¢˜</strong>ã€‚ä¸“å®¶æ˜¯èŠ‚ç‚¹ï¼Œä¼šè®®æ˜¯è¾¹ï¼Œä½†è¾¹åªåœ¨ç‰¹å®šæ—¶é—´ç‚¹æœ‰æ•ˆã€‚ç§˜å¯†ä»ä¸“å®¶0å’ŒfirstPersonå¼€å§‹ï¼Œé€šè¿‡ä¼šè®®åœ¨ä¸“å®¶é—´ä¼ æ’­ã€‚å…³é”®ç‚¹ï¼š
- ä¼šè®®æŒ‰æ—¶é—´é¡ºåºå‘ç”Ÿ
- åŒä¸€æ—¶é—´å¯èƒ½æœ‰å¤šä¸ªä¼šè®®åŒæ—¶è¿›è¡Œ
- ç§˜å¯†ä¼ æ’­æ˜¯ç¬æ—¶çš„ï¼ˆåŒä¸€æ—¶é—´å¯ä»¥ä¼ æ’­å¤šæ¬¡ï¼‰</p>

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<p>æ ¸å¿ƒæ€æƒ³ï¼š<strong>æŒ‰æ—¶é—´åˆ†ç»„å¤„ç†ä¼šè®®</strong>ï¼Œå¯¹æ¯ä¸ªæ—¶é—´ç‚¹çš„ä¼šè®®é›†åˆï¼Œä½¿ç”¨å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰æ¥åˆå¹¶çŸ¥æ™“ç§˜å¯†çš„ä¸“å®¶ã€‚</p>

<h3 id="å…³é”®è§‚å¯Ÿ">å…³é”®è§‚å¯Ÿ</h3>

<ol>
<li>åŒä¸€æ—¶é—´ç‚¹çš„ä¼šè®®å¯ä»¥ä»»æ„é¡ºåºå‘ç”Ÿï¼Œç§˜å¯†å¯ä»¥åœ¨è¿™äº›ä¼šè®®ä¸­ä¼ æ’­</li>
<li>ä¸åŒæ—¶é—´ç‚¹çš„ä¼šè®®éœ€è¦æŒ‰æ—¶é—´é¡ºåºå¤„ç†</li>
<li>å¦‚æœä¸€ç»„ä¸“å®¶åœ¨åŒä¸€æ—¶é—´é€šè¿‡ä¼šè®®è¿é€šï¼Œä¸”å…¶ä¸­è‡³å°‘ä¸€äººçŸ¥æ™“ç§˜å¯†ï¼Œåˆ™æ•´ç»„éƒ½ä¼šçŸ¥æ™“</li>
</ol>

<h2 id="è§£æ³•ä¸€æŒ‰æ—¶é—´åˆ†ç»„-å¹¶æŸ¥é›†æ¨è">è§£æ³•ä¸€ï¼šæŒ‰æ—¶é—´åˆ†ç»„ + å¹¶æŸ¥é›†ï¼ˆæ¨èï¼‰</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<ol>
<li>æŒ‰ä¼šè®®æ—¶é—´åˆ†ç»„</li>
<li>å¯¹æ¯ä¸ªæ—¶é—´ç‚¹çš„ä¼šè®®ï¼š
<ul>
<li>ç”¨å¹¶æŸ¥é›†è¿æ¥å‚ä¼šä¸“å®¶</li>
<li>æ£€æŸ¥æ¯ä¸ªè¿é€šåˆ†é‡ï¼šå¦‚æœåŒ…å«å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶ï¼Œæ ‡è®°æ•´ä¸ªåˆ†é‡ä¸ºçŸ¥æ™“ç§˜å¯†</li>
</ul></li>
<li>å¤„ç†å®Œä¸€ä¸ªæ—¶é—´ç‚¹åï¼Œé‡ç½®å¹¶æŸ¥é›†ï¼ˆåªä¿ç•™çŸ¥æ™“ç§˜å¯†çš„çŠ¶æ€ï¼‰</li>
</ol>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æŒ‰æ—¶é—´åˆ†ç»„ä¼šè®®
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        x, y, t := meeting[0], meeting[1], meeting[2]
        timeMap[t] = append(timeMap[t], [2]int{x, y})
    }

    // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true

    // è·å–æ‰€æœ‰æ—¶é—´ç‚¹å¹¶æ’åº
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)

    for _, t := range times {
        meetingsAtTime := timeMap[t]

        // æ„å»ºå½“å‰æ—¶é—´ç‚¹çš„å›¾
        graph := make(map[int][]int)
        experts := make(map[int]bool)

        for _, meeting := range meetingsAtTime {
            x, y := meeting[0], meeting[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
            experts[x] = true
            experts[y] = true
        }

        // BFSä¼ æ’­ç§˜å¯†
        queue := make([]int, 0)
        visited := make(map[int]bool)

        // å°†æ‰€æœ‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶åŠ å…¥é˜Ÿåˆ—
        for expert := range experts {
            if known[expert] &amp;&amp; !visited[expert] {
                queue = append(queue, expert)
                visited[expert] = true
            }
        }

        // BFSéå†
        for len(queue) &gt; 0 {
            curr := queue[0]
            queue = queue[1:]

            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }

    // æ”¶é›†ç»“æœ
    result := make([]int, 0)
    for i := 0; i &lt; n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
</code></pre>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æŒ‰æ—¶é—´åˆ†ç»„ä¼šè®®
        map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; timeMap;
        for (auto&amp; meeting : meetings) {
            int x = meeting[0], y = meeting[1], t = meeting[2];
            timeMap[t].push_back({x, y});
        }

        // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
        vector&lt;bool&gt; known(n, false);
        known[0] = true;
        known[firstPerson] = true;

        for (auto&amp; [time, meetingsAtTime] : timeMap) {
            // æ„å»ºå½“å‰æ—¶é—´ç‚¹çš„å›¾
            unordered_map&lt;int, vector&lt;int&gt;&gt; graph;
            unordered_set&lt;int&gt; experts;

            for (auto&amp; [x, y] : meetingsAtTime) {
                graph[x].push_back(y);
                graph[y].push_back(x);
                experts.insert(x);
                experts.insert(y);
            }

            // BFSä¼ æ’­ç§˜å¯†
            queue&lt;int&gt; q;
            unordered_set&lt;int&gt; visited;

            // å°†æ‰€æœ‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶åŠ å…¥é˜Ÿåˆ—
            for (int expert : experts) {
                if (known[expert] &amp;&amp; !visited.count(expert)) {
                    q.push(expert);
                    visited.insert(expert);
                }
            }

            // BFSéå†
            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }

        // æ”¶é›†ç»“æœ
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(T + M + N)ï¼Œå…¶ä¸­Tæ˜¯ä¸åŒæ—¶é—´ç‚¹æ•°é‡ï¼ŒMæ˜¯ä¼šè®®æ•°ï¼ŒNæ˜¯ä¸“å®¶æ•°
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N + M)</p>

<h2 id="è§£æ³•äºŒå¹¶æŸ¥é›†-æ—¶é—´æ’åºä¼˜åŒ–">è§£æ³•äºŒï¼šå¹¶æŸ¥é›† + æ—¶é—´æ’åºä¼˜åŒ–</h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<p>ä½¿ç”¨å¹¶æŸ¥é›†ï¼Œä½†åœ¨æ¯ä¸ªæ—¶é—´ç‚¹å¤„ç†å®Œåï¼Œéœ€è¦é‡ç½®é‚£äº›ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶çš„è¿æ¥çŠ¶æ€ã€‚</p>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æŒ‰æ—¶é—´æ’åºä¼šè®®
    sort.Slice(meetings, func(i, j int) bool {
        return meetings[i][2] &lt; meetings[j][2]
    })

    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    parent := make([]int, n)
    for i := range parent {
        parent[i] = i
    }

    // åˆå¹¶0å’ŒfirstPerson
    union(parent, 0, firstPerson)

    i := 0
    m := len(meetings)

    for i &lt; m {
        j := i
        // æ‰¾åˆ°ç›¸åŒæ—¶é—´çš„æ‰€æœ‰ä¼šè®®
        for j &lt; m &amp;&amp; meetings[j][2] == meetings[i][2] {
            j++
        }

        // è¿æ¥å½“å‰æ—¶é—´çš„æ‰€æœ‰ä¸“å®¶
        for k := i; k &lt; j; k++ {
            union(parent, meetings[k][0], meetings[k][1])
        }

        // æ£€æŸ¥å“ªäº›ä¸“å®¶çŸ¥é“äº†ç§˜å¯†
        for k := i; k &lt; j; k++ {
            x, y := meetings[k][0], meetings[k][1]
            if find(parent, x) == find(parent, 0) {
                // è¿™ä¸ªè¿é€šåˆ†é‡çŸ¥é“äº†ç§˜å¯†
            } else {
                // é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
                parent[x] = x
                parent[y] = y
            }
        }

        i = j
    }

    // æ”¶é›†çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
    result := []int{}
    for idx := 0; idx &lt; n; idx++ {
        if find(parent, idx) == find(parent, 0) {
            result = append(result, idx)
        }
    }
    return result
}

func find(parent []int, x int) int {
    if parent[x] != x {
        parent[x] = find(parent, parent[x])
    }
    return parent[x]
}

func union(parent []int, x, y int) {
    rootX := find(parent, x)
    rootY := find(parent, y)
    if rootX != rootY {
        parent[rootY] = rootX
    }
}
</code></pre>

<pre><code>class Solution {
private:
    vector&lt;int&gt; parent;

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootY] = rootX;
        }
    }

public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æŒ‰æ—¶é—´æ’åºä¼šè®®
        sort(meetings.begin(), meetings.end(), 
             [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
                 return a[2] &lt; b[2];
             });

        // åˆå§‹åŒ–å¹¶æŸ¥é›†
        parent.resize(n);
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
        }

        // åˆå¹¶0å’ŒfirstPerson
        unite(0, firstPerson);

        int m = meetings.size();
        for (int i = 0; i &lt; m; ) {
            int j = i;
            // æ‰¾åˆ°ç›¸åŒæ—¶é—´çš„æ‰€æœ‰ä¼šè®®
            while (j &lt; m &amp;&amp; meetings[j][2] == meetings[i][2]) {
                j++;
            }

            // è¿æ¥å½“å‰æ—¶é—´çš„æ‰€æœ‰ä¸“å®¶
            for (int k = i; k &lt; j; k++) {
                unite(meetings[k][0], meetings[k][1]);
            }

            // æ£€æŸ¥å¹¶é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
            for (int k = i; k &lt; j; k++) {
                int x = meetings[k][0], y = meetings[k][1];
                if (find(x) != find(0)) {
                    // é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
                    parent[x] = x;
                    parent[y] = y;
                }
            }

            i = j;
        }

        // æ”¶é›†çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (find(i) == find(0)) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(M log M + M Î±(N))ï¼Œå…¶ä¸­Î±æ˜¯åé˜¿å…‹æ›¼å‡½æ•°
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N)</p>

<h2 id="è§£æ³•ä¸‰bfsæŒ‰å±‚ä¼ æ’­">è§£æ³•ä¸‰ï¼šBFSæŒ‰å±‚ä¼ æ’­</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<p>å°†ä¼šè®®æŒ‰æ—¶é—´æ’åºï¼Œä½¿ç”¨BFSæŒ‰æ—¶é—´å±‚ä¼ æ’­ç§˜å¯†ã€‚</p>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æ„å»ºé‚»æ¥è¡¨ï¼šæ—¶é—´ -&gt; [ä¸“å®¶å¯¹]
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        timeMap[meeting[2]] = append(timeMap[meeting[2]], [2]int{meeting[0], meeting[1]})
    }

    // è·å–æ‰€æœ‰æ—¶é—´å¹¶æ’åº
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)

    // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true

    for _, t := range times {
        // æ„å»ºå½“å‰æ—¶é—´çš„å›¾
        graph := make(map[int][]int)
        for _, pair := range timeMap[t] {
            x, y := pair[0], pair[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
        }

        // BFSé˜Ÿåˆ—
        queue := make([]int, 0)
        visited := make(map[int]bool)

        // æ·»åŠ å½“å‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
        for node := range graph {
            if known[node] &amp;&amp; !visited[node] {
                queue = append(queue, node)
                visited[node] = true
            }
        }

        // BFSä¼ æ’­
        for len(queue) &gt; 0 {
            curr := queue[0]
            queue = queue[1:]

            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }

    // æ”¶é›†ç»“æœ
    result := make([]int, 0)
    for i := 0; i &lt; n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
</code></pre>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æ„å»ºæ—¶é—´æ˜ å°„
        map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; timeMap;
        for (auto&amp; meeting : meetings) {
            timeMap[meeting[2]].push_back({meeting[0], meeting[1]});
        }

        vector&lt;bool&gt; known(n, false);
        known[0] = true;
        known[firstPerson] = true;

        for (auto&amp; [time, pairs] : timeMap) {
            // æ„å»ºå½“å‰æ—¶é—´çš„å›¾
            unordered_map&lt;int, vector&lt;int&gt;&gt; graph;
            for (auto&amp; [x, y] : pairs) {
                graph[x].push_back(y);
                graph[y].push_back(x);
            }

            // BFSä¼ æ’­
            queue&lt;int&gt; q;
            unordered_set&lt;int&gt; visited;

            // æ·»åŠ å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
            for (auto&amp; [node, _] : graph) {
                if (known[node] &amp;&amp; !visited.count(node)) {
                    q.push(node);
                    visited.insert(node);
                }
            }

            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }

        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(T + M + N)
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N + M)</p>

<h2 id="å¤æ‚åº¦å¯¹æ¯”">å¤æ‚åº¦å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>è§£æ³•ä¸€</td>
  <td>O(T + M + N)</td>
  <td>O(N + M)</td>
  <td>é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£</td>
  <td>éœ€è¦é¢å¤–å­˜å‚¨æ—¶é—´åˆ†ç»„</td>
</tr>
<tr>
  <td>è§£æ³•äºŒ</td>
  <td>O(M log M + M Î±(N))</td>
  <td>O(N)</td>
  <td>ç©ºé—´æ•ˆç‡é«˜ï¼Œä½¿ç”¨å¹¶æŸ¥é›†</td>
  <td>éœ€è¦é‡ç½®å¹¶æŸ¥é›†çŠ¶æ€</td>
</tr>
<tr>
  <td>è§£æ³•ä¸‰</td>
  <td>O(T + M + N)</td>
  <td>O(N + M)</td>
  <td>BFSç›´è§‚ï¼Œé€‚åˆå›¾ä¼ æ’­</td>
  <td>éœ€è¦æ„å»ºæ—¶é—´æ˜ å°„</td>
</tr>
</tbody>
</table>

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<ol>
<li><strong>è§£æ³•ä¸€ï¼ˆåˆ†ç»„+BFSï¼‰</strong> æ˜¯æœ€ç›´è§‚çš„è§£æ³•ï¼Œé€‚åˆç†è§£å’Œå®ç°</li>
<li><strong>è§£æ³•äºŒï¼ˆå¹¶æŸ¥é›†ï¼‰</strong> ç©ºé—´æ•ˆç‡æœ€é«˜ï¼Œä½†éœ€è¦å°å¿ƒå¤„ç†çŠ¶æ€é‡ç½®</li>
<li><strong>è§£æ³•ä¸‰ï¼ˆBFSåˆ†å±‚ï¼‰</strong> ä¸è§£æ³•ä¸€ç±»ä¼¼ï¼Œä½†æ›´å¼ºè°ƒæ—¶é—´åˆ†å±‚</li>
</ol>

<p><strong>æ¨èä½¿ç”¨è§£æ³•ä¸€</strong>ï¼Œå› ä¸ºï¼š
- é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œè°ƒè¯•
- æ—¶é—´å¤æ‚åº¦ä¸æœ€ä¼˜è§£ç›¸åŒ
- é€‚åˆå¤„ç†å¤§è§„æ¨¡æ•°æ®
- ä»£ç å¯è¯»æ€§å¥½ï¼Œæ˜“äºç»´æŠ¤</p>

<p>åœ¨å®é™…LeetCodeæäº¤ä¸­ï¼Œè§£æ³•ä¸€å’Œè§£æ³•äºŒéƒ½æœ‰å¾ˆå¥½çš„æ€§èƒ½è¡¨ç°ï¼Œå¯ä»¥æ ¹æ®ä¸ªäººåå¥½é€‰æ‹©ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 19:08:03</em></p>

                </div>
            </div>

            <div class="footer">
                <p>ç”± <a href="https://github.com/LFrankl/leetcode" target="_blank">LeetCode Daily Script</a> è‡ªåŠ¨ç”Ÿæˆ</p>
                <p>AI è§£ç­”ç”± <a href="https://www.deepseek.com/" target="_blank">DeepSeek</a> æä¾›</p>
            </div>
        </div>
    </div>

    <!-- æµ®åŠ¨è¿”å›æŒ‰é’® -->
    <button class="fab-back" onclick="history.back()" aria-label="è¿”å›é¢˜ç›®åˆ—è¡¨">
        â†‘
    </button>
</body>
</html>