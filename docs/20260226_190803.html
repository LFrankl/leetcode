<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 2026-02-26 19:08:03</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
        <div class="content">
            <h1>ğŸ“… 2026-02-26 19:08:03 æ¯æ—¥é¢˜ç›®</h1>
            <h1 id="1-ä¸¤æ•°ä¹‹å’Œ">1. ä¸¤æ•°ä¹‹å’Œ</h1>

<p><strong>éš¾åº¦</strong>: Easy</p>

<p><strong>æ ‡ç­¾</strong>: æ•°ç»„, å“ˆå¸Œè¡¨</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/two-sum/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°">é¢˜ç›®æè¿°</h2>

<p>ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ <code>nums</code>&nbsp;å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ <code>target</code>ï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º <strong>å’Œä¸ºç›®æ ‡å€¼ </strong><em><code>target</code></em>&nbsp; çš„é‚£&nbsp;<strong>ä¸¤ä¸ª</strong>&nbsp;æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚</p>

<p>ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚</p>

<p>ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [2,7,11,15], target = 9
<strong>è¾“å‡ºï¼š</strong>[0,1]
<strong>è§£é‡Šï¼š</strong>å› ä¸º nums[0] + nums[1] == 9 ï¼Œè¿”å› [0, 1] ã€‚
</pre>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [3,2,4], target = 6
<strong>è¾“å‡ºï¼š</strong>[1,2]
</pre>

<p><strong class="example">ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [3,3], target = 6
<strong>è¾“å‡ºï¼š</strong>[0,1]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
    <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
    <li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
    <li><strong>åªä¼šå­˜åœ¨ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆ</strong></li>
</ul>

<p>&nbsp;</p>

<p><strong>è¿›é˜¶ï¼š</strong>ä½ å¯ä»¥æƒ³å‡ºä¸€ä¸ªæ—¶é—´å¤æ‚åº¦å°äº <code>O(n<sup>2</sup>)</code> çš„ç®—æ³•å—ï¼Ÿ</p>

<hr />

<h2 id="ä»£ç æ¨¡æ¿">ä»£ç æ¨¡æ¿</h2>

<h3 id="c">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {

    }
};
</code></pre>

<h3 id="java">Java</h3>

<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {

    }
}
</code></pre>

<h3 id="python3">Python3</h3>

<pre><code>class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:

</code></pre>

<h3 id="javascript">JavaScript</h3>

<pre><code>/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {

};
</code></pre>

<h3 id="go">Go</h3>

<pre><code>func twoSum(nums []int, target int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º">æç¤º</h2>

<ol>
<li>A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions just for completeness. It is from these brute force solutions that you can come up with optimizations.</li>
<li>So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?</li>
<li>The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>[2,7,11,15]
9
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek">AI è§£ç­” (DeepSeek)</h2>

<h1 id="ä¸¤æ•°ä¹‹å’Œ-è¯¦ç»†è§£é¢˜åˆ†æ">ä¸¤æ•°ä¹‹å’Œ - è¯¦ç»†è§£é¢˜åˆ†æ</h1>

<h2 id="1-é¢˜ç›®åˆ†æå’Œè§£é¢˜æ€è·¯">1. é¢˜ç›®åˆ†æå’Œè§£é¢˜æ€è·¯</h2>

<p><strong>é—®é¢˜æ ¸å¿ƒ</strong>ï¼šåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ä¸¤ä¸ªæ•°ï¼Œä½¿å®ƒä»¬çš„å’Œç­‰äºç›®æ ‡å€¼ targetã€‚</p>

<p><strong>å…³é”®çº¦æŸ</strong>ï¼š
- ä¸èƒ½ä½¿ç”¨åŒä¸€ä¸ªå…ƒç´ ä¸¤æ¬¡
- å‡è®¾åªæœ‰ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆ
- éœ€è¦è¿”å›å…ƒç´ çš„ä¸‹æ ‡ï¼ˆä¸æ˜¯å€¼æœ¬èº«ï¼‰</p>

<p><strong>åŸºæœ¬æ€è·¯</strong>ï¼š
1. <strong>æš´åŠ›æšä¸¾</strong>ï¼šéå†æ‰€æœ‰å¯èƒ½çš„å…ƒç´ å¯¹ï¼Œæ£€æŸ¥å®ƒä»¬çš„å’Œæ˜¯å¦ç­‰äº target
2. <strong>å“ˆå¸Œè¡¨ä¼˜åŒ–</strong>ï¼šåˆ©ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å·²éå†å…ƒç´ çš„å€¼å’Œä¸‹æ ‡ï¼Œå¿«é€ŸæŸ¥æ‰¾ complement = target - current</p>

<h2 id="2-ä¸åŒè§£æ³•åŠå®ç°">2. ä¸åŒè§£æ³•åŠå®ç°</h2>

<h3 id="è§£æ³•ä¸€æš´åŠ›æšä¸¾æ³•">è§£æ³•ä¸€ï¼šæš´åŠ›æšä¸¾æ³•</h3>

<p><strong>æ€è·¯</strong>ï¼šä½¿ç”¨ä¸¤å±‚å¾ªç¯éå†æ‰€æœ‰å¯èƒ½çš„å…ƒç´ ç»„åˆ</p>

<pre><code>// Go å®ç°
func twoSum(nums []int, target int) []int {
    n := len(nums)
    for i := 0; i &lt; n; i++ {
        for j := i + 1; j &lt; n; j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        int n = nums.size();
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)ï¼Œä¸¤å±‚å¾ªç¯
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å¸¸æ•°ç©ºé—´</p>

<h3 id="è§£æ³•äºŒå“ˆå¸Œè¡¨æ³•ä¸€æ¬¡éå†">è§£æ³•äºŒï¼šå“ˆå¸Œè¡¨æ³•ï¼ˆä¸€æ¬¡éå†ï¼‰</h3>

<p><strong>æ€è·¯</strong>ï¼šéå†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œæ£€æŸ¥ target - nums[i] æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­</p>

<pre><code>// Go å®ç°
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)

    for i, num := range nums {
        complement := target - num
        if idx, exists := hashMap[complement]; exists {
            return []int{idx, i}
        }
        hashMap[num] = i
    }
    return nil
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hashMap;

        for (int i = 0; i &lt; nums.size(); i++) {
            int complement = target - nums[i];
            if (hashMap.find(complement) != hashMap.end()) {
                return {hashMap[complement], i};
            }
            hashMap[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œåªéœ€ä¸€æ¬¡éå†
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦å­˜å‚¨æ‰€æœ‰å…ƒç´ </p>

<h3 id="è§£æ³•ä¸‰å“ˆå¸Œè¡¨æ³•ä¸¤æ¬¡éå†">è§£æ³•ä¸‰ï¼šå“ˆå¸Œè¡¨æ³•ï¼ˆä¸¤æ¬¡éå†ï¼‰</h3>

<p><strong>æ€è·¯</strong>ï¼šå…ˆæ„å»ºå®Œæ•´çš„å“ˆå¸Œè¡¨ï¼Œå†æŸ¥æ‰¾åŒ¹é…å¯¹</p>

<pre><code>// Go å®ç°
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)

    // ç¬¬ä¸€æ¬¡éå†ï¼šæ„å»ºå“ˆå¸Œè¡¨
    for i, num := range nums {
        hashMap[num] = i
    }

    // ç¬¬äºŒæ¬¡éå†ï¼šæŸ¥æ‰¾åŒ¹é…
    for i, num := range nums {
        complement := target - num
        if idx, exists := hashMap[complement]; exists &amp;&amp; idx != i {
            return []int{i, idx}
        }
    }
    return nil
}
</code></pre>

<pre><code>// C++ å®ç°
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hashMap;

        // ç¬¬ä¸€æ¬¡éå†ï¼šæ„å»ºå“ˆå¸Œè¡¨
        for (int i = 0; i &lt; nums.size(); i++) {
            hashMap[nums[i]] = i;
        }

        // ç¬¬äºŒæ¬¡éå†ï¼šæŸ¥æ‰¾åŒ¹é…
        for (int i = 0; i &lt; nums.size(); i++) {
            int complement = target - nums[i];
            if (hashMap.find(complement) != hashMap.end() &amp;&amp; hashMap[complement] != i) {
                return {i, hashMap[complement]};
            }
        }
        return {};
    }
};
</code></pre>

<p><strong>å¤æ‚åº¦åˆ†æ</strong>ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œä¸¤æ¬¡éå†
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œéœ€è¦å­˜å‚¨æ‰€æœ‰å…ƒç´ </p>

<h2 id="3-è§£æ³•å¯¹æ¯”å’Œä¼˜ç¼ºç‚¹">3. è§£æ³•å¯¹æ¯”å’Œä¼˜ç¼ºç‚¹</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æš´åŠ›æšä¸¾</td>
  <td>O(nÂ²)</td>
  <td>O(1)</td>
  <td>å®ç°ç®€å•ï¼Œæ— éœ€é¢å¤–ç©ºé—´</td>
  <td>æ•ˆç‡ä½ï¼Œä¸é€‚åˆå¤§æ•°æ®é‡</td>
</tr>
<tr>
  <td>å“ˆå¸Œè¡¨ï¼ˆä¸€æ¬¡éå†ï¼‰</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>æ•ˆç‡æœ€é«˜ï¼Œä¸€æ¬¡éå†å®Œæˆ</td>
  <td>éœ€è¦é¢å¤–ç©ºé—´</td>
</tr>
<tr>
  <td>å“ˆå¸Œè¡¨ï¼ˆä¸¤æ¬¡éå†ï¼‰</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>é€»è¾‘æ¸…æ™°ï¼Œåˆ†æ­¥æ˜ç¡®</td>
  <td>éœ€è¦ä¸¤æ¬¡éå†</td>
</tr>
</tbody>
</table>

<h2 id="4-æ¨èè§£æ³•">4. æ¨èè§£æ³•</h2>

<p><strong>æ¨èä½¿ç”¨è§£æ³•äºŒï¼ˆå“ˆå¸Œè¡¨ä¸€æ¬¡éå†ï¼‰</strong>ï¼ŒåŸå› ï¼š
1. <strong>æ•ˆç‡æœ€é«˜</strong>ï¼šåªéœ€ä¸€æ¬¡éå†å³å¯å®Œæˆ
2. <strong>å¤„ç†é‡å¤å…ƒç´ </strong>ï¼šå½“é‡åˆ°é‡å¤å…ƒç´ æ—¶ï¼Œåå‡ºç°çš„ä¼šè¦†ç›–å…ˆå‡ºç°çš„ï¼Œè¿™æ°å¥½ç¬¦åˆé¢˜ç›®è¦æ±‚ï¼ˆä¸èƒ½ä½¿ç”¨åŒä¸€ä¸ªå…ƒç´ ä¸¤æ¬¡ï¼‰
3. <strong>ä»£ç ç®€æ´</strong>ï¼šé€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤</p>

<h2 id="5-ç‰¹æ®Šæƒ…å†µå¤„ç†">5. ç‰¹æ®Šæƒ…å†µå¤„ç†</h2>

<ol>
<li><p><strong>é‡å¤å…ƒç´ </strong>ï¼šå¦‚ nums = [3, 3], target = 6</p>

<ul>
<li>å“ˆå¸Œè¡¨æ³•èƒ½æ­£ç¡®å¤„ç†ï¼Œå› ä¸ºæŸ¥æ‰¾æ—¶æ£€æŸ¥äº†ä¸‹æ ‡æ˜¯å¦ç›¸åŒ</li>
</ul></li>
<li><p><strong>è´Ÿæ•°å’Œå¤§æ•°</strong>ï¼šé¢˜ç›®èŒƒå›´æ˜¯ -10â¹ åˆ° 10â¹</p>

<ul>
<li>å“ˆå¸Œè¡¨æ³•ä¸å—æ•°å€¼èŒƒå›´å½±å“</li>
</ul></li>
<li><p><strong>æ— è§£æƒ…å†µ</strong>ï¼šé¢˜ç›®ä¿è¯æœ‰ä¸”åªæœ‰ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆï¼Œå®é™…åº”ç”¨ä¸­å¯è¿”å›ç©ºæ•°ç»„æˆ–ç‰¹å®šå€¼</p></li>
</ol>

<h2 id="6-è¿›é˜¶æ€è€ƒ">6. è¿›é˜¶æ€è€ƒ</h2>

<p>å¯¹äºæ›´å¤æ‚çš„æƒ…å†µï¼ˆå¦‚éœ€è¦è¿”å›æ‰€æœ‰å¯èƒ½çš„è§£ï¼‰ï¼Œå¯ä»¥è€ƒè™‘ï¼š
1. ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ‰€æœ‰ç›¸åŒå€¼çš„ä¸‹æ ‡åˆ—è¡¨
2. å…ˆæ’åºå†ä½¿ç”¨åŒæŒ‡é’ˆæ³•ï¼ˆä½†éœ€è¦é¢å¤–å¤„ç†ä¸‹æ ‡ä¿¡æ¯ï¼‰</p>

<p><strong>æ€»ç»“</strong>ï¼šä¸¤æ•°ä¹‹å’Œæ˜¯å“ˆå¸Œè¡¨åº”ç”¨çš„ç»å…¸ä¾‹é¢˜ï¼ŒæŒæ¡å“ˆå¸Œè¡¨è§£æ³•å¯¹äºè§£å†³ç±»ä¼¼é—®é¢˜ï¼ˆå¦‚ä¸‰æ•°ä¹‹å’Œã€å››æ•°ä¹‹å’Œï¼‰æœ‰é‡è¦å¸®åŠ©ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 19:05:33</em></p>

<hr />

<h1 id="3613-æœ€å°åŒ–è¿é€šåˆ†é‡çš„æœ€å¤§æˆæœ¬">3613. æœ€å°åŒ–è¿é€šåˆ†é‡çš„æœ€å¤§æˆæœ¬</h1>

<p><strong>éš¾åº¦</strong>: Medium</p>

<p><strong>æ ‡ç­¾</strong>: å¹¶æŸ¥é›†, å›¾, äºŒåˆ†æŸ¥æ‰¾, æ’åº</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/minimize-maximum-component-cost/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-2">é¢˜ç›®æè¿°</h2>

<p data-end="331" data-start="85">ç»™ä½ ä¸€ä¸ªæ— å‘è¿é€šå›¾ï¼ŒåŒ…å« <code data-end="137" data-start="134">n</code> ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ç¼–å·ä» 0 åˆ° <code data-end="171" data-start="164">n - 1</code>ï¼Œä»¥åŠä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ <code data-end="202" data-start="195">edges</code>ï¼Œå…¶ä¸­ <code data-end="234" data-start="209">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> è¡¨ç¤ºä¸€æ¡è¿æ¥èŠ‚ç‚¹ <code data-end="279" data-start="275">u<sub>i</sub></code> å’ŒèŠ‚ç‚¹ <code data-end="293" data-start="289">v<sub>i</sub></code> çš„æ— å‘è¾¹ï¼Œè¾¹æƒä¸º <code data-end="310" data-start="306">w<sub>i</sub></code>ï¼Œå¦æœ‰ä¸€ä¸ªæ•´æ•° <code data-end="330" data-start="327">k</code>ã€‚</p>

<p data-end="461" data-start="333">ä½ å¯ä»¥ä»å›¾ä¸­ç§»é™¤ä»»æ„æ•°é‡çš„è¾¹ï¼Œä½¿å¾—æœ€ç»ˆçš„å›¾ä¸­&nbsp;<strong>æœ€å¤š&nbsp;</strong>åªåŒ…å« <code data-end="439" data-start="436">k</code> ä¸ªè¿é€šåˆ†é‡ã€‚</p>

<p data-end="589" data-start="463">è¿é€šåˆ†é‡çš„ <strong>æˆæœ¬&nbsp;</strong>å®šä¹‰ä¸ºè¯¥åˆ†é‡ä¸­è¾¹æƒçš„&nbsp;<strong>æœ€å¤§å€¼&nbsp;</strong>ã€‚å¦‚æœä¸€ä¸ªè¿é€šåˆ†é‡æ²¡æœ‰è¾¹ï¼Œåˆ™å…¶ä»£ä»·ä¸º 0ã€‚</p>

<p data-end="760" data-start="661">è¯·è¿”å›åœ¨ç§»é™¤è¿™äº›è¾¹ä¹‹åï¼Œåœ¨æ‰€æœ‰è¿é€šåˆ†é‡ä¹‹ä¸­çš„&nbsp;<strong>æœ€å¤§æˆæœ¬&nbsp;</strong>çš„&nbsp;<strong>æœ€å°å¯èƒ½å€¼&nbsp;</strong>ã€‚</p>

<p>&nbsp;</p>

<p><strong class="example">ç¤ºä¾‹ 1ï¼š</strong></p>

<div class="example-block">
<p><strong>è¾“å…¥ï¼š</strong> <span class="example-io">n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2</span></p>

<p><strong>è¾“å‡ºï¼š</strong> <span class="example-io">4</span></p>

<p><strong>è§£é‡Šï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minimizemaximumm.jpg" style="width: 535px; height: 225px;" /></p>

<ul>
    <li data-end="1070" data-start="1021">ç§»é™¤èŠ‚ç‚¹ 3 å’ŒèŠ‚ç‚¹ 4 ä¹‹é—´çš„è¾¹ï¼ˆæƒå€¼ä¸º 6ï¼‰ã€‚</li>
    <li data-end="1141" data-start="1073">æœ€ç»ˆçš„è¿é€šåˆ†é‡æˆæœ¬åˆ†åˆ«ä¸º 0 å’Œ 4ï¼Œå› æ­¤æœ€å¤§ä»£ä»·ä¸º 4ã€‚</li>
</ul>
</div>

<p><strong class="example">ç¤ºä¾‹ 2ï¼š</strong></p>

<div class="example-block">
<p><strong>è¾“å…¥ï¼š</strong> <span class="example-io">n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1</span></p>

<p><strong>è¾“å‡ºï¼š</strong> <span class="example-io">5</span></p>

<p><strong>è§£é‡Šï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minmax2.jpg" style="width: 315px; height: 55px;" /></p>

<ul>
    <li data-end="1315" data-start="1251">æ— æ³•ç§»é™¤ä»»ä½•è¾¹ï¼Œå› ä¸ºåªå…è®¸ä¸€ä¸ªè¿é€šåˆ†é‡ï¼ˆ<code>k = 1</code>ï¼‰ï¼Œå›¾å¿…é¡»ä¿æŒå®Œå…¨è¿é€šã€‚</li>
    <li data-end="1389" data-start="1318">è¯¥è¿é€šåˆ†é‡çš„æˆæœ¬ç­‰äºå…¶æœ€å¤§è¾¹æƒï¼Œå³ 5ã€‚</li>
</ul>
</div>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
    <li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
    <li><code>edges[i].length == 3</code></li>
    <li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
    <li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
    <li><code>1 &lt;= k &lt;= n</code></li>
    <li>è¾“å…¥å›¾æ˜¯è¿é€šå›¾ã€‚</li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-2">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-2">C++</h3>

<pre><code>class Solution {
public:
    int minCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k) {

    }
};
</code></pre>

<h3 id="java-2">Java</h3>

<pre><code>class Solution {
    public int minCost(int n, int[][] edges, int k) {

    }
}
</code></pre>

<h3 id="python3-2">Python3</h3>

<pre><code>class Solution:
    def minCost(self, n: int, edges: List[List[int]], k: int) -&gt; int:

</code></pre>

<h3 id="javascript-2">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} k
 * @return {number}
 */
var minCost = function(n, edges, k) {

};
</code></pre>

<h3 id="go-2">Go</h3>

<pre><code>func minCost(n int, edges [][]int, k int) int {

}
</code></pre>

<hr />

<h2 id="æç¤º-2">æç¤º</h2>

<ol>
<li>Sort the <code>edges</code> and do binary search on the candidate maximum weight</li>
<li>Use <code>DFS</code> or <code>DSU</code> to count the number of connected components when keeping only edges with weight &lt;= mid</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-2">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>5
[[0,1,4],[1,2,3],[1,3,2],[3,4,6]]
2
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-2">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ª<strong>æœ€å°åŒ–æœ€å¤§å€¼</strong>é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æœ€å¤šä¿ç•™ k ä¸ªè¿é€šåˆ†é‡çš„å‰æä¸‹ï¼Œé€šè¿‡åˆ é™¤è¾¹æ¥æœ€å°åŒ–æ‰€æœ‰è¿é€šåˆ†é‡ä¸­è¾¹æƒæœ€å¤§å€¼çš„æœ€å¤§å€¼ã€‚</p>

<p><strong>å…³é”®ç‚¹</strong>ï¼š
1. åˆå§‹å›¾æ˜¯è¿é€šçš„ï¼ˆn ä¸ªèŠ‚ç‚¹ï¼Œ1 ä¸ªè¿é€šåˆ†é‡ï¼‰
2. åˆ é™¤è¾¹ä¼šå¢åŠ è¿é€šåˆ†é‡æ•°é‡
3. æ¯ä¸ªè¿é€šåˆ†é‡çš„æˆæœ¬ = è¯¥åˆ†é‡ä¸­æ‰€æœ‰è¾¹çš„æœ€å¤§è¾¹æƒï¼ˆå¦‚æœæ²¡æœ‰è¾¹åˆ™ä¸º 0ï¼‰
4. æœ€ç»ˆè¿é€šåˆ†é‡æ•° â‰¤ k
5. ç›®æ ‡æ˜¯<strong>æœ€å°åŒ–æ‰€æœ‰è¿é€šåˆ†é‡æˆæœ¬çš„æœ€å¤§å€¼</strong></p>

<h2 id="è§£é¢˜æ€è·¯">è§£é¢˜æ€è·¯</h2>

<h3 id="æ ¸å¿ƒè§‚å¯Ÿ">æ ¸å¿ƒè§‚å¯Ÿ</h3>

<ul>
<li>å¦‚æœæˆ‘ä»¬è®¾å®šä¸€ä¸ªé˜ˆå€¼ <code>x</code>ï¼Œåªä¿ç•™è¾¹æƒ â‰¤ <code>x</code> çš„è¾¹ï¼Œé‚£ä¹ˆï¼š
<ul>
<li>æ¯ä¸ªè¿é€šåˆ†é‡çš„æˆæœ¬ â‰¤ <code>x</code></li>
<li>åˆ é™¤è¾¹æƒ &gt; <code>x</code> çš„è¾¹ä¼šå¢åŠ è¿é€šåˆ†é‡æ•°é‡</li>
</ul></li>
<li>é—®é¢˜è½¬åŒ–ä¸ºï¼šæ‰¾åˆ°æœ€å°çš„ <code>x</code>ï¼Œä½¿å¾—åˆ é™¤æ‰€æœ‰è¾¹æƒ &gt; <code>x</code> çš„è¾¹åï¼Œè¿é€šåˆ†é‡æ•° â‰¤ k</li>
</ul>

<h3 id="è½¬åŒ–ä¸ºåˆ¤å®šé—®é¢˜">è½¬åŒ–ä¸ºåˆ¤å®šé—®é¢˜</h3>

<p>å¯¹äºç»™å®šçš„ <code>x</code>ï¼š
1. åªè€ƒè™‘è¾¹æƒ â‰¤ <code>x</code> çš„è¾¹æ„å»ºå­å›¾
2. è®¡ç®—è¯¥å­å›¾çš„è¿é€šåˆ†é‡æ•° <code>cnt</code>
3. å¦‚æœ <code>cnt â‰¤ k</code>ï¼Œåˆ™ <code>x</code> å¯è¡Œï¼ˆå› ä¸ºå¯ä»¥è¿›ä¸€æ­¥åˆ é™¤è¾¹æ¥å¢åŠ åˆ†é‡ï¼Œä½†ä¸ä¼šå¢åŠ æˆæœ¬ï¼‰</p>

<h3 id="è§£æ³•é€‰æ‹©">è§£æ³•é€‰æ‹©</h3>

<ol>
<li><strong>äºŒåˆ†ç­”æ¡ˆ + å¹¶æŸ¥é›†</strong>ï¼ˆæœ€ä¼˜è§£ï¼‰</li>
<li><strong>Kruskal å˜ç§</strong>ï¼ˆç±»ä¼¼æœ€å°ç”Ÿæˆæ ‘æ€æƒ³ï¼‰</li>
<li><strong>DFS/BFS è®¡æ•°</strong>ï¼ˆé…åˆäºŒåˆ†ï¼‰</li>
</ol>

<h2 id="è§£æ³•ä¸€äºŒåˆ†ç­”æ¡ˆ-å¹¶æŸ¥é›†">è§£æ³•ä¸€ï¼šäºŒåˆ†ç­”æ¡ˆ + å¹¶æŸ¥é›†</h2>

<h3 id="æ€è·¯">æ€è·¯</h3>

<ol>
<li>å¯¹è¾¹æƒè¿›è¡Œæ’åºï¼ˆç”¨äºäºŒåˆ†ï¼‰</li>
<li>äºŒåˆ†æŸ¥æ‰¾æœ€å°çš„ <code>x</code>ï¼Œä½¿å¾—åªä½¿ç”¨è¾¹æƒ â‰¤ <code>x</code> çš„è¾¹æ—¶ï¼Œè¿é€šåˆ†é‡æ•° â‰¤ k</li>
<li>ä½¿ç”¨å¹¶æŸ¥é›†å¿«é€Ÿè®¡ç®—è¿é€šåˆ†é‡æ•°</li>
</ol>

<h3 id="å¤æ‚åº¦">å¤æ‚åº¦</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO((E + n) log W)ï¼ŒW æ˜¯æœ€å¤§è¾¹æƒ</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(n)</li>
</ul>

<h3 id="ä»£ç å®ç°">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°">Go å®ç°</h4>

<pre><code>func minMaxCost(n int, edges [][]int, k int) int {
    // è¾¹æƒèŒƒå›´
    left, right := 0, 0
    for _, e := range edges {
        if e[2] &gt; right {
            right = e[2]
        }
    }

    // äºŒåˆ†ç­”æ¡ˆ
    ans := right
    for left &lt;= right {
        mid := left + (right-left)/2
        if check(n, edges, k, mid) {
            ans = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return ans
}

func check(n int, edges [][]int, k int, limit int) bool {
    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    parent := make([]int, n)
    for i := 0; i &lt; n; i++ {
        parent[i] = i
    }

    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    union := func(x, y int) {
        px, py := find(x), find(y)
        if px != py {
            parent[px] = py
        }
    }

    // åªè¿æ¥è¾¹æƒ &lt;= limit çš„è¾¹
    for _, e := range edges {
        if e[2] &lt;= limit {
            union(e[0], e[1])
        }
    }

    // è®¡ç®—è¿é€šåˆ†é‡æ•°
    components := 0
    for i := 0; i &lt; n; i++ {
        if find(i) == i {
            components++
        }
    }

    return components &lt;= k
}
</code></pre>

<h4 id="c-å®ç°">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int minMaxCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k) {
        int left = 0, right = 0;
        for (auto&amp; e : edges) {
            right = max(right, e[2]);
        }

        int ans = right;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            if (check(n, edges, k, mid)) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

private:
    bool check(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k, int limit) {
        vector&lt;int&gt; parent(n);
        iota(parent.begin(), parent.end(), 0);

        function&lt;int(int)&gt; find = [&amp;](int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        };

        auto unionSet = [&amp;](int x, int y) {
            int px = find(x), py = find(y);
            if (px != py) {
                parent[px] = py;
            }
        };

        for (auto&amp; e : edges) {
            if (e[2] &lt;= limit) {
                unionSet(e[0], e[1]);
            }
        }

        int components = 0;
        for (int i = 0; i &lt; n; i++) {
            if (find(i) == i) {
                components++;
            }
        }

        return components &lt;= k;
    }
};
</code></pre>

<h2 id="è§£æ³•äºŒkruskal-å˜ç§è´ªå¿ƒ">è§£æ³•äºŒï¼šKruskal å˜ç§ï¼ˆè´ªå¿ƒï¼‰</h2>

<h3 id="æ€è·¯-2">æ€è·¯</h3>

<ol>
<li>å°†è¾¹æŒ‰æƒå€¼ä»å°åˆ°å¤§æ’åº</li>
<li>ä½¿ç”¨ Kruskal ç®—æ³•é€æ­¥æ·»åŠ è¾¹</li>
<li>å½“æ·»åŠ ä¸€æ¡è¾¹ä¼šå‡å°‘è¿é€šåˆ†é‡æ•°æ—¶ï¼Œè®°å½•å½“å‰è¿é€šåˆ†é‡æ•°</li>
<li>æ‰¾åˆ°æ»¡è¶³è¿é€šåˆ†é‡æ•° â‰¤ k çš„æœ€å°è¾¹æƒ</li>
</ol>

<h3 id="å¤æ‚åº¦-2">å¤æ‚åº¦</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO(E log E + E Î±(n))</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(n)</li>
</ul>

<h3 id="ä»£ç å®ç°-2">ä»£ç å®ç°</h3>

<h4 id="go-å®ç°-2">Go å®ç°</h4>

<pre><code>func minMaxCost(n int, edges [][]int, k int) int {
    // æŒ‰è¾¹æƒæ’åº
    sort.Slice(edges, func(i, j int) bool {
        return edges[i][2] &lt; edges[j][2]
    })

    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    parent := make([]int, n)
    for i := 0; i &lt; n; i++ {
        parent[i] = i
    }

    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    union := func(x, y int) bool {
        px, py := find(x), find(y)
        if px == py {
            return false
        }
        parent[px] = py
        return true
    }

    // åˆå§‹è¿é€šåˆ†é‡æ•°
    components := n

    // ç‰¹æ®Šæƒ…å†µï¼šä¸éœ€è¦è¾¹
    if components &lt;= k {
        return 0
    }

    // é€æ­¥æ·»åŠ è¾¹
    for _, e := range edges {
        if union(e[0], e[1]) {
            components--
            if components &lt;= k {
                return e[2]
            }
        }
    }

    // å¦‚æœæ‰€æœ‰è¾¹éƒ½æ·»åŠ åä»ç„¶ &gt; kï¼Œè¿”å›æœ€å¤§è¾¹æƒ
    return edges[len(edges)-1][2]
}
</code></pre>

<h4 id="c-å®ç°-2">C++ å®ç°</h4>

<pre><code>class Solution {
public:
    int minMaxCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int k) {
        // æŒ‰è¾¹æƒæ’åº
        sort(edges.begin(), edges.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
            return a[2] &lt; b[2];
        });

        vector&lt;int&gt; parent(n);
        iota(parent.begin(), parent.end(), 0);

        function&lt;int(int)&gt; find = [&amp;](int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        };

        auto unionSet = [&amp;](int x, int y) -&gt; bool {
            int px = find(x), py = find(y);
            if (px == py) return false;
            parent[px] = py;
            return true;
        };

        int components = n;

        // ç‰¹æ®Šæƒ…å†µ
        if (components &lt;= k) return 0;

        for (auto&amp; e : edges) {
            if (unionSet(e[0], e[1])) {
                components--;
                if (components &lt;= k) {
                    return e[2];
                }
            }
        }

        return edges.back()[2];
    }
};
</code></pre>

<h2 id="è§£æ³•ä¸‰äºŒåˆ†ç­”æ¡ˆ-dfsbfs">è§£æ³•ä¸‰ï¼šäºŒåˆ†ç­”æ¡ˆ + DFS/BFS</h2>

<h3 id="æ€è·¯-3">æ€è·¯</h3>

<ol>
<li>äºŒåˆ†ç­”æ¡ˆ</li>
<li>å¯¹äºæ¯ä¸ª midï¼Œæ„å»ºåªåŒ…å«è¾¹æƒ â‰¤ mid çš„å›¾</li>
<li>ä½¿ç”¨ DFS/BFS è®¡ç®—è¿é€šåˆ†é‡æ•°</li>
</ol>

<h3 id="å¤æ‚åº¦-3">å¤æ‚åº¦</h3>

<ul>
<li>æ—¶é—´å¤æ‚åº¦ï¼šO((E + n) log W)</li>
<li>ç©ºé—´å¤æ‚åº¦ï¼šO(E + n)</li>
</ul>

<h3 id="ä»£ç å®ç°go">ä»£ç å®ç°ï¼ˆGoï¼‰</h3>

<pre><code>func minMaxCost(n int, edges [][]int, k int) int {
    // æ„å»ºé‚»æ¥è¡¨ï¼ˆç”¨äºDFS/BFSï¼‰
    maxWeight := 0
    for _, e := range edges {
        if e[2] &gt; maxWeight {
            maxWeight = e[2]
        }
    }

    left, right := 0, maxWeight
    ans := right

    for left &lt;= right {
        mid := left + (right-left)/2

        // æ„å»ºé‚»æ¥è¡¨ï¼ˆåªåŒ…å«è¾¹æƒ &lt;= mid çš„è¾¹ï¼‰
        adj := make([][]int, n)
        for _, e := range edges {
            if e[2] &lt;= mid {
                adj[e[0]] = append(adj[e[0]], e[1])
                adj[e[1]] = append(adj[e[1]], e[0])
            }
        }

        // DFSè®¡ç®—è¿é€šåˆ†é‡æ•°
        visited := make([]bool, n)
        components := 0
        for i := 0; i &lt; n; i++ {
            if !visited[i] {
                components++
                dfs(i, adj, visited)
            }
        }

        if components &lt;= k {
            ans = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }

    return ans
}

func dfs(node int, adj [][]int, visited []bool) {
    visited[node] = true
    for _, neighbor := range adj[node] {
        if !visited[neighbor] {
            dfs(neighbor, adj, visited)
        }
    }
}
</code></pre>

<h2 id="è§£æ³•å¯¹æ¯”">è§£æ³•å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>ç‰¹æ€§</th>
  <th>äºŒåˆ†+å¹¶æŸ¥é›†</th>
  <th>Kruskalå˜ç§</th>
  <th>äºŒåˆ†+DFS/BFS</th>
</tr>
</thead>
<tbody>
<tr>
  <td>æ—¶é—´å¤æ‚åº¦</td>
  <td>O((E+n)logW)</td>
  <td>O(ElogE + EÎ±(n))</td>
  <td>O((E+n)logW)</td>
</tr>
<tr>
  <td>ç©ºé—´å¤æ‚åº¦</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>O(E+n)</td>
</tr>
<tr>
  <td>å®ç°éš¾åº¦</td>
  <td>ç®€å•</td>
  <td>ç®€å•</td>
  <td>ä¸­ç­‰</td>
</tr>
<tr>
  <td>é€‚ç”¨åœºæ™¯</td>
  <td>é€šç”¨</td>
  <td>è¾¹å·²æ’åºæˆ–éœ€è¦æ’åº</td>
  <td>éœ€è¦æ˜¾å¼å›¾ç»“æ„</td>
</tr>
<tr>
  <td>ä¼˜ç‚¹</td>
  <td>ç¨³å®šé«˜æ•ˆ</td>
  <td>ç›´è§‚ï¼Œä¸€æ¬¡éå†</td>
  <td>ä¸éœ€è¦å¹¶æŸ¥é›†</td>
</tr>
<tr>
  <td>ç¼ºç‚¹</td>
  <td>éœ€è¦äºŒåˆ†</td>
  <td>å¿…é¡»æ’åºæ‰€æœ‰è¾¹</td>
  <td>éœ€è¦æ„å»ºå›¾ï¼Œç©ºé—´å¤§</td>
</tr>
</tbody>
</table>

<h2 id="æ¨èè§£æ³•">æ¨èè§£æ³•</h2>

<p><strong>è§£æ³•ä¸€ï¼ˆäºŒåˆ†+å¹¶æŸ¥é›†ï¼‰æ˜¯æœ€æ¨èçš„</strong>ï¼Œå› ä¸ºï¼š
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜
2. ç©ºé—´å¤æ‚åº¦ä½
3. å®ç°ç®€å•ç›´è§‚
4. é€‚ç”¨äºå„ç§è§„æ¨¡çš„è¾“å…¥</p>

<p><strong>è§£æ³•äºŒï¼ˆKruskalå˜ç§ï¼‰</strong> ä¹Ÿå¾ˆä¼˜ç§€ï¼Œç‰¹åˆ«æ˜¯å½“è¾¹å·²ç»æ’åºæˆ–éœ€è¦æ’åºæ—¶ï¼Œå®ƒæ›´ç›´è§‚ã€‚</p>

<p><strong>è§£æ³•ä¸‰</strong> åœ¨éœ€è¦æ˜¾å¼å›¾ç»“æ„æ—¶æœ‰ç”¨ï¼Œä½†ç©ºé—´å¼€é”€è¾ƒå¤§ã€‚</p>

<p>åœ¨å®é™… LeetCode æäº¤ä¸­ï¼Œè§£æ³•ä¸€å’Œè§£æ³•äºŒéƒ½æ˜¯å¯è¡Œçš„ï¼Œè§£æ³•ä¸€é€šå¸¸æ›´å¿«ä¸€äº›ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 19:06:37</em></p>

<hr />

<h1 id="2092-æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶">2092. æ‰¾å‡ºçŸ¥æ™“ç§˜å¯†çš„æ‰€æœ‰ä¸“å®¶</h1>

<p><strong>éš¾åº¦</strong>: Hard</p>

<p><strong>æ ‡ç­¾</strong>: æ·±åº¦ä¼˜å…ˆæœç´¢, å¹¿åº¦ä¼˜å…ˆæœç´¢, å¹¶æŸ¥é›†, å›¾, æ’åº</p>

<p><strong>é“¾æ¥</strong>: https://leetcode.cn/problems/find-all-people-with-secret/</p>

<hr />

<h2 id="é¢˜ç›®æè¿°-3">é¢˜ç›®æè¿°</h2>

<p>ç»™ä½ ä¸€ä¸ªæ•´æ•° <code>n</code> ï¼Œè¡¨ç¤ºæœ‰ <code>n</code> ä¸ªä¸“å®¶ä» <code>0</code> åˆ° <code>n - 1</code> ç¼–å·ã€‚å¦å¤–ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„äºŒç»´æ•´æ•°æ•°ç»„ <code>meetings</code> ï¼Œå…¶ä¸­ <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> è¡¨ç¤ºä¸“å®¶ <code>x<sub>i</sub></code> å’Œä¸“å®¶ <code>y<sub>i</sub></code> åœ¨æ—¶é—´ <code>time<sub>i</sub></code> è¦å¼€ä¸€åœºä¼šã€‚ä¸€ä¸ªä¸“å®¶å¯ä»¥åŒæ—¶å‚åŠ  <strong>å¤šåœºä¼šè®®</strong> ã€‚æœ€åï¼Œç»™ä½ ä¸€ä¸ªæ•´æ•° <code>firstPerson</code> ã€‚</p>

<p>ä¸“å®¶ <code>0</code> æœ‰ä¸€ä¸ª <strong>ç§˜å¯†</strong> ï¼Œæœ€åˆï¼Œä»–åœ¨æ—¶é—´&nbsp;<code>0</code> å°†è¿™ä¸ªç§˜å¯†åˆ†äº«ç»™äº†ä¸“å®¶ <code>firstPerson</code> ã€‚æ¥ç€ï¼Œè¿™ä¸ªç§˜å¯†ä¼šåœ¨æ¯æ¬¡æœ‰çŸ¥æ™“è¿™ä¸ªç§˜å¯†çš„ä¸“å®¶å‚åŠ ä¼šè®®æ—¶è¿›è¡Œä¼ æ’­ã€‚æ›´æ­£å¼çš„è¡¨è¾¾æ˜¯ï¼Œæ¯æ¬¡ä¼šè®®ï¼Œå¦‚æœä¸“å®¶ <code>x<sub>i</sub></code> åœ¨æ—¶é—´ <code>time<sub>i</sub></code> æ—¶çŸ¥æ™“è¿™ä¸ªç§˜å¯†ï¼Œé‚£ä¹ˆä»–å°†ä¼šä¸ä¸“å®¶ <code>y<sub>i</sub></code> åˆ†äº«è¿™ä¸ªç§˜å¯†ï¼Œåä¹‹äº¦ç„¶ã€‚</p>

<p>ç§˜å¯†å…±äº«æ˜¯ <strong>ç¬æ—¶å‘ç”Ÿ</strong> çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨åŒä¸€æ—¶é—´ï¼Œä¸€ä¸ªä¸“å®¶ä¸å…‰å¯ä»¥æ¥æ”¶åˆ°ç§˜å¯†ï¼Œè¿˜èƒ½åœ¨å…¶ä»–ä¼šè®®ä¸Šä¸å…¶ä»–ä¸“å®¶åˆ†äº«ã€‚</p>

<p>åœ¨æ‰€æœ‰ä¼šè®®éƒ½ç»“æŸä¹‹åï¼Œè¿”å›æ‰€æœ‰çŸ¥æ™“è¿™ä¸ªç§˜å¯†çš„ä¸“å®¶åˆ—è¡¨ã€‚ä½ å¯ä»¥æŒ‰ <strong>ä»»ä½•é¡ºåº</strong> è¿”å›ç­”æ¡ˆã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>è¾“å‡ºï¼š</strong>[0,1,2,3,5]
<strong>è§£é‡Šï¼š
</strong>æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 1 å…±äº«ã€‚
æ—¶é—´ 5 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 2 å…±äº«ã€‚
æ—¶é—´ 8 ï¼Œä¸“å®¶ 2 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ—¶é—´ 10 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 5 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1ã€2ã€3 å’Œ 5 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>è¾“å‡ºï¼š</strong>[0,1,3]
<strong>è§£é‡Šï¼š</strong>
æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ—¶é—´ 2 ï¼Œä¸“å®¶ 1 ä¸ä¸“å®¶ 2 éƒ½ä¸çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
æ—¶é—´ 3 ï¼Œä¸“å®¶ 3 å°†ç§˜å¯†ä¸ä¸“å®¶ 0 å’Œä¸“å®¶ 1 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1 å’Œ 3 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>è¾“å‡ºï¼š</strong>[0,1,2,3,4]
<strong>è§£é‡Šï¼š</strong>
æ—¶é—´ 0 ï¼Œä¸“å®¶ 0 å°†ç§˜å¯†ä¸ä¸“å®¶ 1 å…±äº«ã€‚
æ—¶é—´ 1 ï¼Œä¸“å®¶ 1 å°†ç§˜å¯†ä¸ä¸“å®¶ 2 å…±äº«ï¼Œä¸“å®¶ 2 å°†ç§˜å¯†ä¸ä¸“å®¶ 3 å…±äº«ã€‚
æ³¨æ„ï¼Œä¸“å®¶ 2 å¯ä»¥åœ¨æ”¶åˆ°ç§˜å¯†çš„åŒä¸€æ—¶é—´åˆ†äº«æ­¤ç§˜å¯†ã€‚
æ—¶é—´ 2 ï¼Œä¸“å®¶ 3 å°†ç§˜å¯†ä¸ä¸“å®¶ 4 å…±äº«ã€‚
å› æ­¤ï¼Œåœ¨æ‰€æœ‰ä¼šè®®ç»“æŸåï¼Œä¸“å®¶ 0ã€1ã€2ã€3 å’Œ 4 éƒ½å°†çŸ¥æ™“è¿™ä¸ªç§˜å¯†ã€‚</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
    <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
    <li><code>meetings[i].length == 3</code></li>
    <li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
    <li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
    <li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>

<hr />

<h2 id="ä»£ç æ¨¡æ¿-3">ä»£ç æ¨¡æ¿</h2>

<h3 id="c-3">C++</h3>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {

    }
};
</code></pre>

<h3 id="java-3">Java</h3>

<pre><code>class Solution {
    public List&lt;Integer&gt; findAllPeople(int n, int[][] meetings, int firstPerson) {

    }
}
</code></pre>

<h3 id="python3-3">Python3</h3>

<pre><code>class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -&gt; List[int]:

</code></pre>

<h3 id="javascript-3">JavaScript</h3>

<pre><code>/**
 * @param {number} n
 * @param {number[][]} meetings
 * @param {number} firstPerson
 * @return {number[]}
 */
var findAllPeople = function(n, meetings, firstPerson) {

};
</code></pre>

<h3 id="go-3">Go</h3>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {

}
</code></pre>

<hr />

<h2 id="æç¤º-3">æç¤º</h2>

<ol>
<li>Could you model all the meetings happening at the same time as a graph?</li>
<li>What data structure can you use to efficiently share the secret?</li>
<li>You can use the union-find data structure to quickly determine who knows the secret and share the secret.</li>
</ol>

<hr />

<h2 id="ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹-3">ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹</h2>

<pre><code>6
[[1,2,5],[2,3,8],[1,5,10]]
1
</code></pre>

<hr />

<h2 id="ai-è§£ç­”-deepseek-3">AI è§£ç­” (DeepSeek)</h2>

<h2 id="é¢˜ç›®åˆ†æ-2">é¢˜ç›®åˆ†æ</h2>

<p>è¿™æ˜¯ä¸€ä¸ª<strong>æ—¶é—´ä¾èµ–çš„å›¾ä¼ æ’­é—®é¢˜</strong>ã€‚ä¸“å®¶æ˜¯èŠ‚ç‚¹ï¼Œä¼šè®®æ˜¯è¾¹ï¼Œä½†è¾¹åªåœ¨ç‰¹å®šæ—¶é—´ç‚¹æœ‰æ•ˆã€‚ç§˜å¯†ä»ä¸“å®¶0å’ŒfirstPersonå¼€å§‹ï¼Œé€šè¿‡ä¼šè®®åœ¨ä¸“å®¶é—´ä¼ æ’­ã€‚å…³é”®ç‚¹ï¼š
- ä¼šè®®æŒ‰æ—¶é—´é¡ºåºå‘ç”Ÿ
- åŒä¸€æ—¶é—´å¯èƒ½æœ‰å¤šä¸ªä¼šè®®åŒæ—¶è¿›è¡Œ
- ç§˜å¯†ä¼ æ’­æ˜¯ç¬æ—¶çš„ï¼ˆåŒä¸€æ—¶é—´å¯ä»¥ä¼ æ’­å¤šæ¬¡ï¼‰</p>

<h2 id="è§£é¢˜æ€è·¯-2">è§£é¢˜æ€è·¯</h2>

<p>æ ¸å¿ƒæ€æƒ³ï¼š<strong>æŒ‰æ—¶é—´åˆ†ç»„å¤„ç†ä¼šè®®</strong>ï¼Œå¯¹æ¯ä¸ªæ—¶é—´ç‚¹çš„ä¼šè®®é›†åˆï¼Œä½¿ç”¨å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰æ¥åˆå¹¶çŸ¥æ™“ç§˜å¯†çš„ä¸“å®¶ã€‚</p>

<h3 id="å…³é”®è§‚å¯Ÿ">å…³é”®è§‚å¯Ÿ</h3>

<ol>
<li>åŒä¸€æ—¶é—´ç‚¹çš„ä¼šè®®å¯ä»¥ä»»æ„é¡ºåºå‘ç”Ÿï¼Œç§˜å¯†å¯ä»¥åœ¨è¿™äº›ä¼šè®®ä¸­ä¼ æ’­</li>
<li>ä¸åŒæ—¶é—´ç‚¹çš„ä¼šè®®éœ€è¦æŒ‰æ—¶é—´é¡ºåºå¤„ç†</li>
<li>å¦‚æœä¸€ç»„ä¸“å®¶åœ¨åŒä¸€æ—¶é—´é€šè¿‡ä¼šè®®è¿é€šï¼Œä¸”å…¶ä¸­è‡³å°‘ä¸€äººçŸ¥æ™“ç§˜å¯†ï¼Œåˆ™æ•´ç»„éƒ½ä¼šçŸ¥æ™“</li>
</ol>

<h2 id="è§£æ³•ä¸€æŒ‰æ—¶é—´åˆ†ç»„-å¹¶æŸ¥é›†æ¨è">è§£æ³•ä¸€ï¼šæŒ‰æ—¶é—´åˆ†ç»„ + å¹¶æŸ¥é›†ï¼ˆæ¨èï¼‰</h2>

<h3 id="æ€è·¯-4">æ€è·¯</h3>

<ol>
<li>æŒ‰ä¼šè®®æ—¶é—´åˆ†ç»„</li>
<li>å¯¹æ¯ä¸ªæ—¶é—´ç‚¹çš„ä¼šè®®ï¼š
<ul>
<li>ç”¨å¹¶æŸ¥é›†è¿æ¥å‚ä¼šä¸“å®¶</li>
<li>æ£€æŸ¥æ¯ä¸ªè¿é€šåˆ†é‡ï¼šå¦‚æœåŒ…å«å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶ï¼Œæ ‡è®°æ•´ä¸ªåˆ†é‡ä¸ºçŸ¥æ™“ç§˜å¯†</li>
</ul></li>
<li>å¤„ç†å®Œä¸€ä¸ªæ—¶é—´ç‚¹åï¼Œé‡ç½®å¹¶æŸ¥é›†ï¼ˆåªä¿ç•™çŸ¥æ™“ç§˜å¯†çš„çŠ¶æ€ï¼‰</li>
</ol>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æŒ‰æ—¶é—´åˆ†ç»„ä¼šè®®
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        x, y, t := meeting[0], meeting[1], meeting[2]
        timeMap[t] = append(timeMap[t], [2]int{x, y})
    }

    // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true

    // è·å–æ‰€æœ‰æ—¶é—´ç‚¹å¹¶æ’åº
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)

    for _, t := range times {
        meetingsAtTime := timeMap[t]

        // æ„å»ºå½“å‰æ—¶é—´ç‚¹çš„å›¾
        graph := make(map[int][]int)
        experts := make(map[int]bool)

        for _, meeting := range meetingsAtTime {
            x, y := meeting[0], meeting[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
            experts[x] = true
            experts[y] = true
        }

        // BFSä¼ æ’­ç§˜å¯†
        queue := make([]int, 0)
        visited := make(map[int]bool)

        // å°†æ‰€æœ‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶åŠ å…¥é˜Ÿåˆ—
        for expert := range experts {
            if known[expert] &amp;&amp; !visited[expert] {
                queue = append(queue, expert)
                visited[expert] = true
            }
        }

        // BFSéå†
        for len(queue) &gt; 0 {
            curr := queue[0]
            queue = queue[1:]

            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }

    // æ”¶é›†ç»“æœ
    result := make([]int, 0)
    for i := 0; i &lt; n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
</code></pre>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æŒ‰æ—¶é—´åˆ†ç»„ä¼šè®®
        map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; timeMap;
        for (auto&amp; meeting : meetings) {
            int x = meeting[0], y = meeting[1], t = meeting[2];
            timeMap[t].push_back({x, y});
        }

        // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
        vector&lt;bool&gt; known(n, false);
        known[0] = true;
        known[firstPerson] = true;

        for (auto&amp; [time, meetingsAtTime] : timeMap) {
            // æ„å»ºå½“å‰æ—¶é—´ç‚¹çš„å›¾
            unordered_map&lt;int, vector&lt;int&gt;&gt; graph;
            unordered_set&lt;int&gt; experts;

            for (auto&amp; [x, y] : meetingsAtTime) {
                graph[x].push_back(y);
                graph[y].push_back(x);
                experts.insert(x);
                experts.insert(y);
            }

            // BFSä¼ æ’­ç§˜å¯†
            queue&lt;int&gt; q;
            unordered_set&lt;int&gt; visited;

            // å°†æ‰€æœ‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶åŠ å…¥é˜Ÿåˆ—
            for (int expert : experts) {
                if (known[expert] &amp;&amp; !visited.count(expert)) {
                    q.push(expert);
                    visited.insert(expert);
                }
            }

            // BFSéå†
            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }

        // æ”¶é›†ç»“æœ
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(T + M + N)ï¼Œå…¶ä¸­Tæ˜¯ä¸åŒæ—¶é—´ç‚¹æ•°é‡ï¼ŒMæ˜¯ä¼šè®®æ•°ï¼ŒNæ˜¯ä¸“å®¶æ•°
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N + M)</p>

<h2 id="è§£æ³•äºŒå¹¶æŸ¥é›†-æ—¶é—´æ’åºä¼˜åŒ–">è§£æ³•äºŒï¼šå¹¶æŸ¥é›† + æ—¶é—´æ’åºä¼˜åŒ–</h2>

<h3 id="æ€è·¯-5">æ€è·¯</h3>

<p>ä½¿ç”¨å¹¶æŸ¥é›†ï¼Œä½†åœ¨æ¯ä¸ªæ—¶é—´ç‚¹å¤„ç†å®Œåï¼Œéœ€è¦é‡ç½®é‚£äº›ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶çš„è¿æ¥çŠ¶æ€ã€‚</p>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æŒ‰æ—¶é—´æ’åºä¼šè®®
    sort.Slice(meetings, func(i, j int) bool {
        return meetings[i][2] &lt; meetings[j][2]
    })

    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    parent := make([]int, n)
    for i := range parent {
        parent[i] = i
    }

    // åˆå¹¶0å’ŒfirstPerson
    union(parent, 0, firstPerson)

    i := 0
    m := len(meetings)

    for i &lt; m {
        j := i
        // æ‰¾åˆ°ç›¸åŒæ—¶é—´çš„æ‰€æœ‰ä¼šè®®
        for j &lt; m &amp;&amp; meetings[j][2] == meetings[i][2] {
            j++
        }

        // è¿æ¥å½“å‰æ—¶é—´çš„æ‰€æœ‰ä¸“å®¶
        for k := i; k &lt; j; k++ {
            union(parent, meetings[k][0], meetings[k][1])
        }

        // æ£€æŸ¥å“ªäº›ä¸“å®¶çŸ¥é“äº†ç§˜å¯†
        for k := i; k &lt; j; k++ {
            x, y := meetings[k][0], meetings[k][1]
            if find(parent, x) == find(parent, 0) {
                // è¿™ä¸ªè¿é€šåˆ†é‡çŸ¥é“äº†ç§˜å¯†
            } else {
                // é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
                parent[x] = x
                parent[y] = y
            }
        }

        i = j
    }

    // æ”¶é›†çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
    result := []int{}
    for idx := 0; idx &lt; n; idx++ {
        if find(parent, idx) == find(parent, 0) {
            result = append(result, idx)
        }
    }
    return result
}

func find(parent []int, x int) int {
    if parent[x] != x {
        parent[x] = find(parent, parent[x])
    }
    return parent[x]
}

func union(parent []int, x, y int) {
    rootX := find(parent, x)
    rootY := find(parent, y)
    if rootX != rootY {
        parent[rootY] = rootX
    }
}
</code></pre>

<pre><code>class Solution {
private:
    vector&lt;int&gt; parent;

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootY] = rootX;
        }
    }

public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æŒ‰æ—¶é—´æ’åºä¼šè®®
        sort(meetings.begin(), meetings.end(), 
             [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
                 return a[2] &lt; b[2];
             });

        // åˆå§‹åŒ–å¹¶æŸ¥é›†
        parent.resize(n);
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
        }

        // åˆå¹¶0å’ŒfirstPerson
        unite(0, firstPerson);

        int m = meetings.size();
        for (int i = 0; i &lt; m; ) {
            int j = i;
            // æ‰¾åˆ°ç›¸åŒæ—¶é—´çš„æ‰€æœ‰ä¼šè®®
            while (j &lt; m &amp;&amp; meetings[j][2] == meetings[i][2]) {
                j++;
            }

            // è¿æ¥å½“å‰æ—¶é—´çš„æ‰€æœ‰ä¸“å®¶
            for (int k = i; k &lt; j; k++) {
                unite(meetings[k][0], meetings[k][1]);
            }

            // æ£€æŸ¥å¹¶é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
            for (int k = i; k &lt; j; k++) {
                int x = meetings[k][0], y = meetings[k][1];
                if (find(x) != find(0)) {
                    // é‡ç½®ä¸çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
                    parent[x] = x;
                    parent[y] = y;
                }
            }

            i = j;
        }

        // æ”¶é›†çŸ¥é“ç§˜å¯†çš„ä¸“å®¶
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (find(i) == find(0)) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(M log M + M Î±(N))ï¼Œå…¶ä¸­Î±æ˜¯åé˜¿å…‹æ›¼å‡½æ•°
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N)</p>

<h2 id="è§£æ³•ä¸‰bfsæŒ‰å±‚ä¼ æ’­">è§£æ³•ä¸‰ï¼šBFSæŒ‰å±‚ä¼ æ’­</h2>

<h3 id="æ€è·¯-6">æ€è·¯</h3>

<p>å°†ä¼šè®®æŒ‰æ—¶é—´æ’åºï¼Œä½¿ç”¨BFSæŒ‰æ—¶é—´å±‚ä¼ æ’­ç§˜å¯†ã€‚</p>

<pre><code>func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // æ„å»ºé‚»æ¥è¡¨ï¼šæ—¶é—´ -&gt; [ä¸“å®¶å¯¹]
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        timeMap[meeting[2]] = append(timeMap[meeting[2]], [2]int{meeting[0], meeting[1]})
    }

    // è·å–æ‰€æœ‰æ—¶é—´å¹¶æ’åº
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)

    // å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true

    for _, t := range times {
        // æ„å»ºå½“å‰æ—¶é—´çš„å›¾
        graph := make(map[int][]int)
        for _, pair := range timeMap[t] {
            x, y := pair[0], pair[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
        }

        // BFSé˜Ÿåˆ—
        queue := make([]int, 0)
        visited := make(map[int]bool)

        // æ·»åŠ å½“å‰å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
        for node := range graph {
            if known[node] &amp;&amp; !visited[node] {
                queue = append(queue, node)
                visited[node] = true
            }
        }

        // BFSä¼ æ’­
        for len(queue) &gt; 0 {
            curr := queue[0]
            queue = queue[1:]

            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }

    // æ”¶é›†ç»“æœ
    result := make([]int, 0)
    for i := 0; i &lt; n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
</code></pre>

<pre><code>class Solution {
public:
    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {
        // æ„å»ºæ—¶é—´æ˜ å°„
        map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; timeMap;
        for (auto&amp; meeting : meetings) {
            timeMap[meeting[2]].push_back({meeting[0], meeting[1]});
        }

        vector&lt;bool&gt; known(n, false);
        known[0] = true;
        known[firstPerson] = true;

        for (auto&amp; [time, pairs] : timeMap) {
            // æ„å»ºå½“å‰æ—¶é—´çš„å›¾
            unordered_map&lt;int, vector&lt;int&gt;&gt; graph;
            for (auto&amp; [x, y] : pairs) {
                graph[x].push_back(y);
                graph[y].push_back(x);
            }

            // BFSä¼ æ’­
            queue&lt;int&gt; q;
            unordered_set&lt;int&gt; visited;

            // æ·»åŠ å·²çŸ¥ç§˜å¯†çš„ä¸“å®¶
            for (auto&amp; [node, _] : graph) {
                if (known[node] &amp;&amp; !visited.count(node)) {
                    q.push(node);
                    visited.insert(node);
                }
            }

            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }

        vector&lt;int&gt; result;
        for (int i = 0; i &lt; n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p><strong>æ—¶é—´å¤æ‚åº¦</strong>ï¼šO(T + M + N)
<strong>ç©ºé—´å¤æ‚åº¦</strong>ï¼šO(N + M)</p>

<h2 id="å¤æ‚åº¦å¯¹æ¯”">å¤æ‚åº¦å¯¹æ¯”</h2>

<table>
<thead>
<tr>
  <th>è§£æ³•</th>
  <th>æ—¶é—´å¤æ‚åº¦</th>
  <th>ç©ºé—´å¤æ‚åº¦</th>
  <th>ä¼˜ç‚¹</th>
  <th>ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>è§£æ³•ä¸€</td>
  <td>O(T + M + N)</td>
  <td>O(N + M)</td>
  <td>é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£</td>
  <td>éœ€è¦é¢å¤–å­˜å‚¨æ—¶é—´åˆ†ç»„</td>
</tr>
<tr>
  <td>è§£æ³•äºŒ</td>
  <td>O(M log M + M Î±(N))</td>
  <td>O(N)</td>
  <td>ç©ºé—´æ•ˆç‡é«˜ï¼Œä½¿ç”¨å¹¶æŸ¥é›†</td>
  <td>éœ€è¦é‡ç½®å¹¶æŸ¥é›†çŠ¶æ€</td>
</tr>
<tr>
  <td>è§£æ³•ä¸‰</td>
  <td>O(T + M + N)</td>
  <td>O(N + M)</td>
  <td>BFSç›´è§‚ï¼Œé€‚åˆå›¾ä¼ æ’­</td>
  <td>éœ€è¦æ„å»ºæ—¶é—´æ˜ å°„</td>
</tr>
</tbody>
</table>

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<ol>
<li><strong>è§£æ³•ä¸€ï¼ˆåˆ†ç»„+BFSï¼‰</strong> æ˜¯æœ€ç›´è§‚çš„è§£æ³•ï¼Œé€‚åˆç†è§£å’Œå®ç°</li>
<li><strong>è§£æ³•äºŒï¼ˆå¹¶æŸ¥é›†ï¼‰</strong> ç©ºé—´æ•ˆç‡æœ€é«˜ï¼Œä½†éœ€è¦å°å¿ƒå¤„ç†çŠ¶æ€é‡ç½®</li>
<li><strong>è§£æ³•ä¸‰ï¼ˆBFSåˆ†å±‚ï¼‰</strong> ä¸è§£æ³•ä¸€ç±»ä¼¼ï¼Œä½†æ›´å¼ºè°ƒæ—¶é—´åˆ†å±‚</li>
</ol>

<p><strong>æ¨èä½¿ç”¨è§£æ³•ä¸€</strong>ï¼Œå› ä¸ºï¼š
- é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œè°ƒè¯•
- æ—¶é—´å¤æ‚åº¦ä¸æœ€ä¼˜è§£ç›¸åŒ
- é€‚åˆå¤„ç†å¤§è§„æ¨¡æ•°æ®
- ä»£ç å¯è¯»æ€§å¥½ï¼Œæ˜“äºç»´æŠ¤</p>

<p>åœ¨å®é™…LeetCodeæäº¤ä¸­ï¼Œè§£æ³•ä¸€å’Œè§£æ³•äºŒéƒ½æœ‰å¾ˆå¥½çš„æ€§èƒ½è¡¨ç°ï¼Œå¯ä»¥æ ¹æ®ä¸ªäººåå¥½é€‰æ‹©ã€‚</p>

<hr />

<p><em>è·å–æ—¶é—´: 2026-02-26 19:08:03</em></p>

        </div>
    </div>
</body>
</html>