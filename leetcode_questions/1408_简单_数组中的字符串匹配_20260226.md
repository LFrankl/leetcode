# 1408. 数组中的字符串匹配

**难度**: Easy

**标签**: 数组, 字符串, 字符串匹配

**链接**: https://leetcode.cn/problems/string-matching-in-an-array/

---

## 题目描述

<p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的 <span data-keyword="substring-nonempty">子字符串</span> 的所有单词。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入：</strong>words = ["mass","as","hero","superhero"]
<strong>输出：</strong>["as","hero"]
<strong>解释：</strong>"as" 是 "mass" 的子字符串，"hero" 是 "superhero" 的子字符串。
["hero","as"] 也是有效的答案。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>words = ["leetcode","et","code"]
<strong>输出：</strong>["et","code"]
<strong>解释：</strong>"et" 和 "code" 都是 "leetcode" 的子字符串。
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<strong>输入：</strong>words = ["blue","green","bu"]
<strong>输出：</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
	<li><code>words[i]</code> 仅包含小写英文字母。</li>
	<li>题目数据 <strong>保证</strong> <code>words</code>&nbsp;的每个字符串都是独一无二的。</li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        
    }
};
```

### Java

```java
class Solution {
    public List<String> stringMatching(String[] words) {
        
    }
}
```

### Python3

```python3
class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        
```

### JavaScript

```javascript
/**
 * @param {string[]} words
 * @return {string[]}
 */
var stringMatching = function(words) {
    
};
```

### Go

```golang
func stringMatching(words []string) []string {
    
}
```

---

## 提示

1. Bruteforce to find if one string is substring of another or use KMP algorithm.

---

## 示例测试用例

```
["mass","as","hero","superhero"]
```

---

## AI 解答 (DeepSeek)

## 题目分析
题目要求找出字符串数组中，那些是其他单词子字符串的单词。需要返回所有符合条件的单词，顺序任意。

**关键点**：
- 一个单词是其他单词的子字符串（不能是自身）
- 所有单词都是唯一的
- 需要检查每个单词是否是其他任意单词的子串

## 解法一：暴力枚举法

### 解题思路
最直接的方法：对于每个单词，检查它是否是其他任意单词的子串。使用双重循环实现。

### 代码实现

#### Go 实现
```go
func stringMatching(words []string) []string {
    var result []string
    n := len(words)
    
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            if i != j && len(words[i]) <= len(words[j]) {
                // 检查 words[i] 是否是 words[j] 的子串
                if strings.Contains(words[j], words[i]) {
                    result = append(result, words[i])
                    break  // 找到一个包含它的单词即可
                }
            }
        }
    }
    return result
}
```

#### C++ 实现
```cpp
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        vector<string> result;
        int n = words.size();
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && words[i].length() <= words[j].length()) {
                    // 检查 words[i] 是否是 words[j] 的子串
                    if (words[j].find(words[i]) != string::npos) {
                        result.push_back(words[i]);
                        break;  // 找到一个包含它的单词即可
                    }
                }
            }
        }
        return result;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n² * L)，其中 n 是单词数量，L 是单词平均长度。最坏情况下需要比较所有单词对。
- **空间复杂度**：O(1)（不考虑输出结果的空间）

## 解法二：排序 + 后缀检查法

### 解题思路
1. 按长度对单词排序，较短的单词更可能是较长单词的子串
2. 对于每个单词，只检查它后面的单词（因为后面的单词更长）
3. 这样可以减少不必要的比较

### 代码实现

#### Go 实现
```go
func stringMatching(words []string) []string {
    // 按长度排序
    sortedWords := make([]string, len(words))
    copy(sortedWords, words)
    sort.Slice(sortedWords, func(i, j int) bool {
        return len(sortedWords[i]) < len(sortedWords[j])
    })
    
    var result []string
    n := len(sortedWords)
    
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            // 只检查更长的单词
            if strings.Contains(sortedWords[j], sortedWords[i]) {
                result = append(result, sortedWords[i])
                break  // 找到一个包含它的单词即可
            }
        }
    }
    return result
}
```

#### C++ 实现
```cpp
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        // 按长度排序
        vector<string> sortedWords = words;
        sort(sortedWords.begin(), sortedWords.end(), 
             [](const string& a, const string& b) {
                 return a.length() < b.length();
             });
        
        vector<string> result;
        int n = sortedWords.size();
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // 只检查更长的单词
                if (sortedWords[j].find(sortedWords[i]) != string::npos) {
                    result.push_back(sortedWords[i]);
                    break;  // 找到一个包含它的单词即可
                }
            }
        }
        return result;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n log n + n² * L)，排序需要 O(n log n)，比较需要 O(n² * L)
- **空间复杂度**：O(n)，需要额外的数组存储排序后的单词

## 解法三：连接字符串法

### 解题思路
1. 将所有单词用特殊字符连接成一个长字符串
2. 对于每个单词，检查它在这个长字符串中出现的次数
3. 如果出现次数大于1，说明它是其他单词的子串

### 代码实现

#### Go 实现
```go
func stringMatching(words []string) []string {
    // 用特殊字符连接所有单词
    joined := strings.Join(words, "#")
    
    var result []string
    for _, word := range words {
        // 在连接后的字符串中查找该单词
        // 需要确保找到的位置不是单词本身的一部分
        count := 0
        pos := 0
        for {
            idx := strings.Index(joined[pos:], word)
            if idx == -1 {
                break
            }
            count++
            pos += idx + 1
            if count >= 2 {
                // 出现至少2次，说明是其他单词的子串
                result = append(result, word)
                break
            }
        }
    }
    return result
}
```

#### C++ 实现
```cpp
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        // 用特殊字符连接所有单词
        string joined;
        for (const string& word : words) {
            joined += word + "#";
        }
        
        vector<string> result;
        for (const string& word : words) {
            // 统计单词在连接字符串中出现的次数
            int count = 0;
            size_t pos = 0;
            
            while ((pos = joined.find(word, pos)) != string::npos) {
                count++;
                pos += 1;  // 移动位置继续查找
                if (count >= 2) {
                    // 出现至少2次，说明是其他单词的子串
                    result.push_back(word);
                    break;
                }
            }
        }
        return result;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n * L * S)，其中 S 是连接后字符串的长度，最坏情况下接近 n*L
- **空间复杂度**：O(n * L)，需要存储连接后的字符串

## 解法对比

| 解法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 暴力枚举 | 实现简单，无需额外空间 | 时间复杂度高，O(n² * L) | 数据规模小（n ≤ 100） |
| 排序+后缀检查 | 减少比较次数，效率较高 | 需要排序，改变原始顺序 | 通用场景，性能较好 |
| 连接字符串 | 思路巧妙，代码简洁 | 可能误判（如"a"在"ab"中出现），需要特殊分隔符 | 需要快速实现，对性能要求不高 |

## 推荐解法
对于本题的数据规模（n ≤ 100，L ≤ 30），**解法一（暴力枚举）** 是最简单直接的选择，代码清晰易懂，性能也完全足够。

**解法二（排序+后缀检查）** 在性能上更优，特别是当单词数量较多时，是更通用的解决方案。

**解法三（连接字符串）** 虽然思路巧妙，但需要注意处理边界情况，实际应用中较少使用。

---

*获取时间: 2026-02-26 17:47:40*
