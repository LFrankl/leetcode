# 3613. 最小化连通分量的最大成本

**难度**: Medium

**标签**: 并查集, 图, 二分查找, 排序

**链接**: https://leetcode.cn/problems/minimize-maximum-component-cost/

---

## 题目描述

<p data-end="331" data-start="85">给你一个无向连通图，包含 <code data-end="137" data-start="134">n</code> 个节点，节点编号从 0 到 <code data-end="171" data-start="164">n - 1</code>，以及一个二维整数数组 <code data-end="202" data-start="195">edges</code>，其中 <code data-end="234" data-start="209">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> 表示一条连接节点 <code data-end="279" data-start="275">u<sub>i</sub></code> 和节点 <code data-end="293" data-start="289">v<sub>i</sub></code> 的无向边，边权为 <code data-end="310" data-start="306">w<sub>i</sub></code>，另有一个整数 <code data-end="330" data-start="327">k</code>。</p>

<p data-end="461" data-start="333">你可以从图中移除任意数量的边，使得最终的图中&nbsp;<strong>最多&nbsp;</strong>只包含 <code data-end="439" data-start="436">k</code> 个连通分量。</p>

<p data-end="589" data-start="463">连通分量的 <strong>成本&nbsp;</strong>定义为该分量中边权的&nbsp;<strong>最大值&nbsp;</strong>。如果一个连通分量没有边，则其代价为 0。</p>

<p data-end="760" data-start="661">请返回在移除这些边之后，在所有连通分量之中的&nbsp;<strong>最大成本&nbsp;</strong>的&nbsp;<strong>最小可能值&nbsp;</strong>。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<div class="example-block">
<p><strong>输入：</strong> <span class="example-io">n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2</span></p>

<p><strong>输出：</strong> <span class="example-io">4</span></p>

<p><strong>解释：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minimizemaximumm.jpg" style="width: 535px; height: 225px;" /></p>

<ul>
	<li data-end="1070" data-start="1021">移除节点 3 和节点 4 之间的边（权值为 6）。</li>
	<li data-end="1141" data-start="1073">最终的连通分量成本分别为 0 和 4，因此最大代价为 4。</li>
</ul>
</div>

<p><strong class="example">示例 2：</strong></p>

<div class="example-block">
<p><strong>输入：</strong> <span class="example-io">n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1</span></p>

<p><strong>输出：</strong> <span class="example-io">5</span></p>

<p><strong>解释：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minmax2.jpg" style="width: 315px; height: 55px;" /></p>

<ul>
	<li data-end="1315" data-start="1251">无法移除任何边，因为只允许一个连通分量（<code>k = 1</code>），图必须保持完全连通。</li>
	<li data-end="1389" data-start="1318">该连通分量的成本等于其最大边权，即 5。</li>
</ul>
</div>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li>输入图是连通图。</li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges, int k) {
        
    }
};
```

### Java

```java
class Solution {
    public int minCost(int n, int[][] edges, int k) {
        
    }
}
```

### Python3

```python3
class Solution:
    def minCost(self, n: int, edges: List[List[int]], k: int) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} k
 * @return {number}
 */
var minCost = function(n, edges, k) {
    
};
```

### Go

```golang
func minCost(n int, edges [][]int, k int) int {
    
}
```

---

## 提示

1. Sort the <code>edges</code> and do binary search on the candidate maximum weight
2. Use <code>DFS</code> or <code>DSU</code> to count the number of connected components when keeping only edges with weight <= mid

---

## 示例测试用例

```
5
[[0,1,4],[1,2,3],[1,3,2],[3,4,6]]
2
```

---

## AI 解答 (DeepSeek)

## 题目分析

这是一个**最小化最大值**问题，我们需要在最多保留 k 个连通分量的前提下，通过删除边来最小化所有连通分量中边权最大值的最大值。

**关键点**：
1. 初始图是连通的（n 个节点，1 个连通分量）
2. 删除边会增加连通分量数量
3. 每个连通分量的成本 = 该分量中所有边的最大边权（如果没有边则为 0）
4. 最终连通分量数 ≤ k
5. 目标是**最小化所有连通分量成本的最大值**

## 解题思路

### 核心观察
- 如果我们设定一个阈值 `x`，只保留边权 ≤ `x` 的边，那么：
  - 每个连通分量的成本 ≤ `x`
  - 删除边权 > `x` 的边会增加连通分量数量
- 问题转化为：找到最小的 `x`，使得删除所有边权 > `x` 的边后，连通分量数 ≤ k

### 转化为判定问题
对于给定的 `x`：
1. 只考虑边权 ≤ `x` 的边构建子图
2. 计算该子图的连通分量数 `cnt`
3. 如果 `cnt ≤ k`，则 `x` 可行（因为可以进一步删除边来增加分量，但不会增加成本）

### 解法选择
1. **二分答案 + 并查集**（最优解）
2. **Kruskal 变种**（类似最小生成树思想）
3. **DFS/BFS 计数**（配合二分）

## 解法一：二分答案 + 并查集

### 思路
1. 对边权进行排序（用于二分）
2. 二分查找最小的 `x`，使得只使用边权 ≤ `x` 的边时，连通分量数 ≤ k
3. 使用并查集快速计算连通分量数

### 复杂度
- 时间复杂度：O((E + n) log W)，W 是最大边权
- 空间复杂度：O(n)

### 代码实现

#### Go 实现
```go
func minMaxCost(n int, edges [][]int, k int) int {
    // 边权范围
    left, right := 0, 0
    for _, e := range edges {
        if e[2] > right {
            right = e[2]
        }
    }
    
    // 二分答案
    ans := right
    for left <= right {
        mid := left + (right-left)/2
        if check(n, edges, k, mid) {
            ans = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return ans
}

func check(n int, edges [][]int, k int, limit int) bool {
    // 初始化并查集
    parent := make([]int, n)
    for i := 0; i < n; i++ {
        parent[i] = i
    }
    
    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }
    
    union := func(x, y int) {
        px, py := find(x), find(y)
        if px != py {
            parent[px] = py
        }
    }
    
    // 只连接边权 <= limit 的边
    for _, e := range edges {
        if e[2] <= limit {
            union(e[0], e[1])
        }
    }
    
    // 计算连通分量数
    components := 0
    for i := 0; i < n; i++ {
        if find(i) == i {
            components++
        }
    }
    
    return components <= k
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int minMaxCost(int n, vector<vector<int>>& edges, int k) {
        int left = 0, right = 0;
        for (auto& e : edges) {
            right = max(right, e[2]);
        }
        
        int ans = right;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (check(n, edges, k, mid)) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
    
private:
    bool check(int n, vector<vector<int>>& edges, int k, int limit) {
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);
        
        function<int(int)> find = [&](int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        };
        
        auto unionSet = [&](int x, int y) {
            int px = find(x), py = find(y);
            if (px != py) {
                parent[px] = py;
            }
        };
        
        for (auto& e : edges) {
            if (e[2] <= limit) {
                unionSet(e[0], e[1]);
            }
        }
        
        int components = 0;
        for (int i = 0; i < n; i++) {
            if (find(i) == i) {
                components++;
            }
        }
        
        return components <= k;
    }
};
```

## 解法二：Kruskal 变种（贪心）

### 思路
1. 将边按权值从小到大排序
2. 使用 Kruskal 算法逐步添加边
3. 当添加一条边会减少连通分量数时，记录当前连通分量数
4. 找到满足连通分量数 ≤ k 的最小边权

### 复杂度
- 时间复杂度：O(E log E + E α(n))
- 空间复杂度：O(n)

### 代码实现

#### Go 实现
```go
func minMaxCost(n int, edges [][]int, k int) int {
    // 按边权排序
    sort.Slice(edges, func(i, j int) bool {
        return edges[i][2] < edges[j][2]
    })
    
    // 初始化并查集
    parent := make([]int, n)
    for i := 0; i < n; i++ {
        parent[i] = i
    }
    
    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }
    
    union := func(x, y int) bool {
        px, py := find(x), find(y)
        if px == py {
            return false
        }
        parent[px] = py
        return true
    }
    
    // 初始连通分量数
    components := n
    
    // 特殊情况：不需要边
    if components <= k {
        return 0
    }
    
    // 逐步添加边
    for _, e := range edges {
        if union(e[0], e[1]) {
            components--
            if components <= k {
                return e[2]
            }
        }
    }
    
    // 如果所有边都添加后仍然 > k，返回最大边权
    return edges[len(edges)-1][2]
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int minMaxCost(int n, vector<vector<int>>& edges, int k) {
        // 按边权排序
        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[2] < b[2];
        });
        
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);
        
        function<int(int)> find = [&](int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        };
        
        auto unionSet = [&](int x, int y) -> bool {
            int px = find(x), py = find(y);
            if (px == py) return false;
            parent[px] = py;
            return true;
        };
        
        int components = n;
        
        // 特殊情况
        if (components <= k) return 0;
        
        for (auto& e : edges) {
            if (unionSet(e[0], e[1])) {
                components--;
                if (components <= k) {
                    return e[2];
                }
            }
        }
        
        return edges.back()[2];
    }
};
```

## 解法三：二分答案 + DFS/BFS

### 思路
1. 二分答案
2. 对于每个 mid，构建只包含边权 ≤ mid 的图
3. 使用 DFS/BFS 计算连通分量数

### 复杂度
- 时间复杂度：O((E + n) log W)
- 空间复杂度：O(E + n)

### 代码实现（Go）
```go
func minMaxCost(n int, edges [][]int, k int) int {
    // 构建邻接表（用于DFS/BFS）
    maxWeight := 0
    for _, e := range edges {
        if e[2] > maxWeight {
            maxWeight = e[2]
        }
    }
    
    left, right := 0, maxWeight
    ans := right
    
    for left <= right {
        mid := left + (right-left)/2
        
        // 构建邻接表（只包含边权 <= mid 的边）
        adj := make([][]int, n)
        for _, e := range edges {
            if e[2] <= mid {
                adj[e[0]] = append(adj[e[0]], e[1])
                adj[e[1]] = append(adj[e[1]], e[0])
            }
        }
        
        // DFS计算连通分量数
        visited := make([]bool, n)
        components := 0
        for i := 0; i < n; i++ {
            if !visited[i] {
                components++
                dfs(i, adj, visited)
            }
        }
        
        if components <= k {
            ans = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    
    return ans
}

func dfs(node int, adj [][]int, visited []bool) {
    visited[node] = true
    for _, neighbor := range adj[node] {
        if !visited[neighbor] {
            dfs(neighbor, adj, visited)
        }
    }
}
```

## 解法对比

| 特性 | 二分+并查集 | Kruskal变种 | 二分+DFS/BFS |
|------|------------|------------|-------------|
| 时间复杂度 | O((E+n)logW) | O(ElogE + Eα(n)) | O((E+n)logW) |
| 空间复杂度 | O(n) | O(n) | O(E+n) |
| 实现难度 | 简单 | 简单 | 中等 |
| 适用场景 | 通用 | 边已排序或需要排序 | 需要显式图结构 |
| 优点 | 稳定高效 | 直观，一次遍历 | 不需要并查集 |
| 缺点 | 需要二分 | 必须排序所有边 | 需要构建图，空间大 |

## 推荐解法

**解法一（二分+并查集）是最推荐的**，因为：
1. 时间复杂度最优
2. 空间复杂度低
3. 实现简单直观
4. 适用于各种规模的输入

**解法二（Kruskal变种）** 也很优秀，特别是当边已经排序或需要排序时，它更直观。

**解法三** 在需要显式图结构时有用，但空间开销较大。

在实际 LeetCode 提交中，解法一和解法二都是可行的，解法一通常更快一些。

---

*获取时间: 2026-02-26 19:06:37*
