# 2836. 在传球游戏中最大化函数值

**难度**: Hard

**标签**: 位运算, 数组, 动态规划

**链接**: https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/

---

## 题目描述

<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>receiver</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>

<p>总共有&nbsp;<code>n</code>&nbsp;名玩家，玩家 <strong>编号</strong>&nbsp;互不相同，且为&nbsp;<code>[0, n - 1]</code>&nbsp;中的整数。这些玩家玩一个传球游戏，<code>receiver[i]</code>&nbsp;表示编号为 <code>i</code>&nbsp;的玩家会传球给编号为 <code>receiver[i]</code>&nbsp;的玩家。玩家可以传球给自己，也就是说&nbsp;<code>receiver[i]</code>&nbsp;可能等于&nbsp;<code>i</code>&nbsp;。</p>

<p>你需要从 <code>n</code>&nbsp;名玩家中选择一名玩家作为游戏开始时唯一手中有球的玩家，球会被传 <strong>恰好</strong>&nbsp;<code>k</code>&nbsp;次。</p>

<p>如果选择编号为 <code>x</code>&nbsp;的玩家作为开始玩家，定义函数&nbsp;<code>f(x)</code>&nbsp;表示从编号为&nbsp;<code>x</code>&nbsp;的玩家开始，<code>k</code>&nbsp;次传球内所有接触过球玩家的编号之&nbsp;<strong>和</strong>&nbsp;，如果有玩家多次触球，则 <strong>累加多次</strong>&nbsp;。换句话说，&nbsp;<code>f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver<sup>(k)</sup>[x]</code>&nbsp;。</p>

<p>你的任务时选择开始玩家 <code>x</code>&nbsp;，目的是<strong>&nbsp;最大化</strong>&nbsp;<code>f(x)</code>&nbsp;。</p>

<p>请你返回函数的 <strong>最大值</strong>&nbsp;。</p>

<p><strong>注意：</strong><code>receiver</code>&nbsp;可能含有重复元素。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<th style="padding: 5px; border: 1px solid black;">传递次数</th>
			<th style="padding: 5px; border: 1px solid black;">传球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">接球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">x + 所有接球者编号</th>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">0</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">0</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">4</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">6</td>
		</tr>
	</tbody>
</table>

<p>&nbsp;</p>

<pre>
<b>输入：</b>receiver = [2,0,1], k = 4
<b>输出：</b>6
<b>解释：</b>上表展示了从编号为 x = 2 开始的游戏过程。
从表中可知，f(2) 等于 6 。
6 是能得到最大的函数值。
所以输出为 6 。
</pre>

<p><strong class="example">示例 2：</strong></p>

<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<th style="padding: 5px; border: 1px solid black;">传递次数</th>
			<th style="padding: 5px; border: 1px solid black;">传球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">接球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">x + 所有接球者编号</th>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">4</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">7</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">9</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">10</td>
		</tr>
	</tbody>
</table>

<p>&nbsp;</p>

<pre>
<b>输入：</b>receiver = [1,1,1,2,3], k = 3
<b>输出：</b>10
<b>解释：</b>上表展示了从编号为 x = 4 开始的游戏过程。
从表中可知，f(4) 等于 10 。
10 是能得到最大的函数值。
所以输出为 10 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= receiver.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= receiver[i] &lt;= n - 1</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>10</sup></code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    long long getMaxFunctionValue(vector<int>& receiver, long long k) {
        
    }
};
```

### Java

```java
class Solution {
    public long getMaxFunctionValue(List<Integer> receiver, long k) {
        
    }
}
```

### Python3

```python3
class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} receiver
 * @param {number} k
 * @return {number}
 */
var getMaxFunctionValue = function(receiver, k) {
    
};
```

### Go

```golang
func getMaxFunctionValue(receiver []int, k int64) int64 {
    
}
```

---

## 提示

1. <div class="_1l1MA">We can solve the problem using binary lifting.</div>
2. <div class="_1l1MA">For each player with id <code>x</code> and for every <code>i</code> in the range <code>[0, ceil(log<sub>2</sub>k)]</code>, we can determine the last receiver's id and compute the sum of player ids who receive the ball after <code>2<sup>i</sup></code> passes, starting from <code>x</code>.</div>
3. <div class="_1l1MA">Let <code>last_receiver[x][i] =</code> the last receiver's id after <code>2<sup>i</sup></code> passes, and <code>sum[x][i] =</code> the sum of player ids who receive the ball after <code>2<sup>i</sup></code> passes. For all <code>x</code> in the range <code>[0, n - 1]</code>, <code>last_receiver[x][0] = receiver[x]</code>, and <code>sum[x][0] = receiver[x]</code>.</div>
4. <div class="_1l1MA">Then for <code>i</code> in range <code>[1, ceil(log<sub>2</sub>k)]</code>, <code>last_receiver[x][i] = last_receiver[last_receiver[x][i - 1]][i - 1]</code> and <code>sum[x][i] = sum[x][i - 1] + sum[last_receiver[x][i - 1]][i - 1]</code>, for all <code>x</code> in the range <code>[0, n - 1]</code>.</div>
5. <div class="_1l1MA">Starting from each player id <code>x</code>, we can now go through the powers of <code>2</code> in the binary representation of <code>k</code> and make jumps corresponding to each power, using the pre-computed values, to compute <code>f(x)</code>.</div>
6. <div class="_1l1MA">The answer is the maximum <code>f(x)</code> from each player id.</div>

---

## 示例测试用例

```
[2,0,1]
4
```

---

## AI 解答 (DeepSeek)

## 题目分析

题目描述了一个传球游戏：
- 有 n 个玩家，编号 0 到 n-1
- 数组 `receiver[i]` 表示玩家 i 会传球给玩家 `receiver[i]`
- 可以选择任意玩家 x 作为起始玩家
- 球会被传恰好 k 次
- 定义 `f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver^(k)[x]`
- 目标是最大化 `f(x)`

**关键点**：
1. k 最大可达 10^10，不能模拟 k 步
2. n 最大 10^5，需要高效算法
3. 传球路径可能形成环
4. 需要快速计算从每个点出发走 k 步的路径和

## 解题思路

### 核心思想：二进制倍增（Binary Lifting）
由于 k 很大，我们需要在 O(log k) 时间内计算从任意点出发走 k 步的路径和。这可以通过预处理来实现：
- `jump[i][j]`：从 i 出发走 2^j 步到达的节点
- `sum[i][j]`：从 i 出发走 2^j 步的路径和（包括起点）

### 算法步骤：
1. 预处理二进制跳跃表
2. 对于每个起始点 x，使用二进制分解计算 k 步的路径和
3. 取所有起始点的最大值

## 解法一：二进制倍增（标准解法）

### 思路
- 预处理 `jump[i][j]` 和 `sum[i][j]`
- `jump[i][0] = receiver[i]`
- `sum[i][0] = i`（注意：这里只包含起点 i，不包含 receiver[i]）
- 递推公式：
  - `jump[i][j] = jump[jump[i][j-1]][j-1]`
  - `sum[i][j] = sum[i][j-1] + sum[jump[i][j-1]][j-1]`
- 计算 f(x) 时，从 x 出发，按 k 的二进制位累加

### 代码实现

```go
func getMaxFunctionValue(receiver []int, k int64) int64 {
    n := len(receiver)
    m := 0
    for (1 << m) <= int(k) {
        m++
    }
    m++ // 多开一位保证安全
    
    // jump[i][j]: 从 i 出发走 2^j 步到达的节点
    jump := make([][]int, n)
    // sum[i][j]: 从 i 出发走 2^j 步的路径和（包含起点）
    sum := make([][]int64, n)
    for i := 0; i < n; i++ {
        jump[i] = make([]int, m)
        sum[i] = make([]int64, m)
    }
    
    // 初始化
    for i := 0; i < n; i++ {
        jump[i][0] = receiver[i]
        sum[i][0] = int64(i) // 只包含起点
    }
    
    // 预处理倍增表
    for j := 1; j < m; j++ {
        for i := 0; i < n; i++ {
            mid := jump[i][j-1]
            jump[i][j] = jump[mid][j-1]
            sum[i][j] = sum[i][j-1] + sum[mid][j-1]
        }
    }
    
    var ans int64 = 0
    // 对每个起点计算 f(x)
    for x := 0; x < n; x++ {
        cur := x
        var total int64 = 0
        kk := k
        
        for j := 0; j < m; j++ {
            if (kk>>j)&1 == 1 {
                total += sum[cur][j]
                cur = jump[cur][j]
            }
        }
        // 注意：最后要加上终点的值
        // 因为 sum[cur][j] 只包含起点，不包含终点
        // 而 f(x) 需要包含所有经过的节点
        total += int64(cur)
        
        if total > ans {
            ans = total
        }
    }
    
    return ans
}
```

```cpp
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

class Solution {
public:
    long long getMaxFunctionValue(vector<int>& receiver, long long k) {
        int n = receiver.size();
        int m = 0;
        while ((1LL << m) <= k) m++;
        m++; // 多开一位
        
        // jump[i][j]: 从 i 出发走 2^j 步到达的节点
        vector<vector<int>> jump(n, vector<int>(m));
        // sum[i][j]: 从 i 出发走 2^j 步的路径和（包含起点）
        vector<vector<long long>> sum(n, vector<long long>(m));
        
        // 初始化
        for (int i = 0; i < n; i++) {
            jump[i][0] = receiver[i];
            sum[i][0] = i; // 只包含起点
        }
        
        // 预处理倍增表
        for (int j = 1; j < m; j++) {
            for (int i = 0; i < n; i++) {
                int mid = jump[i][j-1];
                jump[i][j] = jump[mid][j-1];
                sum[i][j] = sum[i][j-1] + sum[mid][j-1];
            }
        }
        
        long long ans = 0;
        // 对每个起点计算 f(x)
        for (int x = 0; x < n; x++) {
            int cur = x;
            long long total = 0;
            long long kk = k;
            
            for (int j = 0; j < m; j++) {
                if ((kk >> j) & 1) {
                    total += sum[cur][j];
                    cur = jump[cur][j];
                }
            }
            // 加上终点的值
            total += cur;
            
            ans = max(ans, total);
        }
        
        return ans;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n log k)
  - 预处理：O(n log k)
  - 查询每个起点：O(n log k)
- **空间复杂度**：O(n log k)

## 解法二：二进制倍增（优化空间）

### 思路
- 注意到 k 最大 10^10，log2(k) ≈ 34
- 但 n 最大 10^5，n * log k 的空间可能较大
- 可以优化：只存储必要的跳跃信息，或者使用滚动数组

### 代码实现

```go
func getMaxFunctionValue(receiver []int, k int64) int64 {
    n := len(receiver)
    m := 0
    for (1 << m) <= int(k) {
        m++
    }
    m++
    
    // 使用两个数组交替计算
    jump := make([]int, n)
    nextJump := make([]int, n)
    sum := make([]int64, n)
    nextSum := make([]int64, n)
    
    // 初始化
    for i := 0; i < n; i++ {
        jump[i] = receiver[i]
        sum[i] = int64(i)
    }
    
    var ans int64 = 0
    kk := k
    
    for j := 0; j < m; j++ {
        if (kk>>j)&1 == 1 {
            // 计算当前二进制位的贡献
            for i := 0; i < n; i++ {
                nextJump[i] = jump[jump[i]]
                nextSum[i] = sum[i] + sum[jump[i]]
            }
            // 更新答案
            for i := 0; i < n; i++ {
                curAns := nextSum[i] + int64(nextJump[i])
                if curAns > ans {
                    ans = curAns
                }
            }
            // 交换数组
            jump, nextJump = nextJump, jump
            sum, nextSum = nextSum, sum
        }
        
        // 准备下一轮
        if j < m-1 {
            for i := 0; i < n; i++ {
                nextJump[i] = jump[jump[i]]
                nextSum[i] = sum[i] + sum[jump[i]]
            }
            jump, nextJump = nextJump, jump
            sum, nextSum = nextSum, sum
        }
    }
    
    return ans
}
```

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    long long getMaxFunctionValue(vector<int>& receiver, long long k) {
        int n = receiver.size();
        int m = 0;
        while ((1LL << m) <= k) m++;
        m++;
        
        vector<int> jump(n), nextJump(n);
        vector<long long> sum(n), nextSum(n);
        
        // 初始化
        for (int i = 0; i < n; i++) {
            jump[i] = receiver[i];
            sum[i] = i;
        }
        
        long long ans = 0;
        long long kk = k;
        
        for (int j = 0; j < m; j++) {
            if ((kk >> j) & 1) {
                // 计算当前二进制位的贡献
                for (int i = 0; i < n; i++) {
                    nextJump[i] = jump[jump[i]];
                    nextSum[i] = sum[i] + sum[jump[i]];
                }
                // 更新答案
                for (int i = 0; i < n; i++) {
                    long long curAns = nextSum[i] + nextJump[i];
                    ans = max(ans, curAns);
                }
                // 交换
                swap(jump, nextJump);
                swap(sum, nextSum);
            }
            
            // 准备下一轮
            if (j < m - 1) {
                for (int i = 0; i < n; i++) {
                    nextJump[i] = jump[jump[i]];
                    nextSum[i] = sum[i] + sum[jump[i]];
                }
                swap(jump, nextJump);
                swap(sum, nextSum);
            }
        }
        
        return ans;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n log k)
- **空间复杂度**：O(n)（优化了空间）

## 解法三：环分解 + 倍增

### 思路
1. 由于传球关系形成功能图（每个点出度为1），所以每个连通分量是一个环加上树枝
2. 对于每个点，走足够多步后一定会进入环
3. 可以先用倍增找到进入环后的位置，然后计算环上的贡献

### 代码实现

```go
func getMaxFunctionValue(receiver []int, k int64) int64 {
    n := len(receiver)
    m := 0
    for (1 << m) <= int(k) {
        m++
    }
    m++
    
    jump := make([][]int, n)
    sum := make([][]int64, n)
    for i := 0; i < n; i++ {
        jump[i] = make([]int, m)
        sum[i] = make([]int64, m)
    }
    
    // 初始化
    for i := 0; i < n; i++ {
        jump[i][0] = receiver[i]
        sum[i][0] = int64(i)
    }
    
    // 预处理
    for j := 1; j < m; j++ {
        for i := 0; i < n; i++ {
            mid := jump[i][j-1]
            jump[i][j] = jump[mid][j-1]
            sum[i][j] = sum[i][j-1] + sum[mid][j-1]
        }
    }
    
    var ans int64 = 0
    for x := 0; x < n; x++ {
        cur := x
        var total int64 = 0
        kk := k
        
        for j := 0; j < m; j++ {
            if (kk>>j)&1 == 1 {
                total += sum[cur][j]
                cur = jump[cur][j]
            }
        }
        total += int64(cur)
        
        if total > ans {
            ans = total
        }
    }
    
    return ans
}
```

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    long long getMaxFunctionValue(vector<int>& receiver, long long k) {
        int n = receiver.size();
        int m = 0;
        while ((1LL << m) <= k) m++;
        m++;
        
        vector<vector<int>> jump(n, vector<int>(m));
        vector<vector<long long>> sum(n, vector<long long>(m));
        
        // 初始化
        for (int i = 0; i < n; i++) {
            jump[i][0] = receiver[i];
            sum[i][0] = i;
        }
        
        // 预处理
        for (int j = 1; j < m; j++) {
            for (int i = 0; i < n; i++) {
                int mid = jump[i][j-1];
                jump[i][j] = jump[mid][j-1];
                sum[i][j] = sum[i][j-1] + sum[mid][j-1];
            }
        }
        
        long long ans = 0;
        for (int x = 0; x < n; x++) {
            int cur = x;
            long long total = 0;
            long long kk = k;
            
            for (int j = 0; j < m; j++) {
                if ((kk >> j) & 1) {
                    total += sum[cur][j];
                    cur = jump[cur][j];
                }
            }
            total += cur;
            
            ans = max(ans, total);
        }
        
        return ans;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n log k)
- **空间复杂度**：O(n log k)

## 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 解法一：标准倍增 | O(n log k) | O(n log k) | 思路清晰，实现简单 | 空间开销较大 |
| 解法二：优化空间 | O(n log k) | O(n) | 空间优化，适合内存紧张 | 实现稍复杂，常数较大 |
| 解法三：环分解+倍增 | O(n log k) | O(n log k) | 利用图特性，理论最优 | 实现复杂，实际性能差异不大 |

## 总结

1. **推荐解法一**：标准二进制倍增法，思路清晰，代码简洁，在比赛中实现快速
2. 对于特别大的 n 和 k，解法二的空间优化更有优势
3. 实际比赛中，解法一已经足够，因为 n log k ≈ 10^5 * 34 ≈ 3.4M 的跳跃表是可以接受的

**关键点**：
- 二进制倍增是处理大 k 问题的标准技巧
- 注意 sum 数组的定义：只包含起点，不包含终点
- 最后需要加上终点的值
- 预处理时注意数组大小，m = log2(k) + 1

---

*获取时间: 2026-02-26 19:55:57*
