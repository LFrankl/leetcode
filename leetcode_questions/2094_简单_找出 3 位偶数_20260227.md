# 2094. 找出 3 位偶数

**难度**: Easy

**标签**: 递归, 数组, 哈希表, 枚举, 排序

**链接**: https://leetcode.cn/problems/finding-3-digit-even-numbers/

---

## 题目描述

<p>给你一个整数数组 <code>digits</code> ，其中每个元素是一个数字（<code>0 - 9</code>）。数组中可能存在重复元素。</p>

<p>你需要找出 <strong>所有</strong> 满足下述条件且 <strong>互不相同</strong> 的整数：</p>

<ul>
	<li>该整数由 <code>digits</code> 中的三个元素按 <strong>任意</strong> 顺序 <strong>依次连接</strong> 组成。</li>
	<li>该整数不含 <strong>前导零</strong></li>
	<li>该整数是一个 <strong>偶数</strong></li>
</ul>

<p>例如，给定的 <code>digits</code> 是 <code>[1, 2, 3]</code> ，整数 <code>132</code> 和 <code>312</code> 满足上面列出的全部条件。</p>

<p>将找出的所有互不相同的整数按 <strong>递增顺序</strong> 排列，并以数组形式返回<em>。</em></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>digits = [2,1,3,0]
<strong>输出：</strong>[102,120,130,132,210,230,302,310,312,320]
<strong>解释：</strong>
所有满足题目条件的整数都在输出数组中列出。 
注意，答案数组中不含有 <strong>奇数</strong> 或带 <strong>前导零</strong> 的整数。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>digits = [2,2,8,8,2]
<strong>输出：</strong>[222,228,282,288,822,828,882]
<strong>解释：</strong>
同样的数字（0 - 9）在构造整数时可以重复多次，重复次数最多与其在 <code>digits</code> 中出现的次数一样。 
在这个例子中，数字 8 在构造 288、828 和 882 时都重复了两次。 
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>digits = [3,7,5]
<strong>输出：</strong>[]
<strong>解释：</strong>
使用给定的 digits 无法构造偶数。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>3 &lt;=&nbsp;digits.length &lt;= 100</code></li>
	<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    vector<int> findEvenNumbers(vector<int>& digits) {
        
    }
};
```

### Java

```java
class Solution {
    public int[] findEvenNumbers(int[] digits) {
        
    }
}
```

### Python3

```python3
class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var findEvenNumbers = function(digits) {
    
};
```

### Go

```golang
func findEvenNumbers(digits []int) []int {
    
}
```

---

## 提示

1. The range of possible answers includes all even numbers between 100 and 999 inclusive. Could you check each possible answer to see if it could be formed from the digits in the array?

---

## 示例测试用例

```
[2,1,3,0]
```

---

## AI 解答 (DeepSeek)

## 题目分析
我们需要从给定的数字数组 `digits` 中，选择三个数字（可以重复使用，但每个数字的使用次数不能超过它在数组中出现的次数）组成一个**三位偶数**，要求：
1. 无前导零（百位不能为0）
2. 是偶数（个位为偶数）
3. 所有结果按升序排列且去重

## 解题思路

### 核心思路
由于数字范围很小（0-9），我们可以：
1. 统计每个数字的出现频率
2. 枚举所有可能的三位数（100-998的偶数）
3. 检查每个数是否能由给定的数字构成
4. 或者直接枚举所有可能的组合

---

## 解法一：暴力枚举所有组合 + 去重排序
### 思路
1. 使用三重循环枚举所有可能的索引组合（考虑重复数字）
2. 检查是否满足条件（百位非0、个位偶数）
3. 使用集合去重，最后排序

### 代码实现
#### Go
```go
func findEvenNumbers(digits []int) []int {
    n := len(digits)
    seen := make(map[int]bool)
    
    for i := 0; i < n; i++ {
        if digits[i] == 0 {
            continue // 百位不能为0
        }
        for j := 0; j < n; j++ {
            if i == j {
                continue
            }
            for k := 0; k < n; k++ {
                if k == i || k == j {
                    continue
                }
                if digits[k] % 2 != 0 {
                    continue // 个位必须偶数
                }
                num := digits[i]*100 + digits[j]*10 + digits[k]
                seen[num] = true
            }
        }
    }
    
    res := make([]int, 0, len(seen))
    for num := range seen {
        res = append(res, num)
    }
    sort.Ints(res)
    return res
}
```

#### C++
```cpp
class Solution {
public:
    vector<int> findEvenNumbers(vector<int>& digits) {
        int n = digits.size();
        unordered_set<int> seen;
        
        for (int i = 0; i < n; i++) {
            if (digits[i] == 0) continue;
            for (int j = 0; j < n; j++) {
                if (i == j) continue;
                for (int k = 0; k < n; k++) {
                    if (k == i || k == j) continue;
                    if (digits[k] % 2 != 0) continue;
                    int num = digits[i] * 100 + digits[j] * 10 + digits[k];
                    seen.insert(num);
                }
            }
        }
        
        vector<int> res(seen.begin(), seen.end());
        sort(res.begin(), res.end());
        return res;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n³ + m log m)，其中 n 是 digits 长度（最大100），m 是结果数量（最多 9×10×5=450）
- **空间复杂度**：O(m)，用于存储结果和去重集合

---

## 解法二：频率统计 + 枚举所有三位偶数
### 思路
1. 统计 digits 中每个数字的频率
2. 枚举所有可能的三位偶数（100-998）
3. 对每个数检查数字频率是否满足

### 代码实现
#### Go
```go
func findEvenNumbers(digits []int) []int {
    freq := make([]int, 10)
    for _, d := range digits {
        freq[d]++
    }
    
    res := []int{}
    for num := 100; num <= 998; num += 2 { // 只枚举偶数
        if num % 2 != 0 {
            continue
        }
        
        // 分解数字
        a := num / 100
        b := (num / 10) % 10
        c := num % 10
        
        // 检查频率
        tempFreq := make([]int, 10)
        tempFreq[a]++
        tempFreq[b]++
        tempFreq[c]++
        
        valid := true
        for i := 0; i < 10; i++ {
            if tempFreq[i] > freq[i] {
                valid = false
                break
            }
        }
        
        if valid {
            res = append(res, num)
        }
    }
    return res
}
```

#### C++
```cpp
class Solution {
public:
    vector<int> findEvenNumbers(vector<int>& digits) {
        vector<int> freq(10, 0);
        for (int d : digits) {
            freq[d]++;
        }
        
        vector<int> res;
        for (int num = 100; num <= 998; num += 2) {
            int a = num / 100;
            int b = (num / 10) % 10;
            int c = num % 10;
            
            vector<int> need(10, 0);
            need[a]++;
            need[b]++;
            need[c]++;
            
            bool valid = true;
            for (int i = 0; i < 10; i++) {
                if (need[i] > freq[i]) {
                    valid = false;
                    break;
                }
            }
            
            if (valid) {
                res.push_back(num);
            }
        }
        return res;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(450 × 10) ≈ O(4500)，因为最多枚举450个偶数，每个检查10个数字的频率
- **空间复杂度**：O(1)，除了结果数组外只用了固定大小的频率数组

---

## 解法三：回溯/DFS生成所有组合
### 思路
1. 使用DFS生成所有长度为3的排列
2. 在生成过程中剪枝（百位不为0，个位为偶数）
3. 使用排序和频率控制重复

### 代码实现
#### Go
```go
func findEvenNumbers(digits []int) []int {
    freq := make([]int, 10)
    for _, d := range digits {
        freq[d]++
    }
    
    resMap := make(map[int]bool)
    
    var dfs func(pos int, num int, used []int)
    dfs = func(pos int, num int, used []int) {
        if pos == 3 {
            if num % 2 == 0 && num >= 100 {
                resMap[num] = true
            }
            return
        }
        
        start := 0
        if pos == 0 {
            start = 1 // 百位不能为0
        }
        
        for d := start; d <= 9; d++ {
            if used[d] < freq[d] {
                used[d]++
                dfs(pos+1, num*10 + d, used)
                used[d]--
            }
        }
    }
    
    used := make([]int, 10)
    dfs(0, 0, used)
    
    res := make([]int, 0, len(resMap))
    for num := range resMap {
        res = append(res, num)
    }
    sort.Ints(res)
    return res
}
```

#### C++
```cpp
class Solution {
public:
    void dfs(int pos, int num, vector<int>& freq, vector<int>& used, unordered_set<int>& res) {
        if (pos == 3) {
            if (num % 2 == 0 && num >= 100) {
                res.insert(num);
            }
            return;
        }
        
        int start = (pos == 0) ? 1 : 0;
        for (int d = start; d <= 9; d++) {
            if (used[d] < freq[d]) {
                used[d]++;
                dfs(pos + 1, num * 10 + d, freq, used, res);
                used[d]--;
            }
        }
    }
    
    vector<int> findEvenNumbers(vector<int>& digits) {
        vector<int> freq(10, 0);
        for (int d : digits) {
            freq[d]++;
        }
        
        unordered_set<int> resSet;
        vector<int> used(10, 0);
        dfs(0, 0, freq, used, resSet);
        
        vector<int> res(resSet.begin(), resSet.end());
        sort(res.begin(), res.end());
        return res;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(10³) = O(1000)，DFS最多探索10×10×10种组合
- **空间复杂度**：O(m + 递归深度)，m为结果数量

---

## 解法对比

| 解法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 解法一（暴力枚举） | 思路简单直观，易实现 | 时间复杂度高，需要去重 | 小数据量，快速实现 |
| 解法二（枚举偶数） | 效率高，只检查有效数字 | 需要枚举所有三位偶数 | 通用场景，性能好 |
| 解法三（DFS） | 灵活，易于扩展 | 代码稍复杂，需要递归 | 需要生成所有组合的场景 |

## 推荐解法
**解法二（频率统计+枚举偶数）** 是最优选择：
1. 时间复杂度最低（O(4500)）
2. 代码简洁易懂
3. 无需复杂去重逻辑
4. 空间效率高

对于本题，digits长度最大为100，但三位偶数最多只有450个，解法二的常数操作非常少，实际运行效率最高。

---

*获取时间: 2026-02-27 16:16:38*
