# 3222. 求出硬币游戏的赢家

**难度**: Easy

**标签**: 数学, 博弈, 模拟

**链接**: https://leetcode.cn/problems/find-the-winning-player-in-coin-game/

---

## 题目描述

<p>给你两个 <strong>正</strong>&nbsp;整数&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp;，分别表示价值为 75 和 10 的硬币的数目。</p>

<p>Alice 和 Bob 正在玩一个游戏。每一轮中，Alice&nbsp;先进行操作，Bob 后操作。每次操作中，玩家需要拿走价值 <b>总和</b>&nbsp;为 115 的硬币。如果一名玩家无法执行此操作，那么这名玩家 <strong>输掉</strong>&nbsp;游戏。</p>

<p>两名玩家都采取 <strong>最优</strong>&nbsp;策略，请你返回游戏的赢家。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<div class="example-block">
<p><span class="example-io"><b>输入：</b>x = 2, y = 7</span></p>

<p><span class="example-io"><b>输出：</b>"Alice"</span></p>

<p><strong>解释：</strong></p>

<p>游戏一次操作后结束：</p>

<ul>
	<li>Alice 拿走 1 枚价值为 75 的硬币和 4 枚价值为 10 的硬币。</li>
</ul>
</div>

<p><strong class="example">示例 2：</strong></p>

<div class="example-block">
<p><span class="example-io"><b>输入：</b>x = 4, y = 11</span></p>

<p><span class="example-io"><b>输出：</b>"Bob"</span></p>

<p><strong>解释：</strong></p>

<p>游戏 2 次操作后结束：</p>

<ul>
	<li>Alice 拿走&nbsp;1 枚价值为 75 的硬币和 4 枚价值为 10 的硬币。</li>
	<li>Bob 拿走&nbsp;1 枚价值为 75 的硬币和 4 枚价值为 10 的硬币。</li>
</ul>
</div>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= x, y &lt;= 100</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    string winningPlayer(int x, int y) {
        
    }
};
```

### Java

```java
class Solution {
    public String winningPlayer(int x, int y) {
        
    }
}
```

### Python3

```python3
class Solution:
    def winningPlayer(self, x: int, y: int) -> str:
        
```

### JavaScript

```javascript
/**
 * @param {number} x
 * @param {number} y
 * @return {string}
 */
var winningPlayer = function(x, y) {
    
};
```

### Go

```golang
func winningPlayer(x int, y int) string {
    
}
```

---

## 提示

1. The only way to make 115 is to use one coin of value 75 and four coins of value 10. Each turn uses up these many coins.
2. Hence the number of turns is <code>min(x, y / 4)</code>.
3. Determine the winner from its parity.

---

## 示例测试用例

```
2
7
```

---

## AI 解答 (DeepSeek)

## 题目分析

这是一个双人博弈游戏，规则如下：
- 有面值75和10的硬币，数量分别为x和y
- 每轮必须拿走总价值为115的硬币组合
- 组合只能是：1个75 + 4个10（75+40=115）
- Alice先手，Bob后手
- 无法操作者输
- 双方都采取最优策略

## 解题思路

### 关键观察
1. 每次操作必须消耗1个75硬币和4个10硬币
2. 游戏能进行的轮数取决于min(x, y//4)
3. 这是一个典型的公平组合游戏，可以用博弈论分析

### 核心逻辑
- 游戏最多能进行 `min(x, y//4)` 轮
- 如果总轮数是奇数：Alice赢（因为Alice先手，最后一轮是Alice操作）
- 如果总轮数是偶数：Bob赢（最后一轮是Bob操作）

## 解法

### 解法一：数学计算法（最优解）
直接计算最大轮数，根据奇偶性判断胜负。

**时间复杂度**：O(1)  
**空间复杂度**：O(1)

```go
func winnerOfGame(x int, y int) string {
    // 计算最多能进行的轮数
    rounds := min(x, y/4)
    // 奇数轮Alice赢，偶数轮Bob赢
    if rounds%2 == 1 {
        return "Alice"
    }
    return "Bob"
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```cpp
class Solution {
public:
    string winnerOfGame(int x, int y) {
        // 计算最多能进行的轮数
        int rounds = min(x, y / 4);
        // 奇数轮Alice赢，偶数轮Bob赢
        return (rounds % 2 == 1) ? "Alice" : "Bob";
    }
};
```

### 解法二：递归+记忆化搜索
使用递归模拟游戏过程，记录胜负状态。

**时间复杂度**：O(x*y)  
**空间复杂度**：O(x*y)

```go
func winnerOfGame(x int, y int) string {
    memo := make([][]int, x+1)
    for i := range memo {
        memo[i] = make([]int, y+1)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }
    
    var dfs func(x, y int) bool
    dfs = func(x, y int) bool {
        if x < 1 || y < 4 {
            return false // 无法操作，当前玩家输
        }
        
        if memo[x][y] != -1 {
            return memo[x][y] == 1
        }
        
        // 尝试拿走1个75和4个10
        // 如果对手在剩余状态下会输，则当前玩家赢
        if !dfs(x-1, y-4) {
            memo[x][y] = 1
            return true
        }
        
        memo[x][y] = 0
        return false
    }
    
    if dfs(x, y) {
        return "Alice"
    }
    return "Bob"
}
```

```cpp
class Solution {
public:
    string winnerOfGame(int x, int y) {
        vector<vector<int>> memo(x+1, vector<int>(y+1, -1));
        
        function<bool(int, int)> dfs = [&](int x, int y) -> bool {
            if (x < 1 || y < 4) return false;
            
            if (memo[x][y] != -1) return memo[x][y] == 1;
            
            // 当前玩家操作后，看对手是否会输
            if (!dfs(x-1, y-4)) {
                memo[x][y] = 1;
                return true;
            }
            
            memo[x][y] = 0;
            return false;
        };
        
        return dfs(x, y) ? "Alice" : "Bob";
    }
};
```

### 解法三：动态规划
自底向上计算所有状态的胜负。

**时间复杂度**：O(x*y)  
**空间复杂度**：O(x*y)

```go
func winnerOfGame(x int, y int) string {
    // dp[i][j]表示有i个75硬币和j个10硬币时，当前玩家是否能赢
    dp := make([][]bool, x+1)
    for i := range dp {
        dp[i] = make([]bool, y+1)
    }
    
    for i := 1; i <= x; i++ {
        for j := 0; j <= y; j++ {
            // 如果可以操作，且操作后对手会输，则当前玩家赢
            if i >= 1 && j >= 4 && !dp[i-1][j-4] {
                dp[i][j] = true
            }
        }
    }
    
    if dp[x][y] {
        return "Alice"
    }
    return "Bob"
}
```

```cpp
class Solution {
public:
    string winnerOfGame(int x, int y) {
        vector<vector<bool>> dp(x+1, vector<bool>(y+1, false));
        
        for (int i = 1; i <= x; i++) {
            for (int j = 0; j <= y; j++) {
                // 如果可以操作，且操作后对手会输，则当前玩家赢
                if (i >= 1 && j >= 4 && !dp[i-1][j-4]) {
                    dp[i][j] = true;
                }
            }
        }
        
        return dp[x][y] ? "Alice" : "Bob";
    }
};
```

## 复杂度对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 数学计算法 | O(1) | O(1) | 效率最高，代码简洁 | 需要数学推导 |
| 递归+记忆化 | O(x*y) | O(x*y) | 通用性强，易于理解 | 效率较低 |
| 动态规划 | O(x*y) | O(x*y) | 避免递归开销 | 需要额外空间 |

## 总结

1. **数学计算法**是最优解，直接利用游戏特性得出公式
2. **递归+记忆化**和**动态规划**是通用解法，适用于更复杂的博弈问题
3. 对于本题，由于约束条件简单（x,y≤100），三种方法都能通过
4. 实际面试中，推荐使用数学计算法，并解释推导过程

**推荐解法**：数学计算法，因为它是最优的，且能体现对问题本质的理解。

---

*获取时间: 2026-02-26 17:53:01*
