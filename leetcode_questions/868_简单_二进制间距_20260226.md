# 868. 二进制间距

**难度**: Easy

**标签**: 位运算

**链接**: https://leetcode.cn/problems/binary-gap/

---

## 题目描述

<p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的<strong> 最长距离 </strong>。如果不存在两个相邻的 1，返回 <code>0</code> 。</p>

<p>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 <strong>相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>"1001"</code> 中的两个 <code>1</code> 的距离为 3 。</p>

<p>&nbsp;</p>

<ul>
</ul>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 22
<strong>输出：</strong>2
<strong>解释：</strong>22 的二进制是 "10110" 。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
第一对相邻的 1 中，两个 1 之间的距离为 2 。
第二对相邻的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 8
<strong>输出：</strong>0
<strong>解释：</strong>8 的二进制是 "1000" 。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>n = 5
<strong>输出：</strong>2
<strong>解释：</strong>5 的二进制是 "101" 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int binaryGap(int n) {
        
    }
};
```

### Java

```java
class Solution {
    public int binaryGap(int n) {
        
    }
}
```

### Python3

```python3
class Solution:
    def binaryGap(self, n: int) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var binaryGap = function(n) {
    
};
```

### Go

```golang
func binaryGap(n int) int {
    
}
```

---

## 示例测试用例

```
22
```

---

## AI 解答 (DeepSeek)

## 题目分析
给定正整数 n，求其二进制表示中两个相邻 1 之间的最大距离（位置差）。如果不存在两个相邻的 1，返回 0。

**关键点**：
- 相邻 1 指的是在二进制串中，两个 1 之间可以有 0，但中间没有其他 1。
- 距离是二进制位的位置差（从最低位开始，位索引通常从 0 或 1 开始，但题目示例中距离是位置差，如 "1001" 距离为 3）。
- 示例中 "10110"（22）的二进制，索引从右向左（最低位索引 0）：
  - 位：1(4) 0(3) 1(2) 1(1) 0(0)
  - 1 的位置：4, 2, 1
  - 相邻对 (4,2) 距离 2, (2,1) 距离 1 → 最大 2。

---

## 解题思路

### 核心思路
遍历二进制位，记录上一个 1 出现的位置，当遇到新的 1 时，计算与上一个 1 的位置差，更新最大距离。

**位置计算**：
- 从最低位（索引 0）开始，每次右移 n，检查最低位是否为 1。
- 记录上一个 1 的索引 `last`，初始为 -1 表示未遇到。
- 当遇到 1 时，如果 `last != -1`，计算 `i - last` 更新最大值，然后更新 `last = i`。

---

## 解法一：位运算遍历

### 思路
从右向左遍历每一位（索引 i 从 0 开始），用 `n >> i & 1` 检查第 i 位是否为 1。

### 代码实现

#### Go
```go
func binaryGap(n int) int {
    maxDist := 0
    last := -1
    for i := 0; n > 0; i++ {
        if n&1 == 1 {
            if last != -1 {
                dist := i - last
                if dist > maxDist {
                    maxDist = dist
                }
            }
            last = i
        }
        n >>= 1
    }
    return maxDist
}
```

#### C++
```cpp
class Solution {
public:
    int binaryGap(int n) {
        int maxDist = 0;
        int last = -1;
        for (int i = 0; n > 0; i++) {
            if (n & 1) {
                if (last != -1) {
                    maxDist = max(maxDist, i - last);
                }
                last = i;
            }
            n >>= 1;
        }
        return maxDist;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(log n)，因为 n 的二进制位数是 O(log n)。
- 空间复杂度：O(1)。

---

## 解法二：只遍历 1 的位置

### 思路
不遍历所有位，只关注 1 出现的位置。用 `last` 记录上一个 1 的位置，每次找到新的 1 就计算距离。

### 代码实现

#### Go
```go
func binaryGap(n int) int {
    maxDist := 0
    last := -1
    pos := 0
    for n > 0 {
        if n&1 == 1 {
            if last != -1 {
                dist := pos - last
                if dist > maxDist {
                    maxDist = dist
                }
            }
            last = pos
        }
        n >>= 1
        pos++
    }
    return maxDist
}
```

#### C++
```cpp
class Solution {
public:
    int binaryGap(int n) {
        int maxDist = 0;
        int last = -1;
        int pos = 0;
        while (n > 0) {
            if (n & 1) {
                if (last != -1) {
                    maxDist = max(maxDist, pos - last);
                }
                last = pos;
            }
            n >>= 1;
            pos++;
        }
        return maxDist;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(log n)
- 空间复杂度：O(1)

---

## 解法三：使用内置函数（仅作参考）

### 思路
某些语言提供获取二进制位索引的函数，但为了通用性，这里用位运算模拟。

### 代码实现（Go 利用 bits.OnesCount 和 bits.TrailingZeros）
```go
import "math/bits"

func binaryGap(n int) int {
    maxDist := 0
    last := -1
    for n > 0 {
        // 获取最低位 1 的位置
        pos := bits.TrailingZeros(uint(n))
        if last != -1 {
            dist := pos - last
            if dist > maxDist {
                maxDist = dist
            }
        }
        last = pos
        // 移除最低位的 1
        n &= n - 1
    }
    return maxDist
}
```

#### C++（利用 __builtin_ctz）
```cpp
class Solution {
public:
    int binaryGap(int n) {
        int maxDist = 0;
        int last = -1;
        while (n > 0) {
            int pos = __builtin_ctz(n); // 最低位 1 的位置
            if (last != -1) {
                maxDist = max(maxDist, pos - last);
            }
            last = pos;
            n &= n - 1; // 移除最低位的 1
        }
        return maxDist;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(k)，k 是 n 中 1 的个数，最坏 O(log n)。
- 空间复杂度：O(1)

---

## 解法对比

| 解法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 解法一 | 简单直观，通用性强 | 遍历所有位，即使没有 1 也遍历 | 通用解法 |
| 解法二 | 和解法一类似，逻辑清晰 | 和解法一几乎相同 | 通用解法 |
| 解法三 | 只遍历 1 的位置，效率高 | 依赖内置函数（如 `__builtin_ctz`），可移植性差 | 对性能要求高，且环境支持内置函数 |

**推荐**：解法一或解法二，因为它们不依赖特定内置函数，代码清晰，且复杂度相同。

---

*获取时间: 2026-02-26 15:42:51*
