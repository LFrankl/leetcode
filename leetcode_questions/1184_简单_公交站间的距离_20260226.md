# 1184. 公交站间的距离

**难度**: Easy

**标签**: 数组

**链接**: https://leetcode.cn/problems/distance-between-bus-stops/

---

## 题目描述

<p>环形公交路线上有&nbsp;<code>n</code>&nbsp;个站，按次序从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code>&nbsp;表示编号为&nbsp;<code>i</code>&nbsp;的车站和编号为&nbsp;<code>(i + 1) % n</code>&nbsp;的车站之间的距离。</p>

<p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p>

<p>返回乘客从出发点&nbsp;<code>start</code>&nbsp;到目的地&nbsp;<code>destination</code>&nbsp;之间的最短距离。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg" style="height: 240px; width: 388px;"></p>

<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 1
<strong>输出：</strong>1
<strong>解释：</strong>公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</pre>

<p>&nbsp;</p>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg" style="height: 240px; width: 388px;"></p>

<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 2
<strong>输出：</strong>3
<strong>解释：</strong>公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。
</pre>

<p>&nbsp;</p>

<p><strong>示例 3：</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg" style="height: 240px; width: 388px;"></p>

<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 3
<strong>输出：</strong>4
<strong>解释：</strong>公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n&nbsp;&lt;= 10^4</code></li>
	<li><code>distance.length == n</code></li>
	<li><code>0 &lt;= start, destination &lt; n</code></li>
	<li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        
    }
};
```

### Java

```java
class Solution {
    public int distanceBetweenBusStops(int[] distance, int start, int destination) {
        
    }
}
```

### Python3

```python3
class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} distance
 * @param {number} start
 * @param {number} destination
 * @return {number}
 */
var distanceBetweenBusStops = function(distance, start, destination) {
    
};
```

### Go

```golang
func distanceBetweenBusStops(distance []int, start int, destination int) int {
    
}
```

---

## 提示

1. Find the distance between the two stops if the bus moved in clockwise or counterclockwise directions.

---

## 示例测试用例

```
[1,2,3,4]
0
1
```

---

## AI 解答 (DeepSeek)

## 题目分析

这是一个环形公交路线问题：
- 有 n 个车站（0 到 n-1）
- distance[i] 表示车站 i 到车站 (i+1)%n 的距离
- 公交车可以顺时针或逆时针行驶
- 求从 start 到 destination 的最短距离

**关键点**：
1. 环形路线有两种走法：顺时针和逆时针
2. 顺时针距离 + 逆时针距离 = 环形总距离
3. 最短距离 = min(顺时针距离, 总距离 - 顺时针距离)

---

## 解法一：直接计算两种距离

### 思路
1. 先计算从 start 到 destination 的顺时针距离
2. 计算环形总距离
3. 逆时针距离 = 总距离 - 顺时针距离
4. 返回两者中的较小值

### 代码实现

#### Go 实现
```go
func distanceBetweenBusStops(distance []int, start int, destination int) int {
    if start > destination {
        start, destination = destination, start
    }
    
    total := 0
    for _, d := range distance {
        total += d
    }
    
    clockwise := 0
    for i := start; i < destination; i++ {
        clockwise += distance[i]
    }
    
    counterClockwise := total - clockwise
    if clockwise < counterClockwise {
        return clockwise
    }
    return counterClockwise
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        if (start > destination) {
            swap(start, destination);
        }
        
        int total = 0;
        for (int d : distance) {
            total += d;
        }
        
        int clockwise = 0;
        for (int i = start; i < destination; i++) {
            clockwise += distance[i];
        }
        
        int counterClockwise = total - clockwise;
        return min(clockwise, counterClockwise);
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，需要遍历数组两次（一次计算总距离，一次计算顺时针距离）
- **空间复杂度**：O(1)，只使用了常数个额外变量

---

## 解法二：单次遍历同时计算

### 思路
在一次遍历中同时计算：
1. 总距离
2. 从 start 到 destination 的顺时针距离
这样可以减少一次遍历

### 代码实现

#### Go 实现
```go
func distanceBetweenBusStops(distance []int, start int, destination int) int {
    if start > destination {
        start, destination = destination, start
    }
    
    total := 0
    clockwise := 0
    
    for i, d := range distance {
        total += d
        if i >= start && i < destination {
            clockwise += d
        }
    }
    
    counterClockwise := total - clockwise
    if clockwise < counterClockwise {
        return clockwise
    }
    return counterClockwise
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        if (start > destination) {
            swap(start, destination);
        }
        
        int total = 0;
        int clockwise = 0;
        
        for (int i = 0; i < distance.size(); i++) {
            total += distance[i];
            if (i >= start && i < destination) {
                clockwise += distance[i];
            }
        }
        
        int counterClockwise = total - clockwise;
        return min(clockwise, counterClockwise);
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，只需要遍历数组一次
- **空间复杂度**：O(1)，只使用了常数个额外变量

---

## 解法三：模运算处理环形（不交换 start 和 destination）

### 思路
不交换 start 和 destination，而是通过模运算来处理环形遍历

### 代码实现

#### Go 实现
```go
func distanceBetweenBusStops(distance []int, start int, destination int) int {
    n := len(distance)
    clockwise := 0
    
    // 计算顺时针距离
    i := start
    for i != destination {
        clockwise += distance[i]
        i = (i + 1) % n
    }
    
    // 计算总距离
    total := 0
    for _, d := range distance {
        total += d
    }
    
    counterClockwise := total - clockwise
    if clockwise < counterClockwise {
        return clockwise
    }
    return counterClockwise
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int n = distance.size();
        int clockwise = 0;
        
        // 计算顺时针距离
        int i = start;
        while (i != destination) {
            clockwise += distance[i];
            i = (i + 1) % n;
        }
        
        // 计算总距离
        int total = 0;
        for (int d : distance) {
            total += d;
        }
        
        int counterClockwise = total - clockwise;
        return min(clockwise, counterClockwise);
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，最坏情况下需要遍历整个环形
- **空间复杂度**：O(1)

---

## 解法对比

| 特性 | 解法一 | 解法二 | 解法三 |
|------|--------|--------|--------|
| 时间复杂度 | O(n) | O(n) | O(n) |
| 空间复杂度 | O(1) | O(1) | O(1) |
| 遍历次数 | 2次 | 1次 | 2次 |
| 代码简洁性 | 简单 | 简单 | 中等 |
| 是否需要交换 | 需要 | 需要 | 不需要 |
| 实际性能 | 良好 | 最优 | 良好 |

**推荐使用解法二**：
1. 只需要一次遍历，效率最高
2. 代码简洁易懂
3. 实际性能最好

**注意事项**：
- 解法一和解法二都先交换了 start 和 destination 确保 start < destination，这样计算顺时针距离更简单
- 解法三展示了不交换的模运算方法，但实际代码稍复杂
- 所有解法都利用了环形路线的特性：顺时针距离 + 逆时针距离 = 总距离

---

## 总结

这道题的核心是理解环形路线的特性：
1. 从 A 到 B 有两条路径：顺时针和逆时针
2. 两条路径的距离之和等于环形总距离
3. 最短距离就是两条路径中的较小值

最简单的实现思路是：
1. 确保 start < destination（交换）
2. 计算总距离和顺时针距离
3. 逆时针距离 = 总距离 - 顺时针距离
4. 返回两者中的较小值

在实际编码中，解法二（单次遍历）是最优选择。

---

*获取时间: 2026-02-26 15:17:42*
