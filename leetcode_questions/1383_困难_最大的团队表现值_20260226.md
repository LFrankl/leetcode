# 1383. 最大的团队表现值

**难度**: Hard

**标签**: 贪心, 数组, 排序, 堆（优先队列）

**链接**: https://leetcode.cn/problems/maximum-performance-of-a-team/

---

## 题目描述

<p>给定两个整数 <code>n</code> 和 <code>k</code>，以及两个长度为 <code>n</code> 的整数数组 <code>speed</code> 和<code> efficiency</code>。现有 <code>n</code> 名工程师，编号从 <code>1</code> 到 <code>n</code>。其中 <code>speed[i]</code>&nbsp;和 <code>efficiency[i]</code>&nbsp;分别代表第 <code>i</code>&nbsp;位工程师的速度和效率。</p>

<p>从这 <code>n</code> 名工程师中最多选择 <code>k</code> 名不同的工程师，使其组成的团队具有最大的团队表现值。</p>

<p><strong>团队表现值</strong>&nbsp;的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p>

<p>请你返回该团队的​​​​​​最大团队表现值，由于答案可能很大，请你返回结果对 <code>10^9 + 7</code> 取余后的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
<strong>输出：</strong>60
<strong>解释：</strong>
我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
<strong>输出：</strong>68
<strong>解释：
</strong>此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
<strong>输出：</strong>72
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= n &lt;= 10^5</code></li>
	<li><code>speed.length == n</code></li>
	<li><code>efficiency.length == n</code></li>
	<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>
	<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        
    }
};
```

### Java

```java
class Solution {
    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {
        
    }
}
```

### Python3

```python3
class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number} n
 * @param {number[]} speed
 * @param {number[]} efficiency
 * @param {number} k
 * @return {number}
 */
var maxPerformance = function(n, speed, efficiency, k) {
    
};
```

### Go

```golang
func maxPerformance(n int, speed []int, efficiency []int, k int) int {
    
}
```

---

## 提示

1. Keep track of the engineers by their efficiency in decreasing order.
2. Starting from one engineer, to build a team, it suffices to bring K-1 more engineers who have higher efficiencies as well as high speeds.

---

## 示例测试用例

```
6
[2,10,3,1,5,8]
[5,4,3,9,7,2]
2
```

---

## AI 解答 (DeepSeek)

## 题目分析

我们需要从 n 个工程师中选出最多 k 个，使得 `(速度之和) × min(效率)` 最大。

**关键点**：
- 团队表现值由两部分决定：速度总和和效率最小值
- 效率最小值由团队中效率最低的成员决定
- 速度总和是选中的工程师速度之和

## 解题思路

### 核心思路
1. **按效率排序**：如果我们固定某个工程师的效率作为团队的最小效率，那么所有效率不低于该工程师的工程师都可以被选择
2. **选择速度最大的 k-1 个**：在效率不低于当前工程师的所有工程师中，选择速度最大的 k-1 个（加上当前工程师自己，共最多 k 个）
3. **遍历所有可能的效率最小值**：对每个工程师作为效率最小值的情况进行计算，取最大值

### 具体实现方法
- 将工程师按效率降序排序
- 使用最小堆维护当前选中的工程师的速度
- 遍历排序后的工程师：
  - 将当前工程师的速度加入堆和速度总和
  - 如果堆的大小超过 k，移除速度最小的工程师（因为效率已经由当前工程师决定，我们只需要速度最大的 k-1 个）
  - 计算当前团队表现值：速度总和 × 当前工程师的效率
  - 更新最大团队表现值

## 解法详解

### 解法一：排序 + 最小堆（推荐）
**思路**：
1. 将工程师按效率降序排序
2. 遍历每个工程师，将其作为效率最小值
3. 使用最小堆维护当前选中的工程师的速度
4. 始终保持堆的大小不超过 k
5. 计算并更新最大表现值

```go
func maxPerformance(n int, speed []int, efficiency []int, k int) int {
    const MOD = 1e9 + 7
    
    // 创建工程师列表
    engineers := make([][2]int, n)
    for i := 0; i < n; i++ {
        engineers[i] = [2]int{efficiency[i], speed[i]}
    }
    
    // 按效率降序排序
    sort.Slice(engineers, func(i, j int) bool {
        return engineers[i][0] > engineers[j][0]
    })
    
    // 最小堆（使用 container/heap）
    h := &minHeap{}
    heap.Init(h)
    
    totalSpeed := 0
    maxPerf := 0
    
    for _, eng := range engineers {
        eff, spd := eng[0], eng[1]
        
        // 将当前工程师的速度加入堆
        heap.Push(h, spd)
        totalSpeed += spd
        
        // 如果堆的大小超过 k，移除速度最小的
        if h.Len() > k {
            minSpd := heap.Pop(h).(int)
            totalSpeed -= minSpd
        }
        
        // 计算当前团队表现值
        perf := totalSpeed * eff
        if perf > maxPerf {
            maxPerf = perf
        }
    }
    
    return maxPerf % MOD
}

// 最小堆实现
type minHeap []int

func (h minHeap) Len() int           { return len(h) }
func (h minHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h minHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *minHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *minHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[:n-1]
    return x
}
```

```cpp
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

class Solution {
public:
    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        const int MOD = 1e9 + 7;
        
        // 创建工程师列表并排序
        vector<pair<int, int>> engineers;
        for (int i = 0; i < n; i++) {
            engineers.emplace_back(efficiency[i], speed[i]);
        }
        
        // 按效率降序排序
        sort(engineers.rbegin(), engineers.rend());
        
        // 最小堆（使用 priority_queue）
        priority_queue<int, vector<int>, greater<int>> minHeap;
        
        long long totalSpeed = 0;
        long long maxPerf = 0;
        
        for (auto& eng : engineers) {
            int eff = eng.first;
            int spd = eng.second;
            
            // 将当前工程师的速度加入堆
            minHeap.push(spd);
            totalSpeed += spd;
            
            // 如果堆的大小超过 k，移除速度最小的
            if (minHeap.size() > k) {
                totalSpeed -= minHeap.top();
                minHeap.pop();
            }
            
            // 计算当前团队表现值
            long long perf = totalSpeed * eff;
            if (perf > maxPerf) {
                maxPerf = perf;
            }
        }
        
        return maxPerf % MOD;
    }
};
```

**时间复杂度**：O(n log n)
- 排序：O(n log n)
- 堆操作：每个元素最多入堆出堆一次，O(n log k)

**空间复杂度**：O(n + k)
- 存储工程师列表：O(n)
- 堆：O(k)

### 解法二：排序 + 前缀和（仅适用于 k 较小的情况）
**思路**：
1. 按效率降序排序
2. 对于每个位置 i，考虑以 engineers[i] 的效率作为最小值
3. 在 i 之前（效率更高）的工程师中，选择速度最大的 k-1 个
4. 可以使用前缀最大 k 个速度的和来优化

```go
// 注意：这种方法在 k 较大时效率较低，仅作为思路展示
func maxPerformance2(n int, speed []int, efficiency []int, k int) int {
    const MOD = 1e9 + 7
    
    engineers := make([][2]int, n)
    for i := 0; i < n; i++ {
        engineers[i] = [2]int{efficiency[i], speed[i]}
    }
    
    // 按效率降序排序
    sort.Slice(engineers, func(i, j int) bool {
        return engineers[i][0] > engineers[j][0]
    })
    
    maxPerf := 0
    
    for i := 0; i < n; i++ {
        eff := engineers[i][0]
        
        // 收集所有效率 >= eff 的工程师的速度
        speeds := make([]int, 0)
        for j := 0; j <= i; j++ {
            speeds = append(speeds, engineers[j][1])
        }
        
        // 取最大的 min(k, len(speeds)) 个速度
        sort.Sort(sort.Reverse(sort.IntSlice(speeds)))
        
        totalSpeed := 0
        for j := 0; j < min(k, len(speeds)); j++ {
            totalSpeed += speeds[j]
        }
        
        perf := totalSpeed * eff
        if perf > maxPerf {
            maxPerf = perf
        }
    }
    
    return maxPerf % MOD
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```cpp
// 注意：这种方法在 k 较大时效率较低，仅作为思路展示
int maxPerformance2(int n, vector<int>& speed, vector<int>& efficiency, int k) {
    const int MOD = 1e9 + 7;
    
    vector<pair<int, int>> engineers;
    for (int i = 0; i < n; i++) {
        engineers.emplace_back(efficiency[i], speed[i]);
    }
    
    // 按效率降序排序
    sort(engineers.rbegin(), engineers.rend());
    
    long long maxPerf = 0;
    
    for (int i = 0; i < n; i++) {
        int eff = engineers[i].first;
        
        // 收集所有效率 >= eff 的工程师的速度
        vector<int> speeds;
        for (int j = 0; j <= i; j++) {
            speeds.push_back(engineers[j].second);
        }
        
        // 取最大的 min(k, (int)speeds.size()) 个速度
        sort(speeds.rbegin(), speeds.rend());
        
        long long totalSpeed = 0;
        int limit = min(k, (int)speeds.size());
        for (int j = 0; j < limit; j++) {
            totalSpeed += speeds[j];
        }
        
        long long perf = totalSpeed * eff;
        if (perf > maxPerf) {
            maxPerf = perf;
        }
    }
    
    return maxPerf % MOD;
}
```

**时间复杂度**：O(n² log n) 或 O(n²)
- 外层循环：O(n)
- 内层收集和排序：O(n log n)
- 总体：O(n² log n)

**空间复杂度**：O(n)

### 解法三：排序 + 平衡二叉搜索树（multiset）
**思路**：
1. 按效率降序排序
2. 使用平衡二叉搜索树（如 C++ 的 multiset）维护当前选中的工程师速度
3. 始终保持选中的工程师数量不超过 k
4. 可以快速获取和删除最小速度

```go
// Go 标准库没有平衡二叉搜索树，这里使用堆是更好的选择
// 此解法主要展示 C++ 的实现
```

```cpp
#include <vector>
#include <algorithm>
#include <set>
using namespace std;

class Solution {
public:
    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        const int MOD = 1e9 + 7;
        
        vector<pair<int, int>> engineers;
        for (int i = 0; i < n; i++) {
            engineers.emplace_back(efficiency[i], speed[i]);
        }
        
        // 按效率降序排序
        sort(engineers.rbegin(), engineers.rend());
        
        multiset<int> speeds;
        long long totalSpeed = 0;
        long long maxPerf = 0;
        
        for (auto& eng : engineers) {
            int eff = eng.first;
            int spd = eng.second;
            
            // 将当前工程师的速度加入集合
            speeds.insert(spd);
            totalSpeed += spd;
            
            // 如果集合大小超过 k，移除速度最小的
            if (speeds.size() > k) {
                totalSpeed -= *speeds.begin();
                speeds.erase(speeds.begin());
            }
            
            // 计算当前团队表现值
            long long perf = totalSpeed * eff;
            if (perf > maxPerf) {
                maxPerf = perf;
            }
        }
        
        return maxPerf % MOD;
    }
};
```

**时间复杂度**：O(n log n)
- 排序：O(n log n)
- multiset 操作：每个元素插入删除一次，O(n log k)

**空间复杂度**：O(n + k)

## 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 排序+最小堆 | O(n log n) | O(n + k) | 效率高，实现简单 | 需要维护堆 |
| 排序+前缀和 | O(n² log n) | O(n) | 思路直观 | 效率低，仅适用于小规模数据 |
| 排序+multiset | O(n log n) | O(n + k) | 可以方便地获取和删除任意元素 | 常数因子较大，不如堆高效 |

## 总结

**推荐使用解法一（排序+最小堆）**，因为：
1. 时间复杂度最优：O(n log n)
2. 空间复杂度合理：O(n + k)
3. 实现相对简单
4. 适用于题目给定的数据范围（n ≤ 10^5）

**关键点**：
- 按效率降序排序，确保遍历时当前工程师的效率是团队最小值
- 使用最小堆维护速度，确保可以快速移除最小速度
- 遍历过程中动态更新速度总和和最大表现值
- 注意使用长整型避免溢出，最后取模

---

*获取时间: 2026-02-26 16:18:53*
