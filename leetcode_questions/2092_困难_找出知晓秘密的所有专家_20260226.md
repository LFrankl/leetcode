# 2092. 找出知晓秘密的所有专家

**难度**: Hard

**标签**: 深度优先搜索, 广度优先搜索, 并查集, 图, 排序

**链接**: https://leetcode.cn/problems/find-all-people-with-secret/

---

## 题目描述

<p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code> 编号。另外给你一个下标从 0 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示专家 <code>x<sub>i</sub></code> 和专家 <code>y<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 要开一场会。一个专家可以同时参加 <strong>多场会议</strong> 。最后，给你一个整数 <code>firstPerson</code> 。</p>

<p>专家 <code>0</code> 有一个 <strong>秘密</strong> ，最初，他在时间&nbsp;<code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>x<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 时知晓这个秘密，那么他将会与专家 <code>y<sub>i</sub></code> 分享这个秘密，反之亦然。</p>

<p>秘密共享是 <strong>瞬时发生</strong> 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p>

<p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>输出：</strong>[0,1,2,3,5]
<strong>解释：
</strong>时间 0 ，专家 0 将秘密与专家 1 共享。
时间 5 ，专家 1 将秘密与专家 2 共享。
时间 8 ，专家 2 将秘密与专家 3 共享。
时间 10 ，专家 1 将秘密与专家 5 共享。
因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>输出：</strong>[0,1,3]
<strong>解释：</strong>
时间 0 ，专家 0 将秘密与专家 3 共享。
时间 2 ，专家 1 与专家 2 都不知晓这个秘密。
时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。
因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>输出：</strong>[0,1,2,3,4]
<strong>解释：</strong>
时间 0 ，专家 0 将秘密与专家 1 共享。
时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。
注意，专家 2 可以在收到秘密的同一时间分享此秘密。
时间 2 ，专家 3 将秘密与专家 4 共享。
因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
	<li><code>meetings[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        
    }
};
```

### Java

```java
class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        
    }
}
```

### Python3

```python3
class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        
```

### JavaScript

```javascript
/**
 * @param {number} n
 * @param {number[][]} meetings
 * @param {number} firstPerson
 * @return {number[]}
 */
var findAllPeople = function(n, meetings, firstPerson) {
    
};
```

### Go

```golang
func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    
}
```

---

## 提示

1. Could you model all the meetings happening at the same time as a graph?
2. What data structure can you use to efficiently share the secret?
3. You can use the union-find data structure to quickly determine who knows the secret and share the secret.

---

## 示例测试用例

```
6
[[1,2,5],[2,3,8],[1,5,10]]
1
```

---

## AI 解答 (DeepSeek)

## 题目分析

这是一个**时间依赖的图传播问题**。专家是节点，会议是边，但边只在特定时间点有效。秘密从专家0和firstPerson开始，通过会议在专家间传播。关键点：
- 会议按时间顺序发生
- 同一时间可能有多个会议同时进行
- 秘密传播是瞬时的（同一时间可以传播多次）

## 解题思路

核心思想：**按时间分组处理会议**，对每个时间点的会议集合，使用并查集（Union-Find）来合并知晓秘密的专家。

### 关键观察
1. 同一时间点的会议可以任意顺序发生，秘密可以在这些会议中传播
2. 不同时间点的会议需要按时间顺序处理
3. 如果一组专家在同一时间通过会议连通，且其中至少一人知晓秘密，则整组都会知晓

## 解法一：按时间分组 + 并查集（推荐）

### 思路
1. 按会议时间分组
2. 对每个时间点的会议：
   - 用并查集连接参会专家
   - 检查每个连通分量：如果包含已知秘密的专家，标记整个分量为知晓秘密
3. 处理完一个时间点后，重置并查集（只保留知晓秘密的状态）

```go
func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // 按时间分组会议
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        x, y, t := meeting[0], meeting[1], meeting[2]
        timeMap[t] = append(timeMap[t], [2]int{x, y})
    }
    
    // 已知秘密的专家
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true
    
    // 获取所有时间点并排序
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)
    
    for _, t := range times {
        meetingsAtTime := timeMap[t]
        
        // 构建当前时间点的图
        graph := make(map[int][]int)
        experts := make(map[int]bool)
        
        for _, meeting := range meetingsAtTime {
            x, y := meeting[0], meeting[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
            experts[x] = true
            experts[y] = true
        }
        
        // BFS传播秘密
        queue := make([]int, 0)
        visited := make(map[int]bool)
        
        // 将所有已知秘密的专家加入队列
        for expert := range experts {
            if known[expert] && !visited[expert] {
                queue = append(queue, expert)
                visited[expert] = true
            }
        }
        
        // BFS遍历
        for len(queue) > 0 {
            curr := queue[0]
            queue = queue[1:]
            
            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }
    
    // 收集结果
    result := make([]int, 0)
    for i := 0; i < n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
```

```cpp
class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        // 按时间分组会议
        map<int, vector<pair<int, int>>> timeMap;
        for (auto& meeting : meetings) {
            int x = meeting[0], y = meeting[1], t = meeting[2];
            timeMap[t].push_back({x, y});
        }
        
        // 已知秘密的专家
        vector<bool> known(n, false);
        known[0] = true;
        known[firstPerson] = true;
        
        for (auto& [time, meetingsAtTime] : timeMap) {
            // 构建当前时间点的图
            unordered_map<int, vector<int>> graph;
            unordered_set<int> experts;
            
            for (auto& [x, y] : meetingsAtTime) {
                graph[x].push_back(y);
                graph[y].push_back(x);
                experts.insert(x);
                experts.insert(y);
            }
            
            // BFS传播秘密
            queue<int> q;
            unordered_set<int> visited;
            
            // 将所有已知秘密的专家加入队列
            for (int expert : experts) {
                if (known[expert] && !visited.count(expert)) {
                    q.push(expert);
                    visited.insert(expert);
                }
            }
            
            // BFS遍历
            while (!q.empty()) {
                int curr = q.front();
                q.pop();
                
                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }
        
        // 收集结果
        vector<int> result;
        for (int i = 0; i < n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
```

**时间复杂度**：O(T + M + N)，其中T是不同时间点数量，M是会议数，N是专家数
**空间复杂度**：O(N + M)

## 解法二：并查集 + 时间排序优化

### 思路
使用并查集，但在每个时间点处理完后，需要重置那些不知道秘密的专家的连接状态。

```go
func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // 按时间排序会议
    sort.Slice(meetings, func(i, j int) bool {
        return meetings[i][2] < meetings[j][2]
    })
    
    // 初始化并查集
    parent := make([]int, n)
    for i := range parent {
        parent[i] = i
    }
    
    // 合并0和firstPerson
    union(parent, 0, firstPerson)
    
    i := 0
    m := len(meetings)
    
    for i < m {
        j := i
        // 找到相同时间的所有会议
        for j < m && meetings[j][2] == meetings[i][2] {
            j++
        }
        
        // 连接当前时间的所有专家
        for k := i; k < j; k++ {
            union(parent, meetings[k][0], meetings[k][1])
        }
        
        // 检查哪些专家知道了秘密
        for k := i; k < j; k++ {
            x, y := meetings[k][0], meetings[k][1]
            if find(parent, x) == find(parent, 0) {
                // 这个连通分量知道了秘密
            } else {
                // 重置不知道秘密的专家
                parent[x] = x
                parent[y] = y
            }
        }
        
        i = j
    }
    
    // 收集知道秘密的专家
    result := []int{}
    for idx := 0; idx < n; idx++ {
        if find(parent, idx) == find(parent, 0) {
            result = append(result, idx)
        }
    }
    return result
}

func find(parent []int, x int) int {
    if parent[x] != x {
        parent[x] = find(parent, parent[x])
    }
    return parent[x]
}

func union(parent []int, x, y int) {
    rootX := find(parent, x)
    rootY := find(parent, y)
    if rootX != rootY {
        parent[rootY] = rootX
    }
}
```

```cpp
class Solution {
private:
    vector<int> parent;
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootY] = rootX;
        }
    }
    
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        // 按时间排序会议
        sort(meetings.begin(), meetings.end(), 
             [](const vector<int>& a, const vector<int>& b) {
                 return a[2] < b[2];
             });
        
        // 初始化并查集
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        
        // 合并0和firstPerson
        unite(0, firstPerson);
        
        int m = meetings.size();
        for (int i = 0; i < m; ) {
            int j = i;
            // 找到相同时间的所有会议
            while (j < m && meetings[j][2] == meetings[i][2]) {
                j++;
            }
            
            // 连接当前时间的所有专家
            for (int k = i; k < j; k++) {
                unite(meetings[k][0], meetings[k][1]);
            }
            
            // 检查并重置不知道秘密的专家
            for (int k = i; k < j; k++) {
                int x = meetings[k][0], y = meetings[k][1];
                if (find(x) != find(0)) {
                    // 重置不知道秘密的专家
                    parent[x] = x;
                    parent[y] = y;
                }
            }
            
            i = j;
        }
        
        // 收集知道秘密的专家
        vector<int> result;
        for (int i = 0; i < n; i++) {
            if (find(i) == find(0)) {
                result.push_back(i);
            }
        }
        return result;
    }
};
```

**时间复杂度**：O(M log M + M α(N))，其中α是反阿克曼函数
**空间复杂度**：O(N)

## 解法三：BFS按层传播

### 思路
将会议按时间排序，使用BFS按时间层传播秘密。

```go
func findAllPeople(n int, meetings [][]int, firstPerson int) []int {
    // 构建邻接表：时间 -> [专家对]
    timeMap := make(map[int][][2]int)
    for _, meeting := range meetings {
        timeMap[meeting[2]] = append(timeMap[meeting[2]], [2]int{meeting[0], meeting[1]})
    }
    
    // 获取所有时间并排序
    times := make([]int, 0, len(timeMap))
    for t := range timeMap {
        times = append(times, t)
    }
    sort.Ints(times)
    
    // 已知秘密的专家
    known := make([]bool, n)
    known[0] = true
    known[firstPerson] = true
    
    for _, t := range times {
        // 构建当前时间的图
        graph := make(map[int][]int)
        for _, pair := range timeMap[t] {
            x, y := pair[0], pair[1]
            graph[x] = append(graph[x], y)
            graph[y] = append(graph[y], x)
        }
        
        // BFS队列
        queue := make([]int, 0)
        visited := make(map[int]bool)
        
        // 添加当前已知秘密的专家
        for node := range graph {
            if known[node] && !visited[node] {
                queue = append(queue, node)
                visited[node] = true
            }
        }
        
        // BFS传播
        for len(queue) > 0 {
            curr := queue[0]
            queue = queue[1:]
            
            for _, neighbor := range graph[curr] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    known[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
    }
    
    // 收集结果
    result := make([]int, 0)
    for i := 0; i < n; i++ {
        if known[i] {
            result = append(result, i)
        }
    }
    return result
}
```

```cpp
class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        // 构建时间映射
        map<int, vector<pair<int, int>>> timeMap;
        for (auto& meeting : meetings) {
            timeMap[meeting[2]].push_back({meeting[0], meeting[1]});
        }
        
        vector<bool> known(n, false);
        known[0] = true;
        known[firstPerson] = true;
        
        for (auto& [time, pairs] : timeMap) {
            // 构建当前时间的图
            unordered_map<int, vector<int>> graph;
            for (auto& [x, y] : pairs) {
                graph[x].push_back(y);
                graph[y].push_back(x);
            }
            
            // BFS传播
            queue<int> q;
            unordered_set<int> visited;
            
            // 添加已知秘密的专家
            for (auto& [node, _] : graph) {
                if (known[node] && !visited.count(node)) {
                    q.push(node);
                    visited.insert(node);
                }
            }
            
            while (!q.empty()) {
                int curr = q.front();
                q.pop();
                
                for (int neighbor : graph[curr]) {
                    if (!visited.count(neighbor)) {
                        visited.insert(neighbor);
                        known[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }
        
        vector<int> result;
        for (int i = 0; i < n; i++) {
            if (known[i]) {
                result.push_back(i);
            }
        }
        return result;
    }
};
```

**时间复杂度**：O(T + M + N)
**空间复杂度**：O(N + M)

## 复杂度对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 解法一 | O(T + M + N) | O(N + M) | 逻辑清晰，易于理解 | 需要额外存储时间分组 |
| 解法二 | O(M log M + M α(N)) | O(N) | 空间效率高，使用并查集 | 需要重置并查集状态 |
| 解法三 | O(T + M + N) | O(N + M) | BFS直观，适合图传播 | 需要构建时间映射 |

## 总结

1. **解法一（分组+BFS）** 是最直观的解法，适合理解和实现
2. **解法二（并查集）** 空间效率最高，但需要小心处理状态重置
3. **解法三（BFS分层）** 与解法一类似，但更强调时间分层

**推荐使用解法一**，因为：
- 逻辑清晰，易于理解和调试
- 时间复杂度与最优解相同
- 适合处理大规模数据
- 代码可读性好，易于维护

在实际LeetCode提交中，解法一和解法二都有很好的性能表现，可以根据个人偏好选择。

---

*获取时间: 2026-02-26 19:08:03*
