# 496. 下一个更大元素 I

**难度**: Easy

**标签**: 栈, 数组, 哈希表, 单调栈

**链接**: https://leetcode.cn/problems/next-greater-element-i/

---

## 题目描述

<p><code>nums1</code>&nbsp;中数字&nbsp;<code>x</code>&nbsp;的 <strong>下一个更大元素</strong> 是指&nbsp;<code>x</code>&nbsp;在&nbsp;<code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比&nbsp;<code>x</code><strong>&nbsp;</strong>大的元素。</p>

<p>给你两个<strong> 没有重复元素</strong> 的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code>&nbsp;是&nbsp;<code>nums2</code>&nbsp;的子集。</p>

<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>

<p>返回一个长度为&nbsp;<code>nums1.length</code> 的数组<em> </em><code>ans</code><em> </em>作为答案，满足<em> </em><code>ans[i]</code><em> </em>是如上所述的 <strong>下一个更大元素</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [4,1,2], nums2 = [1,3,4,2].
<strong>输出：</strong>[-1,3,-1]
<strong>解释：</strong>nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,<strong>4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [<em><strong>1</strong></em>,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,<em><strong>2</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [2,4], nums2 = [1,2,3,4].
<strong>输出：</strong>[3,-1]
<strong>解释：</strong>nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,<em><strong>2</strong></em>,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,<em><strong>4</strong></em>]。不存在下一个更大元素，所以答案是 -1 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
	<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

### Java

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        
    }
}
```

### Python3

```python3
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var nextGreaterElement = function(nums1, nums2) {
    
};
```

### Go

```golang
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    
}
```

---

## 示例测试用例

```
[4,1,2]
[1,3,4,2]
```

---

## AI 解答 (DeepSeek)

## 题目分析

这是一个经典的"下一个更大元素"问题。给定两个数组：
- `nums1` 是 `nums2` 的子集
- 对于 `nums1` 中的每个元素，需要在 `nums2` 中找到该元素，然后在其右侧找到第一个比它大的元素

关键约束：
1. 所有元素互不相同
2. `nums1` 是 `nums2` 的子集
3. 数组长度 ≤ 1000

## 解题思路

### 核心思路
我们需要为 `nums2` 中的每个元素找到其右侧第一个更大的元素，然后将 `nums1` 中元素对应的结果提取出来。

### 方法对比
1. **暴力法**：直接遍历查找，简单但效率低
2. **哈希表+单调栈**：最优解，利用单调递减栈一次遍历 `nums2`，同时用哈希表记录结果
3. **哈希表+反向遍历**：从右向左遍历，利用哈希表记录已处理元素的下一个更大值

## 解法详解

### 解法一：暴力法（双重循环）
**思路**：
1. 对于 `nums1` 中的每个元素，先在 `nums2` 中找到它的位置
2. 从该位置开始向右遍历，找到第一个更大的元素

**时间复杂度**：O(n×m)，其中 n=nums1.length, m=nums2.length
**空间复杂度**：O(1)（不考虑输出数组）

```go
// Go 实现
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    result := make([]int, len(nums1))
    
    for i, num := range nums1 {
        // 在 nums2 中找到 num 的位置
        found := false
        result[i] = -1
        
        for j := 0; j < len(nums2); j++ {
            if nums2[j] == num {
                found = true
            }
            if found && nums2[j] > num {
                result[i] = nums2[j]
                break
            }
        }
    }
    
    return result
}
```

```cpp
// C++ 实现
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> result(nums1.size(), -1);
        
        for (int i = 0; i < nums1.size(); i++) {
            bool found = false;
            
            for (int j = 0; j < nums2.size(); j++) {
                if (nums2[j] == nums1[i]) {
                    found = true;
                }
                if (found && nums2[j] > nums1[i]) {
                    result[i] = nums2[j];
                    break;
                }
            }
        }
        
        return result;
    }
};
```

### 解法二：哈希表+单调栈（最优解）
**思路**：
1. 使用单调递减栈处理 `nums2`
2. 遍历 `nums2`，当当前元素大于栈顶元素时，栈顶元素的下一个更大元素就是当前元素
3. 用哈希表记录每个元素的下一个更大元素
4. 最后遍历 `nums1`，从哈希表中获取结果

**时间复杂度**：O(n+m)，其中 n=nums1.length, m=nums2.length
**空间复杂度**：O(m)，用于存储哈希表和栈

```go
// Go 实现
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    // 使用哈希表存储每个元素的下一个更大元素
    nextGreater := make(map[int]int)
    stack := make([]int, 0)  // 单调递减栈
    
    // 遍历 nums2
    for _, num := range nums2 {
        // 当栈不为空且当前元素大于栈顶元素时
        for len(stack) > 0 && num > stack[len(stack)-1] {
            // 栈顶元素的下一个更大元素是当前元素
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            nextGreater[top] = num
        }
        // 当前元素入栈
        stack = append(stack, num)
    }
    
    // 栈中剩余元素没有下一个更大元素，设为 -1
    for _, num := range stack {
        nextGreater[num] = -1
    }
    
    // 构建结果
    result := make([]int, len(nums1))
    for i, num := range nums1 {
        result[i] = nextGreater[num]
    }
    
    return result
}
```

```cpp
// C++ 实现
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> nextGreater;
        stack<int> st;  // 单调递减栈
        
        // 遍历 nums2
        for (int num : nums2) {
            // 当栈不为空且当前元素大于栈顶元素时
            while (!st.empty() && num > st.top()) {
                nextGreater[st.top()] = num;
                st.pop();
            }
            // 当前元素入栈
            st.push(num);
        }
        
        // 栈中剩余元素没有下一个更大元素
        while (!st.empty()) {
            nextGreater[st.top()] = -1;
            st.pop();
        }
        
        // 构建结果
        vector<int> result(nums1.size());
        for (int i = 0; i < nums1.size(); i++) {
            result[i] = nextGreater[nums1[i]];
        }
        
        return result;
    }
};
```

### 解法三：哈希表+反向遍历
**思路**：
1. 从右向左遍历 `nums2`
2. 维护一个哈希表，记录已处理元素的下一个更大值
3. 对于每个元素，向右查找第一个更大的元素

**时间复杂度**：O(m²) 最坏情况，但实际运行较快
**空间复杂度**：O(m)

```go
// Go 实现
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    // 存储每个元素的下一个更大元素
    nextMap := make(map[int]int)
    
    // 从右向左遍历 nums2
    for i := len(nums2) - 1; i >= 0; i-- {
        j := i + 1
        // 向右查找第一个更大的元素
        for j < len(nums2) && nums2[j] <= nums2[i] {
            // 如果 nums2[j] 的下一个更大元素存在且大于当前元素
            if next, ok := nextMap[nums2[j]]; ok && next > nums2[i] {
                j = len(nums2)  // 可以直接使用这个更大的元素
                break
            }
            j++
        }
        
        if j < len(nums2) {
            nextMap[nums2[i]] = nums2[j]
        } else {
            nextMap[nums2[i]] = -1
        }
    }
    
    // 构建结果
    result := make([]int, len(nums1))
    for i, num := range nums1 {
        result[i] = nextMap[num]
    }
    
    return result
}
```

```cpp
// C++ 实现
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> nextMap;
        
        // 从右向左遍历 nums2
        for (int i = nums2.size() - 1; i >= 0; i--) {
            int j = i + 1;
            // 向右查找第一个更大的元素
            while (j < nums2.size() && nums2[j] <= nums2[i]) {
                // 如果 nums2[j] 的下一个更大元素存在且大于当前元素
                if (nextMap.count(nums2[j]) && nextMap[nums2[j]] > nums2[i]) {
                    j = nums2.size();  // 可以直接使用这个更大的元素
                    break;
                }
                j++;
            }
            
            if (j < nums2.size()) {
                nextMap[nums2[i]] = nums2[j];
            } else {
                nextMap[nums2[i]] = -1;
            }
        }
        
        // 构建结果
        vector<int> result(nums1.size());
        for (int i = 0; i < nums1.size(); i++) {
            result[i] = nextMap[nums1[i]];
        }
        
        return result;
    }
};
```

## 复杂度分析对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 暴力法 | O(n×m) | O(1) | 实现简单，易于理解 | 效率低，不适合大数据量 |
| 哈希表+单调栈 | O(n+m) | O(m) | 最优时间复杂度，效率高 | 需要理解单调栈概念 |
| 哈希表+反向遍历 | O(m²) 最坏 | O(m) | 思路直观，比暴力法优化 | 最坏情况效率仍不高 |

## 推荐解法

**哈希表+单调栈**是最优解法，理由如下：
1. 时间复杂度最优：O(n+m)，满足进阶要求
2. 空间复杂度合理：O(m)，只存储必要信息
3. 通用性强：该模式可解决一系列"下一个更大/更小元素"问题
4. 代码简洁：实现优雅，逻辑清晰

## 关键点总结
1. **单调栈**是解决这类问题的核心数据结构
2. **哈希表**用于快速查询结果
3. 注意处理栈中剩余元素（没有下一个更大元素的元素）
4. 利用题目条件（元素互不相同）简化实现

这种解法不仅适用于本题，还可以扩展到：
- 下一个更大元素 II（循环数组）
- 每日温度问题
- 柱状图中最大矩形等经典问题

---

*获取时间: 2026-02-26 15:29:28*
