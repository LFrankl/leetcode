# 777. 在 LR 字符串中交换相邻字符

**难度**: Medium

**标签**: 双指针, 字符串

**链接**: https://leetcode.cn/problems/swap-adjacent-in-lr-string/

---

## 题目描述

<p>在一个由 <code>'L'</code> , <code>'R'</code> 和 <code>'X'</code> 三个字符组成的字符串（例如<code>"RXXLRXRXL"</code>）中进行移动操作。一次移动操作指用一个&nbsp;<code>"LX"</code>&nbsp;替换一个&nbsp;<code>"XL"</code>，或者用一个&nbsp;<code>"XR"</code>&nbsp;替换一个&nbsp;<code>"RX"</code>。现给定起始字符串&nbsp;<code>start</code>&nbsp;和结束字符串&nbsp;<code>result</code>，请编写代码，当且仅当存在一系列移动操作使得&nbsp;<code>start</code>&nbsp;可以转换成&nbsp;<code>result</code>&nbsp;时， 返回&nbsp;<code>True</code>。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入：</strong>start = "RXXLRXRXL", result = "XRLXXRRLX"
<strong>输出：</strong>true
<strong>解释：</strong>通过以下步骤我们可以将 start 转化为 result：
RXXLRXRXL -&gt;
XRXLRXRXL -&gt;
XRLXRXRXL -&gt;
XRLXXRRXL -&gt;
XRLXXRRLX
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>start = "X", result = "L"
<strong>输出：</strong>false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= start.length&nbsp;&lt;= 10<sup>4</sup></code></li>
	<li><code>start.length == result.length</code></li>
	<li><code>start</code> 和&nbsp;<code>result</code>&nbsp;都只包含&nbsp;<code>'L'</code>, <code>'R'</code>&nbsp;或&nbsp;<code>'X'</code>。</li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    bool canTransform(string start, string result) {
        
    }
};
```

### Java

```java
class Solution {
    public boolean canTransform(String start, String result) {
        
    }
}
```

### Python3

```python3
class Solution:
    def canTransform(self, start: str, result: str) -> bool:
        
```

### JavaScript

```javascript
/**
 * @param {string} start
 * @param {string} result
 * @return {boolean}
 */
var canTransform = function(start, result) {
    
};
```

### Go

```golang
func canTransform(start string, result string) bool {
    
}
```

---

## 提示

1. Think of the L and R's as people on a horizontal line, where X is a space.  The people can't cross each other, and also you can't go from XRX to RXX.

---

## 示例测试用例

```
"RXXLRXRXL"
"XRLXXRRLX"
```

---

## AI 解答 (DeepSeek)

## 题目分析

题目给出了两种移动规则：
1. `"XL" → "LX"`（L 可以向左移动）
2. `"RX" → "XR"`（R 可以向右移动）

关键限制：
- L 只能向左移动（通过替换 XL）
- R 只能向右移动（通过替换 RX）
- X 只是占位符，本身没有方向性
- 移动操作是相邻字符交换，但只能按上述规则进行

## 核心观察

1. **相对顺序不变性**：移除所有 X 后，start 和 result 中的 L 和 R 的相对顺序必须完全相同
2. **位置约束**：
   - L 在 result 中的位置不能比在 start 中更靠右（因为 L 只能向左移动）
   - R 在 result 中的位置不能比在 start 中更靠左（因为 R 只能向右移动）

---

## 解法一：双指针比较法

### 思路
1. 使用两个指针分别遍历 start 和 result
2. 跳过所有的 X，比较非 X 字符
3. 检查顺序一致性
4. 检查位置约束

### 时间复杂度：O(n)
### 空间复杂度：O(1)

```go
func canTransform(start string, end string) bool {
    if len(start) != len(end) {
        return false
    }
    
    n := len(start)
    i, j := 0, 0
    
    for i < n && j < n {
        // 跳过 start 中的 X
        for i < n && start[i] == 'X' {
            i++
        }
        // 跳过 end 中的 X
        for j < n && end[j] == 'X' {
            j++
        }
        
        // 如果都到达末尾，返回 true
        if i == n && j == n {
            return true
        }
        // 如果一个到达末尾而另一个没有，返回 false
        if i == n || j == n {
            return false
        }
        
        // 字符必须相同
        if start[i] != end[j] {
            return false
        }
        
        // 检查位置约束
        // L 在 end 中的位置不能比在 start 中更靠右
        if start[i] == 'L' && i < j {
            return false
        }
        // R 在 end 中的位置不能比在 start 中更靠左
        if start[i] == 'R' && i > j {
            return false
        }
        
        i++
        j++
    }
    
    // 处理末尾的 X
    for i < n {
        if start[i] != 'X' {
            return false
        }
        i++
    }
    for j < n {
        if end[j] != 'X' {
            return false
        }
        j++
    }
    
    return true
}
```

```cpp
class Solution {
public:
    bool canTransform(string start, string end) {
        if (start.length() != end.length()) return false;
        
        int n = start.length();
        int i = 0, j = 0;
        
        while (i < n && j < n) {
            // 跳过 X
            while (i < n && start[i] == 'X') i++;
            while (j < n && end[j] == 'X') j++;
            
            // 检查是否都到达末尾
            if (i == n && j == n) return true;
            if (i == n || j == n) return false;
            
            // 字符必须相同
            if (start[i] != end[j]) return false;
            
            // 检查位置约束
            if (start[i] == 'L' && i < j) return false;  // L 不能向右移动
            if (start[i] == 'R' && i > j) return false;  // R 不能向左移动
            
            i++;
            j++;
        }
        
        // 检查剩余字符
        while (i < n) {
            if (start[i] != 'X') return false;
            i++;
        }
        while (j < n) {
            if (end[j] != 'X') return false;
            j++;
        }
        
        return true;
    }
};
```

---

## 解法二：记录位置并比较

### 思路
1. 分别记录 start 和 result 中所有非 X 字符及其位置
2. 比较两个序列
3. 检查位置约束

### 时间复杂度：O(n)
### 空间复杂度：O(n)

```go
func canTransform(start string, end string) bool {
    if len(start) != len(end) {
        return false
    }
    
    n := len(start)
    var startChars []byte
    var startPos []int
    var endChars []byte
    var endPos []int
    
    // 记录 start 中的非 X 字符和位置
    for i := 0; i < n; i++ {
        if start[i] != 'X' {
            startChars = append(startChars, start[i])
            startPos = append(startPos, i)
        }
    }
    
    // 记录 end 中的非 X 字符和位置
    for i := 0; i < n; i++ {
        if end[i] != 'X' {
            endChars = append(endChars, end[i])
            endPos = append(endPos, i)
        }
    }
    
    // 非 X 字符数量必须相同
    if len(startChars) != len(endChars) {
        return false
    }
    
    // 比较字符序列和位置约束
    for i := 0; i < len(startChars); i++ {
        if startChars[i] != endChars[i] {
            return false
        }
        
        if startChars[i] == 'L' && startPos[i] < endPos[i] {
            return false  // L 不能向右移动
        }
        if startChars[i] == 'R' && startPos[i] > endPos[i] {
            return false  // R 不能向左移动
        }
    }
    
    return true
}
```

```cpp
class Solution {
public:
    bool canTransform(string start, string end) {
        if (start.length() != end.length()) return false;
        
        int n = start.length();
        vector<pair<char, int>> startSeq, endSeq;
        
        // 记录 start 序列
        for (int i = 0; i < n; i++) {
            if (start[i] != 'X') {
                startSeq.push_back({start[i], i});
            }
        }
        
        // 记录 end 序列
        for (int i = 0; i < n; i++) {
            if (end[i] != 'X') {
                endSeq.push_back({end[i], i});
            }
        }
        
        // 检查长度
        if (startSeq.size() != endSeq.size()) return false;
        
        // 比较
        for (int i = 0; i < startSeq.size(); i++) {
            if (startSeq[i].first != endSeq[i].first) return false;
            
            if (startSeq[i].first == 'L' && startSeq[i].second < endSeq[i].second) {
                return false;  // L 不能向右移动
            }
            if (startSeq[i].first == 'R' && startSeq[i].second > endSeq[i].second) {
                return false;  // R 不能向左移动
            }
        }
        
        return true;
    }
};
```

---

## 解法三：单次遍历验证

### 思路
1. 同时遍历两个字符串
2. 维护 L 和 R 的计数差
3. 通过计数差验证可达性

### 时间复杂度：O(n)
### 空间复杂度：O(1)

```go
func canTransform(start string, end string) bool {
    if len(start) != len(end) {
        return false
    }
    
    n := len(start)
    balance := 0  // R 的数量减去 L 的数量
    
    for i := 0; i < n; i++ {
        if start[i] == 'R' {
            balance++
        }
        if end[i] == 'L' {
            balance--
        }
        
        // 任何时候 balance 不能为负（L 不能超过 R）
        if balance < 0 {
            return false
        }
        
        if start[i] == 'L' {
            balance--
        }
        if end[i] == 'R' {
            balance++
        }
        
        // 任何时候 balance 不能为正（R 不能超过 L）
        if balance > 0 {
            return false
        }
    }
    
    return balance == 0
}
```

```cpp
class Solution {
public:
    bool canTransform(string start, string end) {
        if (start.length() != end.length()) return false;
        
        int n = start.length();
        int balance = 0;  // R 的数量减去 L 的数量
        
        for (int i = 0; i < n; i++) {
            if (start[i] == 'R') balance++;
            if (end[i] == 'L') balance--;
            
            // 任何时候 L 不能超过 R
            if (balance < 0) return false;
            
            if (start[i] == 'L') balance--;
            if (end[i] == 'R') balance++;
            
            // 任何时候 R 不能超过 L
            if (balance > 0) return false;
        }
        
        return balance == 0;
    }
};
```

---

## 复杂度对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 解法一 | O(n) | O(1) | 最直观，空间最优 | 逻辑稍复杂 |
| 解法二 | O(n) | O(n) | 逻辑清晰，易于理解 | 需要额外空间 |
| 解法三 | O(n) | O(1) | 简洁巧妙 | 逻辑不够直观 |

## 推荐解法

**解法一（双指针比较法）** 是最推荐的，因为：
1. 空间复杂度最优（O(1)）
2. 时间复杂度最优（O(n)）
3. 逻辑相对清晰，符合题目直观理解
4. 不需要额外存储空间

解法三虽然也很简洁，但逻辑不够直观，调试和理解起来相对困难。解法二需要额外空间，不是最优选择。

---

*获取时间: 2026-02-26 17:53:56*
