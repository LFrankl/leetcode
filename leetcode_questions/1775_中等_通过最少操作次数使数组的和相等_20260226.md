# 1775. 通过最少操作次数使数组的和相等

**难度**: Medium

**标签**: 贪心, 数组, 哈希表, 计数

**链接**: https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/

---

## 题目描述

<p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p>

<p>每次操作中，你可以选择 <strong>任意</strong> 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 <strong>任意</strong> 的值（包含 <code>1</code> 和 <code><span style="">6</span></code>）。</p>

<p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]
<b>输出：</b>3
<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [<strong>6</strong>,1,2,2,2,2] 。
- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,<strong>1</strong>], nums2 = [6,1,2,2,2,2] 。
- 将 nums1[2] 变为 2 。 nums1 = [1,2,<strong>2</strong>,4,5,1], nums2 = [6,1,2,2,2,2] 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>nums1 = [1,1,1,1,1,1,1], nums2 = [6]
<b>输出：</b>-1
<b>解释：</b>没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。
</pre>

<p><strong>示例 3：</strong></p>

<pre><b>输入：</b>nums1 = [6,6], nums2 = [1]
<b>输出：</b>3
<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums1[0] 变为 2 。 nums1 = [<strong>2</strong>,6], nums2 = [1] 。
- 将 nums1[1] 变为 2 。 nums1 = [2,<strong>2</strong>], nums2 = [1] 。
- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [<strong>4</strong>] 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int minOperations(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

### Java

```java
class Solution {
    public int minOperations(int[] nums1, int[] nums2) {
        
    }
}
```

### Python3

```python3
class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var minOperations = function(nums1, nums2) {
    
};
```

### Go

```golang
func minOperations(nums1 []int, nums2 []int) int {
    
}
```

---

## 提示

1. Let's note that we want to either decrease the sum of the array with a larger sum or increase the array's sum with the smaller sum.
2. You can maintain the largest increase or decrease you can make in a binary search tree and each time get the maximum one.

---

## 示例测试用例

```
[1,2,3,4,5,6]
[1,1,2,2,2,2]
```

---

## AI 解答 (DeepSeek)

## 题目分析

**问题本质**：有两个数组，每个元素值在 1~6 之间。每次操作可以将任意一个元素变成 1~6 之间的任意值。目标是让两个数组的和相等，求最少操作次数。

**关键点**：
1. 每个元素的变化范围是有限的（1~6）
2. 操作可以增加或减少元素值，从而改变数组和
3. 我们需要最小化操作次数

## 解题思路

### 核心思路
设：
- `sum1` = nums1 的和
- `sum2` = nums2 的和
- `diff` = sum1 - sum2

如果 `diff == 0`，已经相等，返回 0。

如果 `diff > 0`，说明 sum1 太大，需要减少 sum1 或增加 sum2。
如果 `diff < 0`，说明 sum2 太大，需要减少 sum2 或增加 sum1。

**贪心策略**：
- 对于需要减少的数组，每个元素最多能减少 `当前值 - 1`
- 对于需要增加的数组，每个元素最多能增加 `6 - 当前值`
- 每次选择能带来最大变化量的元素进行操作

### 具体步骤
1. 计算两个数组的和，得到差值 `diff`
2. 如果 `diff == 0`，返回 0
3. 确定哪个数组需要减少，哪个需要增加
4. 收集所有可能的"变化量"：
   - 对于需要减少的数组：每个元素能减少 `nums[i] - 1`
   - 对于需要增加的数组：每个元素能增加 `6 - nums[i]`
5. 将这些变化量从大到小排序
6. 贪心地使用最大的变化量，直到 `diff` 变为 0 或没有更多变化量可用
7. 如果 `diff` 变为 0，返回操作次数；否则返回 -1

---

## 解法一：贪心 + 排序

### 思路
1. 计算两个数组的和及差值
2. 收集所有可能的变化量
3. 对变化量排序（从大到小）
4. 贪心地使用最大的变化量

### 代码实现

#### Go 实现
```go
func minOperations(nums1 []int, nums2 []int) int {
    sum1, sum2 := 0, 0
    for _, num := range nums1 {
        sum1 += num
    }
    for _, num := range nums2 {
        sum2 += num
    }
    
    // 确保 sum1 >= sum2，方便处理
    if sum1 < sum2 {
        nums1, nums2 = nums2, nums1
        sum1, sum2 = sum2, sum1
    }
    
    diff := sum1 - sum2
    if diff == 0 {
        return 0
    }
    
    // 收集变化量
    changes := make([]int, 0)
    
    // nums1 中的元素可以减少（因为 sum1 更大）
    for _, num := range nums1 {
        changes = append(changes, num-1)  // 最多减少到 1
    }
    
    // nums2 中的元素可以增加
    for _, num := range nums2 {
        changes = append(changes, 6-num)  // 最多增加到 6
    }
    
    // 从大到小排序
    sort.Sort(sort.Reverse(sort.IntSlice(changes)))
    
    // 贪心选择
    operations := 0
    for i := 0; i < len(changes) && diff > 0; i++ {
        diff -= changes[i]
        operations++
    }
    
    if diff > 0 {
        return -1
    }
    return operations
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums1, vector<int>& nums2) {
        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
        
        // 确保 sum1 >= sum2
        if (sum1 < sum2) {
            swap(nums1, nums2);
            swap(sum1, sum2);
        }
        
        int diff = sum1 - sum2;
        if (diff == 0) return 0;
        
        vector<int> changes;
        
        // nums1 中的元素可以减少
        for (int num : nums1) {
            changes.push_back(num - 1);
        }
        
        // nums2 中的元素可以增加
        for (int num : nums2) {
            changes.push_back(6 - num);
        }
        
        // 从大到小排序
        sort(changes.rbegin(), changes.rend());
        
        int operations = 0;
        for (int change : changes) {
            if (diff <= 0) break;
            diff -= change;
            operations++;
        }
        
        return diff > 0 ? -1 : operations;
    }
};
```

### 复杂度分析
- **时间复杂度**：O((m+n)log(m+n))，其中 m 和 n 分别是两个数组的长度，主要是排序的复杂度
- **空间复杂度**：O(m+n)，用于存储变化量数组

---

## 解法二：贪心 + 计数排序（优化）

### 思路
由于元素值范围只有 1~6，变化量的范围也是有限的（0~5），可以使用计数排序来优化。

变化量分类：
- 对于需要减少的数组：变化量 = 当前值 - 1（范围 0~5）
- 对于需要增加的数组：变化量 = 6 - 当前值（范围 0~5）

我们可以统计每个变化量出现的次数，然后从大到小使用。

### 代码实现

#### Go 实现
```go
func minOperations(nums1 []int, nums2 []int) int {
    sum1, sum2 := 0, 0
    for _, num := range nums1 {
        sum1 += num
    }
    for _, num := range nums2 {
        sum2 += num
    }
    
    // 确保 sum1 >= sum2
    if sum1 < sum2 {
        nums1, nums2 = nums2, nums1
        sum1, sum2 = sum2, sum1
    }
    
    diff := sum1 - sum2
    if diff == 0 {
        return 0
    }
    
    // 统计变化量（变化量范围 0~5）
    cnt := make([]int, 6)  // cnt[i] 表示变化量为 i 的元素个数
    
    // nums1 中的元素可以减少（变化量 = num-1）
    for _, num := range nums1 {
        cnt[num-1]++
    }
    
    // nums2 中的元素可以增加（变化量 = 6-num）
    for _, num := range nums2 {
        cnt[6-num]++
    }
    
    operations := 0
    // 从最大的变化量（5）开始使用
    for i := 5; i >= 1 && diff > 0; i-- {
        // 每个变化量为 i 的元素最多可以减少 diff 的 i
        for cnt[i] > 0 && diff > 0 {
            diff -= i
            cnt[i]--
            operations++
        }
    }
    
    if diff > 0 {
        return -1
    }
    return operations
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums1, vector<int>& nums2) {
        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
        
        // 确保 sum1 >= sum2
        if (sum1 < sum2) {
            swap(nums1, nums2);
            swap(sum1, sum2);
        }
        
        int diff = sum1 - sum2;
        if (diff == 0) return 0;
        
        // 统计变化量（0~5）
        vector<int> cnt(6, 0);
        
        // nums1 中的元素可以减少
        for (int num : nums1) {
            cnt[num - 1]++;
        }
        
        // nums2 中的元素可以增加
        for (int num : nums2) {
            cnt[6 - num]++;
        }
        
        int operations = 0;
        // 从最大的变化量开始使用
        for (int i = 5; i >= 1 && diff > 0; i--) {
            while (cnt[i] > 0 && diff > 0) {
                diff -= i;
                cnt[i]--;
                operations++;
            }
        }
        
        return diff > 0 ? -1 : operations;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(m+n+6) = O(m+n)，其中 m 和 n 分别是两个数组的长度
- **空间复杂度**：O(6) = O(1)，只需要常数空间存储计数数组

---

## 解法三：双指针（进一步优化）

### 思路
实际上，我们不需要显式地统计所有变化量。我们可以：
1. 对两个数组分别排序
2. 使用双指针：
   - 指针 i 从 nums1 末尾开始（nums1 需要减少）
   - 指针 j 从 nums2 开头开始（nums2 需要增加）
3. 每次选择变化量更大的那个进行操作

### 代码实现

#### Go 实现
```go
func minOperations(nums1 []int, nums2 []int) int {
    sum1, sum2 := 0, 0
    for _, num := range nums1 {
        sum1 += num
    }
    for _, num := range nums2 {
        sum2 += num
    }
    
    // 确保 sum1 >= sum2
    if sum1 < sum2 {
        nums1, nums2 = nums2, nums1
        sum1, sum2 = sum2, sum1
    }
    
    diff := sum1 - sum2
    if diff == 0 {
        return 0
    }
    
    // 排序
    sort.Ints(nums1)  // 升序
    sort.Ints(nums2)  // 升序
    
    operations := 0
    i, j := len(nums1)-1, 0
    
    for diff > 0 && (i >= 0 || j < len(nums2)) {
        // 计算 nums1[i] 能减少的最大值
        reduce := 0
        if i >= 0 {
            reduce = nums1[i] - 1
        }
        
        // 计算 nums2[j] 能增加的最大值
        increase := 0
        if j < len(nums2) {
            increase = 6 - nums2[j]
        }
        
        // 选择变化量更大的操作
        if reduce >= increase {
            diff -= reduce
            i--
        } else {
            diff -= increase
            j++
        }
        operations++
        
        // 如果 diff <= 0，提前结束
        if diff <= 0 {
            return operations
        }
    }
    
    return -1
}
```

#### C++ 实现
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums1, vector<int>& nums2) {
        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
        
        // 确保 sum1 >= sum2
        if (sum1 < sum2) {
            swap(nums1, nums2);
            swap(sum1, sum2);
        }
        
        int diff = sum1 - sum2;
        if (diff == 0) return 0;
        
        // 排序
        sort(nums1.begin(), nums1.end());  // 升序
        sort(nums2.begin(), nums2.end());  // 升序
        
        int operations = 0;
        int i = nums1.size() - 1, j = 0;
        
        while (diff > 0 && (i >= 0 || j < nums2.size())) {
            int reduce = (i >= 0) ? nums1[i] - 1 : 0;
            int increase = (j < nums2.size()) ? 6 - nums2[j] : 0;
            
            if (reduce >= increase) {
                diff -= reduce;
                i--;
            } else {
                diff -= increase;
                j++;
            }
            operations++;
            
            if (diff <= 0) {
                return operations;
            }
        }
        
        return -1;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(mlogm + nlogn)，主要是排序的复杂度
- **空间复杂度**：O(1)（不考虑排序的递归栈空间）

---

## 解法对比

| 特性 | 解法一（排序） | 解法二（计数排序） | 解法三（双指针） |
|------|---------------|-------------------|-----------------|
| 时间复杂度 | O((m+n)log(m+n)) | O(m+n) | O(mlogm + nlogn) |
| 空间复杂度 | O(m+n) | O(1) | O(1)（不考虑递归栈） |
| 实现难度 | 简单 | 中等 | 中等 |
| 适用场景 | 通用 | 元素范围有限时最优 | 需要减少额外空间时 |
| 实际性能 | 较慢 | 最快 | 中等 |

### 推荐解法
**解法二（计数排序）是最优解**，因为：
1. 时间复杂度 O(m+n)，是最优的
2. 空间复杂度 O(1)，只需要常数空间
3. 利用了题目中元素值范围有限（1~6）的特性
4. 实现相对简单，性能最好

### 关键点总结
1. **贪心策略**：每次选择能带来最大变化量的操作
2. **变化量计算**：
   - 对于需要减少的元素：变化量 = 当前值 - 1
   - 对于需要增加的元素：变化量 = 6 - 当前值
3. **优化技巧**：利用元素值范围有限的特点，使用计数排序代替通用排序
4. **边界处理**：注意 diff 为 0 的情况和无法达成的情况

在实际面试中，建议先提出解法一（通用贪心），然后优化到解法二（计数排序），展示对问题特性的理解和优化能力。

---

*获取时间: 2026-02-26 19:54:37*
