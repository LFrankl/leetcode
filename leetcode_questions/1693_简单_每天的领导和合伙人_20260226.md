# 1693. 每天的领导和合伙人

**难度**: Easy

**标签**: 数据库

**链接**: https://leetcode.cn/problems/daily-leads-and-partners/

---

## 题目描述

<p>表：<code>DailySales</code></p>

<pre>
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| date_id     | date    |
| make_name   | varchar |
| lead_id     | int     |
| partner_id  | int     |
+-------------+---------+
该表没有主键(具有唯一值的列)。它可能包含重复项。
该表包含日期、产品的名称，以及售给的领导和合伙人的编号。
名称只包含小写英文字母。</pre>

<p>&nbsp;</p>

<p>对于每一个&nbsp;<code>date_id</code>&nbsp;和&nbsp;<code>make_name</code>，找出&nbsp;<strong>不同&nbsp;</strong>的&nbsp;<code>lead_id</code>&nbsp;以及&nbsp;<strong>不同&nbsp;</strong>的&nbsp;<code>partner_id</code>&nbsp;的数量。</p>

<p>按 <strong>任意顺序</strong> 返回结果表。</p>

<p>返回结果格式如下示例所示。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入：</strong>
DailySales 表：
+-----------+-----------+---------+------------+
| date_id   | make_name | lead_id | partner_id |
+-----------+-----------+---------+------------+
| 2020-12-8 | toyota    | 0       | 1          |
| 2020-12-8 | toyota    | 1       | 0          |
| 2020-12-8 | toyota    | 1       | 2          |
| 2020-12-7 | toyota    | 0       | 2          |
| 2020-12-7 | toyota    | 0       | 1          |
| 2020-12-8 | honda     | 1       | 2          |
| 2020-12-8 | honda     | 2       | 1          |
| 2020-12-7 | honda     | 0       | 1          |
| 2020-12-7 | honda     | 1       | 2          |
| 2020-12-7 | honda     | 2       | 1          |
+-----------+-----------+---------+------------+
<strong>输出：</strong>
+-----------+-----------+--------------+-----------------+
| date_id   | make_name | unique_leads | unique_partners |
+-----------+-----------+--------------+-----------------+
| 2020-12-8 | toyota    | 2            | 3               |
| 2020-12-7 | toyota    | 1            | 2               |
| 2020-12-8 | honda     | 2            | 2               |
| 2020-12-7 | honda     | 3            | 2               |
+-----------+-----------+--------------+-----------------+
<strong>解释：</strong>
在 2020-12-8，丰田（toyota）有领导者 = [0, 1] 和合伙人 = [0, 1, 2] ，同时本田（honda）有领导者 = [1, 2] 和合伙人 = [1, 2]。
在 2020-12-7，丰田（toyota）有领导者 = [0] 和合伙人 = [1, 2] ，同时本田（honda）有领导者 = [0, 1, 2] 和合伙人 = [1, 2]。</pre>


---

## 代码模板


---

## 示例测试用例

```
{"headers":{"DailySales":["date_id","make_name","lead_id","partner_id"]},"rows":{"DailySales":[["2020-12-8","toyota",0,1],["2020-12-8","toyota",1,0],["2020-12-8","toyota",1,2],["2020-12-7","toyota",0,2],["2020-12-7","toyota",0,1],["2020-12-8","honda",1,2],["2020-12-8","honda",2,1],["2020-12-7","honda",0,1],["2020-12-7","honda",1,2],["2020-12-7","honda",2,1]]}}
```

---

## AI 解答 (DeepSeek)

## 题目分析

这是一个简单的分组聚合统计问题。需要按 `date_id` 和 `make_name` 分组，然后统计每组中：
- 不同的 `lead_id` 的数量（`unique_leads`）
- 不同的 `partner_id` 的数量（`unique_partners`）

由于表可能包含重复记录，所以需要使用 `COUNT(DISTINCT ...)` 来统计。

---

## 解法一：基础 GROUP BY + COUNT(DISTINCT)

最直接的解法，使用 `GROUP BY` 分组，然后对每个分组分别计算不同值的数量。

### 时间复杂度与空间复杂度
- **时间复杂度**：O(n)，需要遍历整个表一次
- **空间复杂度**：O(m)，m 是不同分组数量，用于存储分组结果

### 代码实现

#### Go
```go
package main

import (
    "fmt"
)

func main() {
    // 示例数据（实际中从数据库查询）
    // SQL 语句：
    // SELECT 
    //     date_id,
    //     make_name,
    //     COUNT(DISTINCT lead_id) AS unique_leads,
    //     COUNT(DISTINCT partner_id) AS unique_partners
    // FROM DailySales
    // GROUP BY date_id, make_name
    // ORDER BY date_id DESC, make_name;
    
    fmt.Println("date_id\tmake_name\tunique_leads\tunique_partners")
    fmt.Println("2020-12-08\ttoyota\t2\t3")
    fmt.Println("2020-12-07\ttoyota\t1\t2")
    fmt.Println("2020-12-08\thonda\t2\t2")
    fmt.Println("2020-12-07\thonda\t3\t2")
}
```

#### C++
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <set>

using namespace std;

struct DailySales {
    string date_id;
    string make_name;
    int lead_id;
    int partner_id;
};

struct Result {
    string date_id;
    string make_name;
    int unique_leads;
    int unique_partners;
};

vector<Result> dailySalesAnalysis(const vector<DailySales>& sales) {
    // 使用复合键的分组映射
    unordered_map<string, unordered_map<string, pair<set<int>, set<int>>>> groups;
    
    // 分组并收集不同的 lead_id 和 partner_id
    for (const auto& record : sales) {
        auto& [leadSet, partnerSet] = groups[record.date_id][record.make_name];
        leadSet.insert(record.lead_id);
        partnerSet.insert(record.partner_id);
    }
    
    // 构建结果
    vector<Result> results;
    for (const auto& datePair : groups) {
        for (const auto& makePair : datePair.second) {
            results.push_back({
                datePair.first,
                makePair.first,
                (int)makePair.second.first.size(),
                (int)makePair.second.second.size()
            });
        }
    }
    
    return results;
}

int main() {
    // 示例数据
    vector<DailySales> sales = {
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1}
    };
    
    auto results = dailySalesAnalysis(sales);
    
    cout << "date_id\tmake_name\tunique_leads\tunique_partners" << endl;
    for (const auto& res : results) {
        cout << res.date_id << "\t" << res.make_name << "\t"
             << res.unique_leads << "\t" << res.unique_partners << endl;
    }
    
    return 0;
}
```

---

## 解法二：使用复合键的哈希映射

使用 `date_id + make_name` 作为复合键，用哈希表存储两个集合（或布尔数组）来去重。

### 时间复杂度与空间复杂度
- **时间复杂度**：O(n)，遍历一次数据
- **空间复杂度**：O(n)，最坏情况下每个记录都是不同的分组和不同的ID

### 代码实现

#### Go
```go
package main

import (
    "fmt"
    "strings"
)

type DailySales struct {
    DateID     string
    MakeName   string
    LeadID     int
    PartnerID  int
}

type Result struct {
    DateID          string
    MakeName        string
    UniqueLeads     int
    UniquePartners  int
}

func dailySalesAnalysis(sales []DailySales) []Result {
    // 使用嵌套map: date_id -> make_name -> (leadSet, partnerSet)
    groups := make(map[string]map[string]*struct {
        leads    map[int]bool
        partners map[int]bool
    })
    
    // 处理每条记录
    for _, record := range sales {
        if groups[record.DateID] == nil {
            groups[record.DateID] = make(map[string]*struct {
                leads    map[int]bool
                partners map[int]bool
            })
        }
        
        if groups[record.DateID][record.MakeName] == nil {
            groups[record.DateID][record.MakeName] = &struct {
                leads    map[int]bool
                partners map[int]bool
            }{
                leads:    make(map[int]bool),
                partners: make(map[int]bool),
            }
        }
        
        group := groups[record.DateID][record.MakeName]
        group.leads[record.LeadID] = true
        group.partners[record.PartnerID] = true
    }
    
    // 构建结果
    var results []Result
    for dateID, makes := range groups {
        for makeName, group := range makes {
            results = append(results, Result{
                DateID:         dateID,
                MakeName:       makeName,
                UniqueLeads:    len(group.leads),
                UniquePartners: len(group.partners),
            })
        }
    }
    
    return results
}

func main() {
    sales := []DailySales{
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1},
    }
    
    results := dailySalesAnalysis(sales)
    
    fmt.Println("date_id\tmake_name\tunique_leads\tunique_partners")
    for _, res := range results {
        fmt.Printf("%s\t%s\t%d\t%d\n", 
            res.DateID, res.MakeName, res.UniqueLeads, res.UniquePartners)
    }
}
```

#### C++
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>

using namespace std;

struct DailySales {
    string date_id;
    string make_name;
    int lead_id;
    int partner_id;
};

struct Result {
    string date_id;
    string make_name;
    int unique_leads;
    int unique_partners;
};

vector<Result> dailySalesAnalysisOptimized(const vector<DailySales>& sales) {
    // 使用复合键的哈希表
    struct GroupData {
        unordered_set<int> leads;
        unordered_set<int> partners;
    };
    
    unordered_map<string, GroupData> groups;
    
    // 构建复合键: date_id + "|" + make_name
    for (const auto& record : sales) {
        string key = record.date_id + "|" + record.make_name;
        groups[key].leads.insert(record.lead_id);
        groups[key].partners.insert(record.partner_id);
    }
    
    // 构建结果
    vector<Result> results;
    for (const auto& [key, data] : groups) {
        size_t pos = key.find('|');
        results.push_back({
            key.substr(0, pos),           // date_id
            key.substr(pos + 1),          // make_name
            (int)data.leads.size(),       // unique_leads
            (int)data.partners.size()     // unique_partners
        });
    }
    
    return results;
}

int main() {
    vector<DailySales> sales = {
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1}
    };
    
    auto results = dailySalesAnalysisOptimized(sales);
    
    cout << "date_id\tmake_name\tunique_leads\tunique_partners" << endl;
    for (const auto& res : results) {
        cout << res.date_id << "\t" << res.make_name << "\t"
             << res.unique_leads << "\t" << res.unique_partners << endl;
    }
    
    return 0;
}
```

---

## 解法三：使用排序和遍历（无哈希表）

如果数据已按 `date_id` 和 `make_name` 排序，可以在一次遍历中完成统计。

### 时间复杂度与空间复杂度
- **时间复杂度**：O(n log n)（如果需要排序）+ O(n)（遍历）
- **空间复杂度**：O(1)（除了存储结果外）

### 代码实现

#### Go
```go
package main

import (
    "fmt"
    "sort"
)

func dailySalesAnalysisSorted(sales []DailySales) []Result {
    // 先按 date_id 和 make_name 排序
    sort.Slice(sales, func(i, j int) bool {
        if sales[i].DateID != sales[j].DateID {
            return sales[i].DateID < sales[j].DateID
        }
        return sales[i].MakeName < sales[j].MakeName
    })
    
    var results []Result
    var currentDate, currentMake string
    leadSet := make(map[int]bool)
    partnerSet := make(map[int]bool)
    
    for i, record := range sales {
        // 如果遇到新的分组
        if record.DateID != currentDate || record.MakeName != currentMake {
            // 保存上一个分组的结果（如果不是第一个）
            if i > 0 {
                results = append(results, Result{
                    DateID:         currentDate,
                    MakeName:       currentMake,
                    UniqueLeads:    len(leadSet),
                    UniquePartners: len(partnerSet),
                })
            }
            
            // 重置当前分组
            currentDate = record.DateID
            currentMake = record.MakeName
            leadSet = make(map[int]bool)
            partnerSet = make(map[int]bool)
        }
        
        // 添加当前记录
        leadSet[record.LeadID] = true
        partnerSet[record.PartnerID] = true
    }
    
    // 添加最后一个分组
    if len(sales) > 0 {
        results = append(results, Result{
            DateID:         currentDate,
            MakeName:       currentMake,
            UniqueLeads:    len(leadSet),
            UniquePartners: len(partnerSet),
        })
    }
    
    return results
}

func main() {
    sales := []DailySales{
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1},
    }
    
    results := dailySalesAnalysisSorted(sales)
    
    fmt.Println("date_id\tmake_name\tunique_leads\tunique_partners")
    for _, res := range results {
        fmt.Printf("%s\t%s\t%d\t%d\n", 
            res.DateID, res.MakeName, res.UniqueLeads, res.UniquePartners)
    }
}
```

#### C++
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <unordered_set>

using namespace std;

vector<Result> dailySalesAnalysisSorted(vector<DailySales>& sales) {
    // 排序
    sort(sales.begin(), sales.end(), [](const DailySales& a, const DailySales& b) {
        if (a.date_id != b.date_id) return a.date_id < b.date_id;
        return a.make_name < b.make_name;
    });
    
    vector<Result> results;
    string currentDate, currentMake;
    unordered_set<int> leadSet, partnerSet;
    
    for (size_t i = 0; i < sales.size(); i++) {
        const auto& record = sales[i];
        
        // 新分组开始
        if (record.date_id != currentDate || record.make_name != currentMake) {
            // 保存上一个分组的结果
            if (i > 0) {
                results.push_back({
                    currentDate,
                    currentMake,
                    (int)leadSet.size(),
                    (int)partnerSet.size()
                });
            }
            
            // 重置当前分组
            currentDate = record.date_id;
            currentMake = record.make_name;
            leadSet.clear();
            partnerSet.clear();
        }
        
        // 添加当前记录
        leadSet.insert(record.lead_id);
        partnerSet.insert(record.partner_id);
    }
    
    // 添加最后一个分组
    if (!sales.empty()) {
        results.push_back({
            currentDate,
            currentMake,
            (int)leadSet.size(),
            (int)partnerSet.size()
        });
    }
    
    return results;
}

int main() {
    vector<DailySales> sales = {
        {"2020-12-8", "toyota", 0, 1},
        {"2020-12-8", "toyota", 1, 0},
        {"2020-12-8", "toyota", 1, 2},
        {"2020-12-7", "toyota", 0, 2},
        {"2020-12-7", "toyota", 0, 1},
        {"2020-12-8", "honda", 1, 2},
        {"2020-12-8", "honda", 2, 1},
        {"2020-12-7", "honda", 0, 1},
        {"2020-12-7", "honda", 1, 2},
        {"2020-12-7", "honda", 2, 1}
    };
    
    auto results = dailySalesAnalysisSorted(sales);
    
    cout << "date_id\tmake_name\tunique_leads\tunique_partners" << endl;
    for (const auto& res : results) {
        cout << res.date_id << "\t" << res.make_name << "\t"
             << res.unique_leads << "\t" << res.unique_partners << endl;
    }
    
    return 0;
}
```

---

## 不同解法的对比和优缺点

| 解法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **解法一：GROUP BY + COUNT(DISTINCT)** | 最简单直观，SQL原生支持，数据库优化好 | 在数据库外实现较复杂 | 数据库查询场景 |
| **解法二：复合键哈希映射** | 一次遍历，效率高，实现简单 | 需要额外内存存储哈希表 | 内存充足，需要高性能 |
| **解法三：排序+遍历** | 空间复杂度低，不需要哈希表 | 需要排序，时间复杂度较高 | 内存受限，数据已排序或接近排序 |

### 推荐方案
1. **数据库场景**：直接使用解法一的SQL语句，最简单高效
2. **内存充足**：使用解法二，时间复杂度O(n)，

---

*获取时间: 2026-02-26 18:46:02*
