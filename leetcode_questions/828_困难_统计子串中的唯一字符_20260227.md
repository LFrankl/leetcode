# 828. 统计子串中的唯一字符

**难度**: Hard

**标签**: 哈希表, 字符串, 动态规划

**链接**: https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/

---

## 题目描述

<p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p>

<p>例如：<code>s = "LEETCODE"</code> ，则其中 <code>"L"</code>, <code>"T"</code>,<code>"C"</code>,<code>"O"</code>,<code>"D"</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p>

<p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。输入用例保证返回值为&nbsp;32 位整数。</p>

<p>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入: </strong>s = "ABC"
<strong>输出: </strong>10
<strong>解释:</strong> 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入: </strong>s = "ABA"
<strong>输出: </strong>8
<strong>解释: </strong>除了 countUniqueChars("ABA") = 1 之外，其余与示例 1 相同。
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "LEETCODE"
<strong>输出：</strong>92
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> 只包含大写英文字符</li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int uniqueLetterString(string s) {
        
    }
};
```

### Java

```java
class Solution {
    public int uniqueLetterString(String s) {
        
    }
}
```

### Python3

```python3
class Solution:
    def uniqueLetterString(self, s: str) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var uniqueLetterString = function(s) {
    
};
```

### Go

```golang
func uniqueLetterString(s string) int {
    
}
```

---

## 示例测试用例

```
"ABC"
```

---

## AI 解答 (DeepSeek)

## 题目分析

题目要求计算字符串 `s` 的所有子串中唯一字符的总个数。唯一字符指的是在子串中只出现一次的字符。

**关键点**：
- 子串数量为 O(n²)，直接枚举会超时（n ≤ 10⁵）
- 需要转换思路：从统计每个子串的唯一字符，转换为**计算每个字符在多少个子串中是唯一的**

## 解题思路

### 核心转换
对于字符 `ch`，考虑它在哪些子串中是唯一的：
- 假设字符 `ch` 出现在位置 `i`，且它左边最近相同字符位置为 `prev`，右边最近相同字符位置为 `next`
- 那么包含位置 `i` 且 `ch` 在该子串中唯一的子串数量为：
  ```
  (i - prev) × (next - i)
  ```
  其中：
  - `i - prev`：以位置 `i` 的 `ch` 为基准，向左可以扩展的长度（保证左边不包含相同字符）
  - `next - i`：向右可以扩展的长度（保证右边不包含相同字符）

### 算法步骤
1. 预处理每个字符出现的位置列表
2. 对于每个位置 `i` 的字符 `ch`：
   - 找到它在 `ch` 的位置列表中的索引
   - 确定左边最近相同字符位置（如果不存在则为 -1）
   - 确定右边最近相同字符位置（如果不存在则为 n）
3. 计算该字符在该位置对答案的贡献
4. 累加所有位置的所有字符的贡献

## 解法一：位置列表法

### 思路
为每个字符记录所有出现位置，遍历每个位置计算贡献。

```go
func uniqueLetterString(s string) int {
    n := len(s)
    // 记录每个字符的所有出现位置
    pos := make([][]int, 26)
    for i := 0; i < 26; i++ {
        pos[i] = append(pos[i], -1) // 左边界
    }
    for i, ch := range s {
        idx := int(ch - 'A')
        pos[idx] = append(pos[idx], i)
    }
    for i := 0; i < 26; i++ {
        pos[i] = append(pos[i], n) // 右边界
    }
    
    ans := 0
    // 遍历每个字符的每个出现位置（不包括边界）
    for i := 0; i < 26; i++ {
        positions := pos[i]
        // 遍历实际出现的位置
        for j := 1; j < len(positions)-1; j++ {
            left := positions[j] - positions[j-1]
            right := positions[j+1] - positions[j]
            ans += left * right
        }
    }
    return ans
}
```

```cpp
class Solution {
public:
    int uniqueLetterString(string s) {
        int n = s.size();
        // 记录每个字符的所有出现位置
        vector<vector<int>> pos(26);
        for (int i = 0; i < 26; i++) {
            pos[i].push_back(-1); // 左边界
        }
        for (int i = 0; i < n; i++) {
            int idx = s[i] - 'A';
            pos[idx].push_back(i);
        }
        for (int i = 0; i < 26; i++) {
            pos[i].push_back(n); // 右边界
        }
        
        int ans = 0;
        // 遍历每个字符的每个出现位置
        for (int i = 0; i < 26; i++) {
            const vector<int>& positions = pos[i];
            // 遍历实际出现的位置（不包括边界）
            for (int j = 1; j < positions.size() - 1; j++) {
                int left = positions[j] - positions[j-1];
                int right = positions[j+1] - positions[j];
                ans += left * right;
            }
        }
        return ans;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，每个位置被处理常数次
- 空间复杂度：O(n)，存储所有位置

## 解法二：动态维护最近位置

### 思路
遍历字符串时，动态维护每个字符最近两次出现的位置，直接计算贡献。

```go
func uniqueLetterString(s string) int {
    n := len(s)
    // lastPos 记录字符最近一次出现的位置
    // secondLastPos 记录字符倒数第二次出现的位置
    lastPos := make([]int, 26)
    secondLastPos := make([]int, 26)
    for i := 0; i < 26; i++ {
        lastPos[i] = -1
        secondLastPos[i] = -1
    }
    
    ans := 0
    for i := 0; i < n; i++ {
        idx := int(s[i] - 'A')
        // 当前字符在位置 i 对答案的贡献
        // 左边可选长度：i - lastPos[idx]
        // 右边可选长度：lastPos[idx] - secondLastPos[idx]
        if lastPos[idx] != -1 {
            ans += (lastPos[idx] - secondLastPos[idx]) * (i - lastPos[idx])
        }
        // 更新位置
        secondLastPos[idx] = lastPos[idx]
        lastPos[idx] = i
    }
    
    // 处理最后一批贡献
    for i := 0; i < 26; i++ {
        if lastPos[i] != -1 {
            ans += (lastPos[i] - secondLastPos[i]) * (n - lastPos[i])
        }
    }
    
    return ans
}
```

```cpp
class Solution {
public:
    int uniqueLetterString(string s) {
        int n = s.size();
        vector<int> lastPos(26, -1);
        vector<int> secondLastPos(26, -1);
        
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int idx = s[i] - 'A';
            if (lastPos[idx] != -1) {
                ans += (lastPos[idx] - secondLastPos[idx]) * (i - lastPos[idx]);
            }
            secondLastPos[idx] = lastPos[idx];
            lastPos[idx] = i;
        }
        
        // 处理最后一批贡献
        for (int i = 0; i < 26; i++) {
            if (lastPos[i] != -1) {
                ans += (lastPos[i] - secondLastPos[i]) * (n - lastPos[i]);
            }
        }
        
        return ans;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，单次遍历
- 空间复杂度：O(1)，只使用固定大小的数组

## 解法三：贡献法（更直观的版本）

### 思路
对于每个位置，计算该位置的字符在多少个子串中是唯一的。

```go
func uniqueLetterString(s string) int {
    n := len(s)
    // 记录每个字符出现的位置
    pos := make([][]int, 26)
    for i := 0; i < n; i++ {
        idx := int(s[i] - 'A')
        pos[idx] = append(pos[idx], i)
    }
    
    ans := 0
    // 对每个字符计算贡献
    for i := 0; i < 26; i++ {
        positions := pos[i]
        m := len(positions)
        for j := 0; j < m; j++ {
            // 左边界的最近相同字符位置
            left := -1
            if j > 0 {
                left = positions[j-1]
            }
            // 右边界的最近相同字符位置
            right := n
            if j < m-1 {
                right = positions[j+1]
            }
            // 当前位置的贡献
            ans += (positions[j] - left) * (right - positions[j])
        }
    }
    return ans
}
```

```cpp
class Solution {
public:
    int uniqueLetterString(string s) {
        int n = s.size();
        vector<vector<int>> pos(26);
        for (int i = 0; i < n; i++) {
            pos[s[i] - 'A'].push_back(i);
        }
        
        int ans = 0;
        for (int i = 0; i < 26; i++) {
            const vector<int>& positions = pos[i];
            int m = positions.size();
            for (int j = 0; j < m; j++) {
                int left = (j > 0) ? positions[j-1] : -1;
                int right = (j < m-1) ? positions[j+1] : n;
                ans += (positions[j] - left) * (right - positions[j]);
            }
        }
        return ans;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，每个位置被处理一次
- 空间复杂度：O(n)，存储位置信息

## 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 位置列表法 | O(n) | O(n) | 思路清晰，易于理解 | 需要额外存储所有位置 |
| 动态维护法 | O(n) | O(1) | 空间最优，一次遍历 | 逻辑稍复杂，需要处理边界 |
| 贡献法 | O(n) | O(n) | 最直观，符合问题转换思路 | 需要存储位置信息 |

## 总结

1. **最优解法**：动态维护法，时间复杂度 O(n)，空间复杂度 O(1)
2. **最易理解**：贡献法，直接体现了"每个字符在多少个子串中是唯一的"这一核心思想
3. **关键技巧**：将问题从"统计每个子串的唯一字符"转换为"统计每个字符在多少个子串中是唯一的"，这是解决本题的核心

**推荐使用解法二（动态维护法）**，因为它既高效又节省空间，适合处理大规模数据。

---

*获取时间: 2026-02-27 16:21:07*
