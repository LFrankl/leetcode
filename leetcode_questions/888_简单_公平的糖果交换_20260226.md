# 888. 公平的糖果交换

**难度**: Easy

**标签**: 数组, 哈希表, 二分查找, 排序

**链接**: https://leetcode.cn/problems/fair-candy-swap/

---

## 题目描述

<p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p>

<p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p>

<p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>aliceSizes = [1,1], bobSizes = [2,2]
<strong>输出：</strong>[1,2]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>aliceSizes = [1,2], bobSizes = [2,3]
<strong>输出：</strong>[1,2]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>aliceSizes = [2], bobSizes = [1,3]
<strong>输出：</strong>[2,3]
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>aliceSizes = [1,2,5], bobSizes = [2,4]
<strong>输出：</strong>[5,4]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= aliceSizes.length, bobSizes.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 10<sup>5</sup></code></li>
	<li>爱丽丝和鲍勃的糖果总数量不同。</li>
	<li>题目数据保证对于给定的输入至少存在一个有效答案。</li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {
        
    }
};
```

### Java

```java
class Solution {
    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {
        
    }
}
```

### Python3

```python3
class Solution:
    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} aliceSizes
 * @param {number[]} bobSizes
 * @return {number[]}
 */
var fairCandySwap = function(aliceSizes, bobSizes) {
    
};
```

### Go

```golang
func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
    
}
```

---

## 示例测试用例

```
[1,1]
[2,2]
```

---

## AI 解答 (DeepSeek)

## 题目分析

**问题描述**：
- 爱丽丝和鲍勃各有若干盒糖果，每盒糖果数量不同。
- 他们想交换**恰好一盒**糖果，使得交换后两人糖果总数相等。
- 题目保证至少存在一个有效答案。
- 返回一个长度为 2 的数组 `[a, b]`，其中 `a` 是爱丽丝给出的糖果数，`b` 是鲍勃给出的糖果数。

**关键点**：
- 设爱丽丝初始总数为 `sumA`，鲍勃初始总数为 `sumB`。
- 交换后：`sumA - a + b = sumB - b + a`
- 化简得：`sumA - sumB = 2a - 2b`
- 即：`a - b = (sumA - sumB) / 2`
- 令 `diff = (sumA - sumB) / 2`，则我们需要找到 `a` 和 `b` 使得 `a = b + diff`。

---

## 解法一：哈希表法

**思路**：
1. 计算 `sumA` 和 `sumB`，得到 `diff = (sumA - sumB) / 2`。
2. 将鲍勃的糖果盒数量存入哈希表（集合）。
3. 遍历爱丽丝的糖果盒数量 `a`，检查 `b = a - diff` 是否在鲍勃的集合中。
4. 找到后返回 `[a, b]`。

**时间复杂度**：O(n + m)  
**空间复杂度**：O(m)（存储鲍勃的糖果盒集合）

### Go 实现
```go
func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
    sumA, sumB := 0, 0
    for _, v := range aliceSizes {
        sumA += v
    }
    for _, v := range bobSizes {
        sumB += v
    }
    diff := (sumA - sumB) / 2
    
    setB := make(map[int]bool)
    for _, v := range bobSizes {
        setB[v] = true
    }
    
    for _, a := range aliceSizes {
        b := a - diff
        if setB[b] {
            return []int{a, b}
        }
    }
    return nil
}
```

### C++ 实现
```cpp
#include <vector>
#include <unordered_set>
using namespace std;

class Solution {
public:
    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {
        int sumA = 0, sumB = 0;
        for (int v : aliceSizes) sumA += v;
        for (int v : bobSizes) sumB += v;
        int diff = (sumA - sumB) / 2;
        
        unordered_set<int> setB(bobSizes.begin(), bobSizes.end());
        for (int a : aliceSizes) {
            int b = a - diff;
            if (setB.count(b)) {
                return {a, b};
            }
        }
        return {};
    }
};
```

---

## 解法二：排序 + 双指针

**思路**：
1. 计算 `diff = (sumA - sumB) / 2`。
2. 对 `aliceSizes` 和 `bobSizes` 排序。
3. 双指针遍历两个数组，寻找满足 `a - b = diff` 的一对。

**时间复杂度**：O(n log n + m log m)  
**空间复杂度**：O(1)（不考虑排序的栈空间）

### Go 实现
```go
func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
    sumA, sumB := 0, 0
    for _, v := range aliceSizes {
        sumA += v
    }
    for _, v := range bobSizes {
        sumB += v
    }
    diff := (sumA - sumB) / 2
    
    sort.Ints(aliceSizes)
    sort.Ints(bobSizes)
    
    i, j := 0, 0
    for i < len(aliceSizes) && j < len(bobSizes) {
        d := aliceSizes[i] - bobSizes[j]
        if d == diff {
            return []int{aliceSizes[i], bobSizes[j]}
        } else if d < diff {
            i++
        } else {
            j++
        }
    }
    return nil
}
```

### C++ 实现
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {
        int sumA = 0, sumB = 0;
        for (int v : aliceSizes) sumA += v;
        for (int v : bobSizes) sumB += v;
        int diff = (sumA - sumB) / 2;
        
        sort(aliceSizes.begin(), aliceSizes.end());
        sort(bobSizes.begin(), bobSizes.end());
        
        int i = 0, j = 0;
        while (i < aliceSizes.size() && j < bobSizes.size()) {
            int d = aliceSizes[i] - bobSizes[j];
            if (d == diff) {
                return {aliceSizes[i], bobSizes[j]};
            } else if (d < diff) {
                i++;
            } else {
                j++;
            }
        }
        return {};
    }
};
```

---

## 解法三：二分查找

**思路**：
1. 计算 `diff = (sumA - sumB) / 2`。
2. 对鲍勃的数组排序。
3. 遍历爱丽丝的数组，对每个 `a`，在鲍勃数组中二分查找 `b = a - diff`。

**时间复杂度**：O(m log m + n log m)  
**空间复杂度**：O(1)（不考虑排序的栈空间）

### Go 实现
```go
func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
    sumA, sumB := 0, 0
    for _, v := range aliceSizes {
        sumA += v
    }
    for _, v := range bobSizes {
        sumB += v
    }
    diff := (sumA - sumB) / 2
    
    sort.Ints(bobSizes)
    
    for _, a := range aliceSizes {
        b := a - diff
        idx := sort.SearchInts(bobSizes, b)
        if idx < len(bobSizes) && bobSizes[idx] == b {
            return []int{a, b}
        }
    }
    return nil
}
```

### C++ 实现
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {
        int sumA = 0, sumB = 0;
        for (int v : aliceSizes) sumA += v;
        for (int v : bobSizes) sumB += v;
        int diff = (sumA - sumB) / 2;
        
        sort(bobSizes.begin(), bobSizes.end());
        
        for (int a : aliceSizes) {
            int b = a - diff;
            if (binary_search(bobSizes.begin(), bobSizes.end(), b)) {
                return {a, b};
            }
        }
        return {};
    }
};
```

---

## 复杂度对比

| 解法         | 时间复杂度          | 空间复杂度 | 优点                         | 缺点                     |
|--------------|---------------------|------------|------------------------------|--------------------------|
| 哈希表法     | O(n + m)            | O(m)       | 最快，代码简单               | 需要额外空间存储哈希表   |
| 排序+双指针  | O(n log n + m log m)| O(1)       | 空间最优                     | 排序增加时间复杂度       |
| 二分查找     | O(m log m + n log m)| O(1)       | 空间较优，比双指针稍慢       | 需要排序，且查找稍慢     |

---

## 总结
- **哈希表法**是最直观且效率最高的解法，适合本题数据规模。
- **排序+双指针**在空间受限时更优。
- **二分查找**是哈希表和双指针的折中方案。

**推荐使用哈希表法**，因为其时间复杂度最低，且代码简洁易懂。

---

*获取时间: 2026-02-26 17:52:02*
