# 2696. 删除子串后的字符串最小长度

**难度**: Easy

**标签**: 栈, 字符串, 模拟

**链接**: https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/

---

## 题目描述

<p>给你一个仅由 <strong>大写</strong> 英文字符组成的字符串 <code>s</code> 。</p>

<p>你可以对此字符串执行一些操作，在每一步操作中，你可以从 <code>s</code> 中删除 <strong>任一个</strong> <code>"AB"</code> 或 <code>"CD"</code> 子字符串。</p>

<p>通过执行操作，删除所有&nbsp;<code>"AB"</code> 和 <code>"CD"</code> 子串，返回可获得的最终字符串的 <strong>最小</strong> 可能长度。</p>

<p><strong>注意</strong>，删除子串后，重新连接出的字符串可能会产生新的&nbsp;<code>"AB"</code> 或 <code>"CD"</code> 子串。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "ABFCACDB"
<strong>输出：</strong>2
<strong>解释：</strong>你可以执行下述操作：
- 从 "<em><strong>AB</strong></em>FCACDB" 中删除子串 "AB"，得到 s = "FCACDB" 。
- 从 "FCA<em><strong>CD</strong></em>B" 中删除子串 "CD"，得到 s = "FCAB" 。
- 从 "FC<strong><em>AB</em></strong>" 中删除子串 "AB"，得到 s = "FC" 。
最终字符串的长度为 2 。
可以证明 2 是可获得的最小长度。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "ACBBD"
<strong>输出：</strong>5
<strong>解释：</strong>无法执行操作，字符串长度不变。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> 仅由大写英文字母组成</li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int minLength(string s) {
        
    }
};
```

### Java

```java
class Solution {
    public int minLength(String s) {
        
    }
}
```

### Python3

```python3
class Solution:
    def minLength(self, s: str) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var minLength = function(s) {
    
};
```

### Go

```golang
func minLength(s string) int {
    
}
```

---

## 提示

1. Can we use brute force to solve the problem?
2. Repeatedly traverse the string to find and remove the substrings “AB” and “CD” until no more occurrences exist.
3. Can the solution be optimized using a stack?

---

## 示例测试用例

```
"ABFCACDB"
```

---

## AI 解答 (DeepSeek)

## 题目分析
题目要求从字符串中不断删除子串 "AB" 或 "CD"，删除后剩余部分会拼接起来，可能形成新的可删除子串，直到无法删除为止。目标是最终字符串的最小长度。

**关键点**：
- 删除操作可以按任意顺序进行
- 删除后相邻字符可能形成新的 "AB" 或 "CD"
- 最终字符串中不能包含 "AB" 或 "CD"

## 解题思路
这个问题类似于括号匹配，可以用栈来模拟删除过程。遍历字符串，将字符压入栈，如果栈顶和当前字符组成 "AB" 或 "CD"，则弹出栈顶（相当于删除这对字符），否则压入当前字符。

---

## 解法一：栈模拟（最优解法）
### 思路
使用栈来模拟删除过程：
1. 遍历字符串中的每个字符
2. 如果栈不为空且栈顶字符与当前字符组成 "AB" 或 "CD"，则弹出栈顶
3. 否则将当前字符压入栈
4. 最终栈的大小就是最小长度

### 代码实现
#### Go
```go
func minLength(s string) int {
    stack := []byte{}
    for i := 0; i < len(s); i++ {
        if len(stack) > 0 {
            top := stack[len(stack)-1]
            if (top == 'A' && s[i] == 'B') || (top == 'C' && s[i] == 'D') {
                stack = stack[:len(stack)-1] // 弹出栈顶
                continue
            }
        }
        stack = append(stack, s[i])
    }
    return len(stack)
}
```

#### C++
```cpp
#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    int minLength(string s) {
        vector<char> stack;
        for (char c : s) {
            if (!stack.empty()) {
                char top = stack.back();
                if ((top == 'A' && c == 'B') || (top == 'C' && c == 'D')) {
                    stack.pop_back();
                    continue;
                }
            }
            stack.push_back(c);
        }
        return stack.size();
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，每个字符最多入栈和出栈一次
- **空间复杂度**：O(n)，最坏情况下所有字符都在栈中

---

## 解法二：递归删除
### 思路
递归地查找并删除 "AB" 或 "CD"，直到字符串不再变化为止。

### 代码实现
#### Go
```go
func minLength(s string) int {
    for {
        newStr := ""
        i := 0
        for i < len(s) {
            if i+1 < len(s) && ((s[i] == 'A' && s[i+1] == 'B') || (s[i] == 'C' && s[i+1] == 'D')) {
                i += 2 // 跳过这两个字符
            } else {
                newStr += string(s[i])
                i++
            }
        }
        if newStr == s {
            break
        }
        s = newStr
    }
    return len(s)
}
```

#### C++
```cpp
#include <string>
using namespace std;

class Solution {
public:
    int minLength(string s) {
        while (true) {
            string newStr;
            int i = 0;
            while (i < s.length()) {
                if (i + 1 < s.length() && 
                   ((s[i] == 'A' && s[i+1] == 'B') || 
                    (s[i] == 'C' && s[i+1] == 'D'))) {
                    i += 2;
                } else {
                    newStr.push_back(s[i]);
                    i++;
                }
            }
            if (newStr == s) break;
            s = newStr;
        }
        return s.length();
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n²)，最坏情况下每次只删除一对字符，需要 O(n) 轮
- **空间复杂度**：O(n)，需要额外的字符串存储中间结果

---

## 解法三：双指针原地修改
### 思路
使用双指针模拟栈的行为，直接在原字符串上修改：
- `i` 指向栈顶的下一个位置
- 遍历字符串，如果当前字符与栈顶组成 "AB" 或 "CD"，则 `i--`（弹出栈顶）
- 否则将当前字符放入栈顶位置，`i++`

### 代码实现
#### Go
```go
func minLength(s string) int {
    stack := make([]byte, len(s))
    i := 0 // 栈顶指针（指向下一个空位）
    
    for _, ch := range s {
        if i > 0 {
            top := stack[i-1]
            if (top == 'A' && byte(ch) == 'B') || (top == 'C' && byte(ch) == 'D') {
                i-- // 弹出栈顶
                continue
            }
        }
        stack[i] = byte(ch)
        i++
    }
    return i
}
```

#### C++
```cpp
#include <string>
using namespace std;

class Solution {
public:
    int minLength(string s) {
        int i = 0; // 栈顶指针
        for (char c : s) {
            if (i > 0) {
                char top = s[i-1];
                if ((top == 'A' && c == 'B') || (top == 'C' && c == 'D')) {
                    i--; // 弹出栈顶
                    continue;
                }
            }
            s[i++] = c;
        }
        return i;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，一次遍历
- **空间复杂度**：O(1)（原地修改）或 O(n)（Go 版本需要额外数组）

---

## 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 栈模拟 | O(n) | O(n) | 高效直观，一次遍历 | 需要额外栈空间 |
| 递归删除 | O(n²) | O(n) | 思路简单 | 效率低，重复扫描 |
| 双指针原地 | O(n) | O(1) | 空间最优 | 修改原字符串（可能不允许） |

## 总结
**推荐使用解法一（栈模拟）**：
- 时间复杂度最优
- 代码简洁易懂
- 符合栈的典型应用场景（类似括号匹配）
- 在实际面试和竞赛中最常用

对于特别注重空间的情况，可以考虑解法三（双指针原地修改），但需要注意是否允许修改输入字符串。

---

*获取时间: 2026-02-28 16:16:03*
