# 1. 两数之和

**难度**: Easy

**标签**: 数组, 哈希表

**链接**: https://leetcode.cn/problems/two-sum/

---

## 题目描述

<p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>&nbsp; 的那&nbsp;<strong>两个</strong>&nbsp;整数，并返回它们的数组下标。</p>

<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>

<p>你可以按任意顺序返回答案。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,7,11,15], target = 9
<strong>输出：</strong>[0,1]
<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,2,4], target = 6
<strong>输出：</strong>[1,2]
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,3], target = 6
<strong>输出：</strong>[0,1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
	<li><strong>只会存在一个有效答案</strong></li>
</ul>

<p>&nbsp;</p>

<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法吗？</p>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
    }
};
```

### Java

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        
    }
}
```

### Python3

```python3
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    
};
```

### Go

```golang
func twoSum(nums []int, target int) []int {
    
}
```

---

## 提示

1. A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions just for completeness. It is from these brute force solutions that you can come up with optimizations.
2. So, if we fix one of the numbers, say <code>x</code>, we have to scan the entire array to find the next number <code>y</code> which is <code>value - x</code> where value is the input parameter. Can we change our array somehow so that this search becomes faster?
3. The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?

---

## 示例测试用例

```
[2,7,11,15]
9
```

---

## AI 解答 (DeepSeek)

# 两数之和 - 详细解题分析

## 1. 题目分析和解题思路

**问题核心**：在数组中找到两个数，使它们的和等于目标值 target。

**关键约束**：
- 不能使用同一个元素两次
- 假设只有一个有效答案
- 需要返回元素的下标（不是值本身）

**基本思路**：
1. **暴力枚举**：遍历所有可能的元素对，检查它们的和是否等于 target
2. **哈希表优化**：利用哈希表存储已遍历元素的值和下标，快速查找 complement = target - current

## 2. 不同解法及实现

### 解法一：暴力枚举法
**思路**：使用两层循环遍历所有可能的元素组合

```go
// Go 实现
func twoSum(nums []int, target int) []int {
    n := len(nums)
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil
}
```

```cpp
// C++ 实现
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n²)，两层循环
- 空间复杂度：O(1)，只使用了常数空间

### 解法二：哈希表法（一次遍历）
**思路**：遍历数组，对于每个元素，检查 target - nums[i] 是否在哈希表中

```go
// Go 实现
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)
    
    for i, num := range nums {
        complement := target - num
        if idx, exists := hashMap[complement]; exists {
            return []int{idx, i}
        }
        hashMap[num] = i
    }
    return nil
}
```

```cpp
// C++ 实现
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashMap;
        
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (hashMap.find(complement) != hashMap.end()) {
                return {hashMap[complement], i};
            }
            hashMap[nums[i]] = i;
        }
        return {};
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，只需一次遍历
- 空间复杂度：O(n)，最坏情况下需要存储所有元素

### 解法三：哈希表法（两次遍历）
**思路**：先构建完整的哈希表，再查找匹配对

```go
// Go 实现
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)
    
    // 第一次遍历：构建哈希表
    for i, num := range nums {
        hashMap[num] = i
    }
    
    // 第二次遍历：查找匹配
    for i, num := range nums {
        complement := target - num
        if idx, exists := hashMap[complement]; exists && idx != i {
            return []int{i, idx}
        }
    }
    return nil
}
```

```cpp
// C++ 实现
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashMap;
        
        // 第一次遍历：构建哈希表
        for (int i = 0; i < nums.size(); i++) {
            hashMap[nums[i]] = i;
        }
        
        // 第二次遍历：查找匹配
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (hashMap.find(complement) != hashMap.end() && hashMap[complement] != i) {
                return {i, hashMap[complement]};
            }
        }
        return {};
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，两次遍历
- 空间复杂度：O(n)，需要存储所有元素

## 3. 解法对比和优缺点

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 暴力枚举 | O(n²) | O(1) | 实现简单，无需额外空间 | 效率低，不适合大数据量 |
| 哈希表（一次遍历） | O(n) | O(n) | 效率最高，一次遍历完成 | 需要额外空间 |
| 哈希表（两次遍历） | O(n) | O(n) | 逻辑清晰，分步明确 | 需要两次遍历 |

## 4. 推荐解法

**推荐使用解法二（哈希表一次遍历）**，原因：
1. **效率最高**：只需一次遍历即可完成
2. **处理重复元素**：当遇到重复元素时，后出现的会覆盖先出现的，这恰好符合题目要求（不能使用同一个元素两次）
3. **代码简洁**：逻辑清晰，易于理解和维护

## 5. 特殊情况处理

1. **重复元素**：如 nums = [3, 3], target = 6
   - 哈希表法能正确处理，因为查找时检查了下标是否相同
   
2. **负数和大数**：题目范围是 -10⁹ 到 10⁹
   - 哈希表法不受数值范围影响

3. **无解情况**：题目保证有且只有一个有效答案，实际应用中可返回空数组或特定值

## 6. 进阶思考

对于更复杂的情况（如需要返回所有可能的解），可以考虑：
1. 使用哈希表存储所有相同值的下标列表
2. 先排序再使用双指针法（但需要额外处理下标信息）

**总结**：两数之和是哈希表应用的经典例题，掌握哈希表解法对于解决类似问题（如三数之和、四数之和）有重要帮助。

---

*获取时间: 2026-02-26 19:05:33*
