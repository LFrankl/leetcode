# 2213. 由单个字符重复的最长子字符串

**难度**: Hard

**标签**: 线段树, 数组, 字符串, 有序集合

**链接**: https://leetcode.cn/problems/longest-substring-of-one-repeating-character/

---

## 题目描述

<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>k</code> 的字符串 <code>queryCharacters</code> ，一个下标从 <code>0</code> 开始、长度也是 <code>k</code> 的整数 <strong>下标</strong> 数组&nbsp;<code>queryIndices</code> ，这两个都用来描述 <code>k</code> 个查询。</p>

<p>第 <code>i</code> 个查询会将 <code>s</code> 中位于下标 <code>queryIndices[i]</code> 的字符更新为 <code>queryCharacters[i]</code> 。</p>

<p>返回一个长度为 <code>k</code> 的数组 <code>lengths</code> ，其中 <code>lengths[i]</code> 是在执行第 <code>i</code> 个查询 <strong>之后</strong> <code>s</code> 中仅由 <strong>单个字符重复</strong> 组成的 <strong>最长子字符串</strong> 的 <strong>长度</strong> <em>。</em></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]
<strong>输出：</strong>[3,3,4]
<strong>解释：</strong>
- 第 1 次查询更新后 s = "<em>b<strong>b</strong>b</em>acc" 。由单个字符重复组成的最长子字符串是 "bbb" ，长度为 3 。
- 第 2 次查询更新后 s = "bbb<em><strong>c</strong>cc</em>" 。由单个字符重复组成的最长子字符串是 "bbb" 或 "ccc"，长度为 3 。
- 第 3 次查询更新后 s = "<em>bbb<strong>b</strong></em>cc" 。由单个字符重复组成的最长子字符串是 "bbbb" ，长度为 4 。
因此，返回 [3,3,4] 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "abyzz", queryCharacters = "aa", queryIndices = [2,1]
<strong>输出：</strong>[2,3]
<strong>解释：</strong>
- 第 1 次查询更新后 s = "ab<strong>a</strong><em>zz</em>" 。由单个字符重复组成的最长子字符串是 "zz" ，长度为 2 。
- 第 2 次查询更新后 s = "<em>a<strong>a</strong>a</em>zz" 。由单个字符重复组成的最长子字符串是 "aaa" ，长度为 3 。
因此，返回 [2,3] 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> 由小写英文字母组成</li>
	<li><code>k == queryCharacters.length == queryIndices.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li><code>queryCharacters</code> 由小写英文字母组成</li>
	<li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {
        
    }
};
```

### Java

```java
class Solution {
    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {
        
    }
}
```

### Python3

```python3
class Solution:
    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:
        
```

### JavaScript

```javascript
/**
 * @param {string} s
 * @param {string} queryCharacters
 * @param {number[]} queryIndices
 * @return {number[]}
 */
var longestRepeating = function(s, queryCharacters, queryIndices) {
    
};
```

### Go

```golang
func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    
}
```

---

## 提示

1. Use a segment tree to perform fast point updates and range queries.
2. We need each segment tree node to store the length of the longest substring of that segment consisting of only 1 repeating character.
3. We will also have each segment tree node store the leftmost and rightmost character of the segment, the max length of a prefix substring consisting of only 1 repeating character, and the max length of a suffix substring consisting of only 1 repeating character.
4. Use this information to properly merge the two segment tree nodes together.

---

## 示例测试用例

```
"babacc"
"bcb"
[1,3,3]
```

---

## AI 解答 (DeepSeek)

## 题目分析

**问题核心**：
- 初始字符串 `s`，长度 `n ≤ 1e5`
- 有 `k ≤ 1e5` 次查询，每次查询将 `s[pos]` 修改为指定字符
- 每次修改后，需要返回当前字符串中**由相同字符组成的连续子串的最大长度**

**关键点**：
- 每次修改后需要快速计算最长连续相同字符的长度
- 暴力方法（每次 O(n) 扫描）会超时：O(nk) = 1e10
- 需要维护动态信息，支持单点更新和快速查询全局最大值

---

## 解题思路

### 思路一：线段树维护区间信息（推荐）
**核心思想**：
- 用线段树维护每个区间的最长连续相同字符信息
- 每个节点存储：
  1. 区间长度 `len`
  2. 前缀最长连续长度 `preLen`
  3. 后缀最长连续长度 `sufLen`
  4. 区间内最长连续长度 `maxLen`
  5. 区间左端字符 `leftChar`
  6. 区间右端字符 `rightChar`
- 合并两个子区间时：
  - 如果左子区间的右字符 == 右子区间的左字符，则可以合并
  - 更新 `preLen`, `sufLen`, `maxLen`
- 每次修改更新叶子节点，向上合并
- 根节点的 `maxLen` 就是答案

**时间复杂度**：
- 建树：O(n)
- 每次查询更新：O(log n)
- 总复杂度：O((n + k) log n)

**空间复杂度**：O(n)

---

### 思路二：分块法
**核心思想**：
- 将字符串分成若干块（每块大小 ≈ √n）
- 每块维护：
  - 块内最长连续长度
  - 块内前缀连续长度
  - 块内后缀连续长度
  - 块内字符
- 更新时只更新所在块
- 查询时：
  - 块内直接计算
  - 块间需要考虑连接处

**时间复杂度**：
- 更新：O(√n)
- 查询：O(√n)
- 总复杂度：O(k√n)

**空间复杂度**：O(n)

---

### 思路三：平衡树（Treap/Splay）维护连续段
**核心思想**：
- 将字符串视为若干连续相同字符的段
- 用平衡树维护这些段（每段记录字符、长度、起始位置）
- 修改时：
  - 找到包含该位置的段
  - 可能分裂段（修改点在段中间）
  - 更新字符
  - 合并相邻相同字符的段
- 查询时：平衡树中维护的最大长度

**时间复杂度**：
- 每次操作：O(log m)，m 为段数
- 总复杂度：O((n + k) log n)

**空间复杂度**：O(n)

---

## 代码实现

### 解法一：线段树（最优解）

```go
type Node struct {
    leftChar, rightChar byte
    preLen, sufLen, maxLen, size int
}

type SegmentTree struct {
    n int
    s []byte
    nodes []Node
}

func NewSegmentTree(str string) *SegmentTree {
    n := len(str)
    st := &SegmentTree{
        n: n,
        s: []byte(str),
        nodes: make([]Node, 4*n),
    }
    st.build(1, 0, n-1)
    return st
}

func (st *SegmentTree) build(idx, l, r int) {
    if l == r {
        ch := st.s[l]
        st.nodes[idx] = Node{
            leftChar: ch,
            rightChar: ch,
            preLen: 1,
            sufLen: 1,
            maxLen: 1,
            size: 1,
        }
        return
    }
    mid := (l + r) / 2
    st.build(idx*2, l, mid)
    st.build(idx*2+1, mid+1, r)
    st.pushUp(idx)
}

func (st *SegmentTree) pushUp(idx int) {
    left := &st.nodes[idx*2]
    right := &st.nodes[idx*2+1]
    node := &st.nodes[idx]
    
    node.leftChar = left.leftChar
    node.rightChar = right.rightChar
    node.size = left.size + right.size
    
    // 前缀长度
    node.preLen = left.preLen
    if left.preLen == left.size && left.rightChar == right.leftChar {
        node.preLen = left.size + right.preLen
    }
    
    // 后缀长度
    node.sufLen = right.sufLen
    if right.sufLen == right.size && left.rightChar == right.leftChar {
        node.sufLen = right.size + left.sufLen
    }
    
    // 最大长度
    node.maxLen = max(left.maxLen, right.maxLen)
    if left.rightChar == right.leftChar {
        node.maxLen = max(node.maxLen, left.sufLen+right.preLen)
    }
}

func (st *SegmentTree) update(pos int, ch byte) {
    st.updateHelper(1, 0, st.n-1, pos, ch)
}

func (st *SegmentTree) updateHelper(idx, l, r, pos int, ch byte) {
    if l == r {
        st.nodes[idx].leftChar = ch
        st.nodes[idx].rightChar = ch
        return
    }
    mid := (l + r) / 2
    if pos <= mid {
        st.updateHelper(idx*2, l, mid, pos, ch)
    } else {
        st.updateHelper(idx*2+1, mid+1, r, pos, ch)
    }
    st.pushUp(idx)
}

func (st *SegmentTree) query() int {
    return st.nodes[1].maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    st := NewSegmentTree(s)
    k := len(queryIndices)
    ans := make([]int, k)
    
    for i := 0; i < k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            st.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = st.query()
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```cpp
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

struct Node {
    char leftChar, rightChar;
    int preLen, sufLen, maxLen, size;
};

class SegmentTree {
private:
    int n;
    string s;
    vector<Node> nodes;
    
    void build(int idx, int l, int r) {
        if (l == r) {
            char ch = s[l];
            nodes[idx] = {ch, ch, 1, 1, 1, 1};
            return;
        }
        int mid = (l + r) / 2;
        build(idx * 2, l, mid);
        build(idx * 2 + 1, mid + 1, r);
        pushUp(idx);
    }
    
    void pushUp(int idx) {
        Node& left = nodes[idx * 2];
        Node& right = nodes[idx * 2 + 1];
        Node& node = nodes[idx];
        
        node.leftChar = left.leftChar;
        node.rightChar = right.rightChar;
        node.size = left.size + right.size;
        
        // 前缀长度
        node.preLen = left.preLen;
        if (left.preLen == left.size && left.rightChar == right.leftChar) {
            node.preLen = left.size + right.preLen;
        }
        
        // 后缀长度
        node.sufLen = right.sufLen;
        if (right.sufLen == right.size && left.rightChar == right.leftChar) {
            node.sufLen = right.size + left.sufLen;
        }
        
        // 最大长度
        node.maxLen = max(left.maxLen, right.maxLen);
        if (left.rightChar == right.leftChar) {
            node.maxLen = max(node.maxLen, left.sufLen + right.preLen);
        }
    }
    
    void updateHelper(int idx, int l, int r, int pos, char ch) {
        if (l == r) {
            nodes[idx].leftChar = ch;
            nodes[idx].rightChar = ch;
            return;
        }
        int mid = (l + r) / 2;
        if (pos <= mid) {
            updateHelper(idx * 2, l, mid, pos, ch);
        } else {
            updateHelper(idx * 2 + 1, mid + 1, r, pos, ch);
        }
        pushUp(idx);
    }

public:
    SegmentTree(const string& str) : s(str) {
        n = s.length();
        nodes.resize(4 * n);
        build(1, 0, n - 1);
    }
    
    void update(int pos, char ch) {
        updateHelper(1, 0, n - 1, pos, ch);
    }
    
    int query() {
        return nodes[1].maxLen;
    }
};

class Solution {
public:
    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {
        SegmentTree st(s);
        int k = queryIndices.size();
        vector<int> ans(k);
        
        for (int i = 0; i < k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                st.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = st.query();
        }
        return ans;
    }
};
```

---

### 解法二：分块法

```go
type Block struct {
    start, end int
    chars []byte
    preLen, sufLen, maxLen int
}

func (b *Block) recalc() {
    n := len(b.chars)
    b.preLen = 1
    for i := 1; i < n && b.chars[i] == b.chars[0]; i++ {
        b.preLen++
    }
    
    b.sufLen = 1
    for i := n - 2; i >= 0 && b.chars[i] == b.chars[n-1]; i-- {
        b.sufLen++
    }
    
    b.maxLen = 1
    cur := 1
    for i := 1; i < n; i++ {
        if b.chars[i] == b.chars[i-1] {
            cur++
            if cur > b.maxLen {
                b.maxLen = cur
            }
        } else {
            cur = 1
        }
    }
}

type BlockArray struct {
    blocks []*Block
    blockSize int
    s []byte
}

func NewBlockArray(s string, blockSize int) *BlockArray {
    n := len(s)
    ba := &BlockArray{
        s: []byte(s),
        blockSize: blockSize,
    }
    for i := 0; i < n; i += blockSize {
        end := min(i+blockSize, n)
        block := &Block{
            start: i,
            end: end,
            chars: []byte(s[i:end]),
        }
        block.recalc()
        ba.blocks = append(ba.blocks, block)
    }
    return ba
}

func (ba *BlockArray) update(pos int, ch byte) {
    ba.s[pos] = ch
    blockIdx := pos / ba.blockSize
    block := ba.blocks[blockIdx]
    localPos := pos % ba.blockSize
    block.chars[localPos] = ch
    block.recalc()
}

func (ba *BlockArray) query() int {
    maxLen := 0
    lastChar := byte(0)
    lastLen := 0
    
    for _, block := range ba.blocks {
        maxLen = max(maxLen, block.maxLen)
        
        // 处理块间连接
        if lastChar != 0 && lastChar == block.chars[0] {
            total := lastLen + block.preLen
            maxLen = max(maxLen, total)
        }
        
        // 更新 lastChar 和 lastLen
        if block.sufLen == len(block.chars) {
            if lastChar == block.chars[0] {
                lastLen += len(block.chars)
            } else {
                lastLen = block.sufLen
                lastChar = block.chars[0]
            }
        } else {
            lastLen = block.sufLen
            lastChar = block.chars[len(block.chars)-1]
        }
    }
    return maxLen
}

func longestRepeating(s string, queryCharacters string, queryIndices []int) []int {
    n := len(s)
    blockSize := int(math.Sqrt(float64(n))) + 1
    ba := NewBlockArray(s, blockSize)
    
    k := len(queryIndices)
    ans := make([]int, k)
    
    for i := 0; i < k; i++ {
        pos := queryIndices[i]
        ch := queryCharacters[i]
        if s[pos] != ch {
            ba.update(pos, ch)
            s = s[:pos] + string(ch) + s[pos+1:]
        }
        ans[i] = ba.query()
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```cpp
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
using namespace std;

struct Block {
    int start, end;
    vector<char> chars;
    int preLen, sufLen, maxLen;
    
    void recalc() {
        int n = chars.size();
        // 计算前缀长度
        preLen = 1;
        for (int i = 1; i < n && chars[i] == chars[0]; i++) {
            preLen++;
        }
        
        // 计算后缀长度
        sufLen = 1;
        for (int i = n - 2; i >= 0 && chars[i] == chars[n-1]; i--) {
            sufLen++;
        }
        
        // 计算最大长度
        maxLen = 1;
        int cur = 1;
        for (int i = 1; i < n; i++) {
            if (chars[i] == chars[i-1]) {
                cur++;
                maxLen = max(maxLen, cur);
            } else {
                cur = 1;
            }
        }
    }
};

class BlockArray {
private:
    vector<Block> blocks;
    int blockSize;
    string s;
    
public:
    BlockArray(const string& str, int bs) : s(str), blockSize(bs) {
        int n = s.length();
        for (int i = 0; i < n; i += blockSize) {
            int end = min(i + blockSize, n);
            Block block;
            block.start = i;
            block.end = end;
            for (int j = i; j < end; j++) {
                block.chars.push_back(s[j]);
            }
            block.recalc();
            blocks.push_back(block);
        }
    }
    
    void update(int pos, char ch) {
        s[pos] = ch;
        int blockIdx = pos / blockSize;
        int localPos = pos % blockSize;
        blocks[blockIdx].chars[localPos] = ch;
        blocks[blockIdx].recalc();
    }
    
    int query() {
        int maxLen = 0;
        char lastChar = 0;
        int lastLen = 0;
        
        for (auto& block : blocks) {
            maxLen = max(maxLen, block.maxLen);
            
            // 处理块间连接
            if (lastChar != 0 && lastChar == block.chars[0]) {
                int total = lastLen + block.preLen;
                maxLen = max(maxLen, total);
            }
            
            // 更新 lastChar 和 lastLen
            if (block.sufLen == (int)block.chars.size()) {
                if (lastChar == block.chars[0]) {
                    lastLen += block.chars.size();
                } else {
                    lastLen = block.sufLen;
                    lastChar = block.chars[0];
                }
            } else {
                lastLen = block.sufLen;
                lastChar = block.chars.back();
            }
        }
        return maxLen;
    }
};

class Solution {
public:
    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {
        int n = s.length();
        int blockSize = sqrt(n) + 1;
        BlockArray ba(s, blockSize);
        
        int k = queryIndices.size();
        vector<int> ans(k);
        
        for (int i = 0; i < k; i++) {
            int pos = queryIndices[i];
            char ch = queryCharacters[i];
            if (s[pos] != ch) {
                ba.update(pos, ch);
                s[pos] = ch;
            }
            ans[i] = ba.query();
        }
        return ans;
    }
};
```

---

## 复杂度分析

### 解法一：线段树
- **时间复杂度**：
  - 建树：O(n)
  - 每次更新：O(log n)
  - 总复杂度：O((n + k) log n)
- **空间复杂度**：O(n)

### 解法二：分块法
- **时间复杂度**：
  - 初始化：O(n)
  - 每次更新：O(√n)（更新一个块）
  - 每次查询：O(√n)（遍历所有块）
  - 总复杂度：O(k√n)
- **空间复杂度**：O(n)

---

## 解法对比

| 特性

---

*获取时间: 2026-02-26 17:50:30*
