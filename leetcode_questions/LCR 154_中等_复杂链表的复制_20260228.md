# LCR 154. 复杂链表的复制

**难度**: Medium

**标签**: 哈希表, 链表

**链接**: https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/

---

## 题目描述

<p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/01/09/e1.png"></p>

<pre><strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/01/09/e2.png"></p>

<pre><strong>输入：</strong>head = [[1,1],[2,1]]
<strong>输出：</strong>[[1,1],[2,1]]
</pre>

<p><strong>示例 3：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/01/09/e3.png"></strong></p>

<pre><strong>输入：</strong>head = [[3,null],[3,0],[3,null]]
<strong>输出：</strong>[[3,null],[3,0],[3,null]]
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
<strong>解释：</strong>给定的链表为空（空指针），因此返回 null。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
	<li><code>Node.random</code>&nbsp;为空（null）或指向链表中的节点。</li>
	<li>节点数目不超过 1000 。</li>
</ul>

<p>&nbsp;</p>

<p><strong>注意：</strong>本题与主站 138 题相同：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>

<p>&nbsp;</p>


---

## 代码模板


### C++

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        
    }
};
```

### Java

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        
    }
}
```

### Python3

```python3
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        
```

### JavaScript

```javascript
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function(head) {
    
};
```

### Go

```golang
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
    
}
```

---

## 示例测试用例

```
[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

---

## AI 解答 (DeepSeek)

## 题目分析
这是一个复杂链表的深拷贝问题。每个节点包含：
- `val`：节点值
- `next`：指向下一个节点
- `random`：随机指向链表中的任意节点或 null

难点在于：复制链表时，需要正确处理 `random` 指针的指向关系，因为新节点的 `random` 应该指向新链表中的对应节点，而不是原链表中的节点。

## 解题思路

### 核心挑战
1. 如何建立原节点和新节点的对应关系
2. 如何高效地设置新节点的 `random` 指针

## 解法一：哈希表映射法

### 思路
1. 第一次遍历：创建所有新节点，并用哈希表建立原节点到新节点的映射
2. 第二次遍历：根据哈希表设置新节点的 `next` 和 `random` 指针

### 时间复杂度：O(n)
### 空间复杂度：O(n)

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */
func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }
    
    // 创建哈希表，存储原节点到新节点的映射
    nodeMap := make(map[*Node]*Node)
    
    // 第一次遍历：创建所有新节点
    cur := head
    for cur != nil {
        newNode := &Node{Val: cur.Val}
        nodeMap[cur] = newNode
        cur = cur.Next
    }
    
    // 第二次遍历：设置新节点的 next 和 random 指针
    cur = head
    for cur != nil {
        newNode := nodeMap[cur]
        if cur.Next != nil {
            newNode.Next = nodeMap[cur.Next]
        }
        if cur.Random != nil {
            newNode.Random = nodeMap[cur.Random]
        }
        cur = cur.Next
    }
    
    return nodeMap[head]
}
```

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;
        
        // 哈希表存储原节点到新节点的映射
        unordered_map<Node*, Node*> nodeMap;
        
        // 第一次遍历：创建所有新节点
        Node* cur = head;
        while (cur) {
            nodeMap[cur] = new Node(cur->val);
            cur = cur->next;
        }
        
        // 第二次遍历：设置新节点的 next 和 random 指针
        cur = head;
        while (cur) {
            Node* newNode = nodeMap[cur];
            if (cur->next) {
                newNode->next = nodeMap[cur->next];
            }
            if (cur->random) {
                newNode->random = nodeMap[cur->random];
            }
            cur = cur->next;
        }
        
        return nodeMap[head];
    }
};
```

## 解法二：原地修改法（节点拆分法）

### 思路
1. 第一次遍历：在每个原节点后面插入一个复制的新节点
   - 原链表：A->B->C
   - 修改后：A->A'->B->B'->C->C'
2. 第二次遍历：设置新节点的 `random` 指针
   - 新节点的 `random` = 原节点 `random` 的 next
3. 第三次遍历：拆分两个链表，恢复原链表并构建新链表

### 时间复杂度：O(n)
### 空间复杂度：O(1)（不考虑输出占用的空间）

```go
func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }
    
    // 第一步：在每个节点后面插入复制节点
    cur := head
    for cur != nil {
        newNode := &Node{Val: cur.Val}
        newNode.Next = cur.Next
        cur.Next = newNode
        cur = newNode.Next
    }
    
    // 第二步：设置复制节点的 random 指针
    cur = head
    for cur != nil {
        if cur.Random != nil {
            cur.Next.Random = cur.Random.Next
        }
        cur = cur.Next.Next
    }
    
    // 第三步：拆分两个链表
    cur = head
    newHead := head.Next
    copyCur := newHead
    
    for cur != nil {
        cur.Next = cur.Next.Next
        cur = cur.Next
        
        if copyCur.Next != nil {
            copyCur.Next = copyCur.Next.Next
            copyCur = copyCur.Next
        }
    }
    
    return newHead
}
```

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;
        
        // 第一步：在每个节点后面插入复制节点
        Node* cur = head;
        while (cur) {
            Node* newNode = new Node(cur->val);
            newNode->next = cur->next;
            cur->next = newNode;
            cur = newNode->next;
        }
        
        // 第二步：设置复制节点的 random 指针
        cur = head;
        while (cur) {
            if (cur->random) {
                cur->next->random = cur->random->next;
            }
            cur = cur->next->next;
        }
        
        // 第三步：拆分两个链表
        cur = head;
        Node* newHead = head->next;
        Node* copyCur = newHead;
        
        while (cur) {
            cur->next = cur->next->next;
            cur = cur->next;
            
            if (copyCur->next) {
                copyCur->next = copyCur->next->next;
                copyCur = copyCur->next;
            }
        }
        
        return newHead;
    }
};
```

## 解法三：递归+哈希表（DFS）

### 思路
1. 使用递归深度优先遍历链表
2. 用哈希表记录已经复制过的节点，避免重复复制
3. 递归复制当前节点，然后递归复制 `next` 和 `random` 指向的节点

### 时间复杂度：O(n)
### 空间复杂度：O(n)（递归栈空间+哈希表）

```go
func copyRandomList(head *Node) *Node {
    visited := make(map[*Node]*Node)
    return dfs(head, visited)
}

func dfs(node *Node, visited map[*Node]*Node) *Node {
    if node == nil {
        return nil
    }
    
    // 如果节点已经复制过，直接返回
    if newNode, ok := visited[node]; ok {
        return newNode
    }
    
    // 创建新节点
    newNode := &Node{Val: node.Val}
    visited[node] = newNode
    
    // 递归复制 next 和 random
    newNode.Next = dfs(node.Next, visited)
    newNode.Random = dfs(node.Random, visited)
    
    return newNode
}
```

```cpp
class Solution {
private:
    unordered_map<Node*, Node*> visited;
    
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;
        
        // 如果节点已经复制过，直接返回
        if (visited.find(head) != visited.end()) {
            return visited[head];
        }
        
        // 创建新节点
        Node* newNode = new Node(head->val);
        visited[head] = newNode;
        
        // 递归复制 next 和 random
        newNode->next = copyRandomList(head->next);
        newNode->random = copyRandomList(head->random);
        
        return newNode;
    }
};
```

## 复杂度对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|-----------|------|------|
| 哈希表映射法 | O(n) | O(n) | 思路清晰，实现简单 | 需要额外 O(n) 空间 |
| 原地修改法 | O(n) | O(1) | 空间效率高 | 修改了原链表，需要恢复 |
| 递归+哈希表 | O(n) | O(n) | 代码简洁，递归思路清晰 | 递归栈可能溢出，空间复杂度高 |

## 总结

1. **哈希表映射法**是最直观的解法，适合面试时快速实现
2. **原地修改法**空间效率最高，但会修改原链表，需要注意是否允许修改原链表
3. **递归+哈希表**代码简洁，但递归可能造成栈溢出，适合链表不太长的情况

在实际面试中，建议先讲解哈希表映射法，然后优化到原地修改法，展示对空间复杂度的优化能力。

---

*获取时间: 2026-02-28 16:17:17*
