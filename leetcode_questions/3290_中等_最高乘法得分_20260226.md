# 3290. 最高乘法得分

**难度**: Medium

**标签**: 数组, 动态规划

**链接**: https://leetcode.cn/problems/maximum-multiplication-score/

---

## 题目描述

<p>给你一个大小为 4 的整数数组 <code>a</code> 和一个大小 <strong>至少</strong>为 4 的整数数组 <code>b</code>。</p>

<p>你需要从数组 <code>b</code> 中选择四个下标 <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, 和 <code>i<sub>3</sub></code>，并满足 <code>i<sub>0</sub> &lt; i<sub>1</sub> &lt; i<sub>2</sub> &lt; i<sub>3</sub></code>。你的得分将是 <code>a[0] * b[i<sub>0</sub>] + a[1] * b[i<sub>1</sub>] + a[2] * b[i<sub>2</sub>] + a[3] * b[i<sub>3</sub>]</code> 的值。</p>

<p>返回你能够获得的 <strong>最大 </strong>得分。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<div class="example-block">
<p><strong>输入：</strong> <span class="example-io">a = [3,2,5,6], b = [2,-6,4,-5,-3,2,-7]</span></p>

<p><strong>输出：</strong> <span class="example-io">26</span></p>

<p><strong>解释：</strong><br />
选择下标 0, 1, 2 和 5。得分为 <code>3 * 2 + 2 * (-6) + 5 * 4 + 6 * 2 = 26</code>。</p>
</div>

<p><strong class="example">示例 2：</strong></p>

<div class="example-block">
<p><strong>输入：</strong> <span class="example-io">a = [-1,4,5,-2], b = [-5,-1,-3,-2,-4]</span></p>

<p><strong>输出：</strong> <span class="example-io">-1</span></p>

<p><strong>解释：</strong><br />
选择下标 0, 1, 3 和 4。得分为 <code>(-1) * (-5) + 4 * (-1) + 5 * (-2) + (-2) * (-4) = -1</code>。</p>
</div>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>a.length == 4</code></li>
	<li><code>4 &lt;= b.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= a[i], b[i] &lt;= 10<sup>5</sup></code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    long long maxScore(vector<int>& a, vector<int>& b) {
        
    }
};
```

### Java

```java
class Solution {
    public long maxScore(int[] a, int[] b) {
        
    }
}
```

### Python3

```python3
class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} a
 * @param {number[]} b
 * @return {number}
 */
var maxScore = function(a, b) {
    
};
```

### Go

```golang
func maxScore(a []int, b []int) int64 {
    
}
```

---

## 提示

1. Try using dynamic programming.
2. Consider a dp with the following states: The current position in the array b, and the number of indices considered.

---

## 示例测试用例

```
[3,2,5,6]
[2,-6,4,-5,-3,2,-7]
```

---

## AI 解答 (DeepSeek)

## 题目分析

我们需要从数组 `b` 中选择 4 个索引（保持顺序），与固定长度为 4 的数组 `a` 对应相乘求和，使得得分最大。

**关键约束**：
- `a` 长度固定为 4
- `b` 长度 `n ≥ 4`
- 选择的 4 个索引必须严格递增：`i0 < i1 < i2 < i3`
- 目标是最大化：`a[0]*b[i0] + a[1]*b[i1] + a[2]*b[i2] + a[3]*b[i3]`

---

## 解题思路

### 思路一：动态规划（4 阶段 DP）
将问题看作在 `b` 中按顺序选择 4 个元素，每个阶段对应一个 `a[k]`。  
定义 `dp[k][i]` 表示从 `b[0..i]` 中选择 `k+1` 个元素（对应 `a[0..k]`）的最大得分。  
转移方程：
```
dp[k][i] = max(dp[k][i-1], dp[k-1][i-1] + a[k] * b[i])
```
其中 `k = 0..3`，`i ≥ k`（因为至少需要 k+1 个元素）。  
最终答案：`dp[3][n-1]`。

**时间复杂度**：O(4n) = O(n)  
**空间复杂度**：O(4n) = O(n)，可优化到 O(1)（滚动数组）

---

### 思路二：分阶段贪心（基于 a 的符号）
由于 `a` 固定为 4 个数，我们可以分阶段选择：
- 如果 `a[k] > 0`，则在可选范围内选择最大的 `b[i]`
- 如果 `a[k] < 0`，则在可选范围内选择最小的 `b[i]`
但必须保证索引递增，所以每个阶段的可选范围是 `b` 的剩余部分。

这种方法需要维护前缀/后缀的最大最小值，实现较复杂，且不一定保证全局最优（因为选择当前最优可能影响后续选择）。

---

### 思路三：四重循环优化（后缀最大值）
对于固定 `i3`，我们需要前三个索引的最优选择。  
可以预处理：
- 对于每个位置 `i`，计算 `a[3]*b[i]` 加上之前三个阶段的最大值。
- 用类似 DP 但反向或正向递推的方式，避免 O(n⁴) 暴力。

实际上，我们可以用 **分阶段后缀最大值** 来优化：
1. 从右往左计算 `max3[i] = max(a[3]*b[j])` 对于 `j ≥ i`
2. 然后计算 `max2[i] = max(a[2]*b[i] + max3[i+1])` 对于 `i`
3. 类似得到 `max1` 和 `max0`。

这样时间复杂度 O(n)，空间 O(n) 或 O(1)。

---

## 解法实现

### 解法一：动态规划（4 阶段 DP，空间优化）
```go
func maxScore(a []int, b []int) int {
    n := len(b)
    // dpPrev 和 dpCurr 分别表示上一阶段和当前阶段
    dpPrev := make([]int, n)
    dpCurr := make([]int, n)
    
    // 初始化 k=0 阶段
    dpCurr[0] = a[0] * b[0]
    for i := 1; i < n; i++ {
        dpCurr[i] = max(dpCurr[i-1], a[0]*b[i])
    }
    
    // 阶段 k=1,2,3
    for k := 1; k < 4; k++ {
        dpPrev, dpCurr = dpCurr, dpPrev
        // i < k 时不可能选 k+1 个元素，跳过
        dpCurr[k] = dpPrev[k-1] + a[k]*b[k]
        for i := k+1; i < n; i++ {
            dpCurr[i] = max(dpCurr[i-1], dpPrev[i-1] + a[k]*b[i])
        }
    }
    return dpCurr[n-1]
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```cpp
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxScore(vector<int>& a, vector<int>& b) {
        int n = b.size();
        vector<long long> dpPrev(n), dpCurr(n);
        // 阶段 0
        dpCurr[0] = (long long)a[0] * b[0];
        for (int i = 1; i < n; i++) {
            dpCurr[i] = max(dpCurr[i-1], (long long)a[0] * b[i]);
        }
        // 阶段 1,2,3
        for (int k = 1; k < 4; k++) {
            swap(dpPrev, dpCurr);
            dpCurr[k] = dpPrev[k-1] + (long long)a[k] * b[k];
            for (int i = k+1; i < n; i++) {
                dpCurr[i] = max(dpCurr[i-1], dpPrev[i-1] + (long long)a[k] * b[i]);
            }
        }
        return dpCurr[n-1];
    }
};
```

**复杂度分析**：
- 时间复杂度：O(4n) = O(n)
- 空间复杂度：O(n)（两个数组）

---

### 解法二：分阶段后缀最大值（反向 DP）
定义：
- `suffix3[i]` = 从 `i` 开始往后选一个数作为第 4 个数的最大 `a[3]*b[j]`
- `suffix2[i]` = 从 `i` 开始往后选两个数（第3、4个）的最大和
- `suffix1[i]` = 从 `i` 开始往后选三个数的最大和
- `suffix0[i]` = 从 `i` 开始往后选四个数的最大和（即最终答案）

递推：
```
suffix3[i] = max(a[3]*b[i], suffix3[i+1])
suffix2[i] = max(a[2]*b[i] + suffix3[i+1], suffix2[i+1])
suffix1[i] = max(a[1]*b[i] + suffix2[i+1], suffix1[i+1])
suffix0[i] = max(a[0]*b[i] + suffix1[i+1], suffix0[i+1])
```
从右往左计算。

```go
func maxScore(a []int, b []int) int {
    n := len(b)
    suffix3 := make([]int64, n)
    suffix2 := make([]int64, n)
    suffix1 := make([]int64, n)
    suffix0 := make([]int64, n)
    
    // 初始化最后一个位置
    suffix3[n-1] = int64(a[3]) * int64(b[n-1])
    suffix2[n-1] = -1 << 62 // 不可能选两个数，设为极小
    suffix1[n-1] = -1 << 62
    suffix0[n-1] = -1 << 62
    
    for i := n-2; i >= 0; i-- {
        // 第 4 个数
        suffix3[i] = max(int64(a[3])*int64(b[i]), suffix3[i+1])
        // 第 3、4 个数
        if i <= n-2 {
            suffix2[i] = max(int64(a[2])*int64(b[i])+suffix3[i+1], suffix2[i+1])
        } else {
            suffix2[i] = -1 << 62
        }
        // 第 2、3、4 个数
        if i <= n-3 {
            suffix1[i] = max(int64(a[1])*int64(b[i])+suffix2[i+1], suffix1[i+1])
        } else {
            suffix1[i] = -1 << 62
        }
        // 第 1、2、3、4 个数
        if i <= n-4 {
            suffix0[i] = max(int64(a[0])*int64(b[i])+suffix1[i+1], suffix0[i+1])
        } else {
            suffix0[i] = -1 << 62
        }
    }
    return int(suffix0[0])
}

func max(x, y int64) int64 {
    if x > y {
        return x
    }
    return y
}
```

```cpp
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxScore(vector<int>& a, vector<int>& b) {
        int n = b.size();
        vector<long long> suffix3(n), suffix2(n), suffix1(n), suffix0(n);
        const long long INF = LLONG_MIN / 2;
        
        suffix3[n-1] = (long long)a[3] * b[n-1];
        suffix2[n-1] = INF;
        suffix1[n-1] = INF;
        suffix0[n-1] = INF;
        
        for (int i = n-2; i >= 0; i--) {
            suffix3[i] = max((long long)a[3] * b[i], suffix3[i+1]);
            
            if (i <= n-2) {
                suffix2[i] = max((long long)a[2] * b[i] + suffix3[i+1], suffix2[i+1]);
            } else {
                suffix2[i] = INF;
            }
            
            if (i <= n-3) {
                suffix1[i] = max((long long)a[1] * b[i] + suffix2[i+1], suffix1[i+1]);
            } else {
                suffix1[i] = INF;
            }
            
            if (i <= n-4) {
                suffix0[i] = max((long long)a[0] * b[i] + suffix1[i+1], suffix0[i+1]);
            } else {
                suffix0[i] = INF;
            }
        }
        return suffix0[0];
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)
- 空间复杂度：O(n)（可优化到 O(1)，只保留最近几个值）

---

### 解法三：四变量滚动 DP（最优空间）
由于只依赖前一阶段，我们可以用 4 个变量分别表示以当前位置结尾的 1、2、3、4 个数的最大得分。

```go
func maxScore(a []int, b []int) int {
    n := len(b)
    // dp1, dp2, dp3, dp4 分别表示选择 1,2,3,4 个数的最大得分
    dp1, dp2, dp3, dp4 := int64(-1e18), int64(-1e18), int64(-1e18), int64(-1e18)
    
    for i := 0; i < n; i++ {
        val := int64(b[i])
        // 注意更新顺序：从多到少，避免重复使用当前元素
        dp4 = max(dp4, dp3 + int64(a[3])*val)
        dp3 = max(dp3, dp2 + int64(a[2])*val)
        dp2 = max(dp2, dp1 + int64(a[1])*val)
        dp1 = max(dp1, int64(a[0])*val)
    }
    return int(dp4)
}

func max(x, y int64) int64 {
    if x > y {
        return x
    }
    return y
}
```

```cpp
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxScore(vector<int>& a, vector<int>& b) {
        int n = b.size();
        long long dp1 = LLONG_MIN, dp2 = LLONG_MIN, dp3 = LLONG_MIN, dp4 = LLONG_MIN;
        for (int i = 0; i < n; i++) {
            long long val = b[i];
            dp4 = max(dp4, dp3 + a[3] * val);
            dp3 = max(dp3, dp2 + a[2] * val);
            dp2 = max(dp2, dp1 + a[1] * val);
            dp1 = max(dp1, a[0] * val);
        }
        return dp4;
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)
- 空间复杂度：O(1)

---

## 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 动态规划（4阶段） | O(n) | O(n) | 直观，易于理解 | 空间可优化 |
| 后缀最大值 | O(n) | O(n) | 反向思维，避免索引越界判断 | 实现稍复杂 |
| 四变量滚动 DP | O(n) | O(1) | 最优空间，代码简洁 | 需要仔细处理更新顺序 |

**推荐解法**：解法三（四变量滚动 DP），因为它在时间和空间上都是最优的，且代码简洁。

---

*获取时间: 2026-02-26 17:48:47*
