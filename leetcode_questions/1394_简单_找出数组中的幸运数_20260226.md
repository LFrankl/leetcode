# 1394. 找出数组中的幸运数

**难度**: Easy

**标签**: 数组, 哈希表, 计数

**链接**: https://leetcode.cn/problems/find-lucky-integer-in-an-array/

---

## 题目描述

<p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>

<p>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p>

<ul>
	<li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li>
	<li>如果数组中不含幸运数，则返回 <strong>-1 </strong>。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>arr = [2,2,3,4]
<strong>输出：</strong>2
<strong>解释：</strong>数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>arr = [1,2,2,3,3,3]
<strong>输出：</strong>3
<strong>解释：</strong>1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>arr = [2,2,2,3,3]
<strong>输出：</strong>-1
<strong>解释：</strong>数组中不存在幸运数。
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>arr = [5]
<strong>输出：</strong>-1
</pre>

<p><strong>示例 5：</strong></p>

<pre><strong>输入：</strong>arr = [7,7,7,7,7,7,7]
<strong>输出：</strong>7
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 500</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 500</code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int findLucky(vector<int>& arr) {
        
    }
};
```

### Java

```java
class Solution {
    public int findLucky(int[] arr) {
        
    }
}
```

### Python3

```python3
class Solution:
    def findLucky(self, arr: List[int]) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var findLucky = function(arr) {
    
};
```

### Go

```golang
func findLucky(arr []int) int {
    
}
```

---

## 提示

1. Count the frequency of each integer in the array.
2. Get all lucky numbers and return the largest of them.

---

## 示例测试用例

```
[2,2,3,4]
```

---

## AI 解答 (DeepSeek)

## 题目分析

我们需要在数组中找到满足以下条件的数字：
1. 数字的出现次数等于数字本身的值
2. 如果有多个这样的数字，返回最大的那个
3. 如果没有，返回 -1

数组长度 ≤ 500，元素值 ≤ 500，因此我们可以使用多种方法解决。

## 解法一：哈希表计数 + 遍历检查

### 解题思路
1. 使用哈希表统计每个数字出现的次数
2. 遍历哈希表，检查每个数字是否满足 `数字 == 出现次数`
3. 记录满足条件的最大数字

### 代码实现

#### Go 实现
```go
func findLucky(arr []int) int {
    // 统计每个数字出现的次数
    freq := make(map[int]int)
    for _, num := range arr {
        freq[num]++
    }
    
    // 寻找最大的幸运数
    maxLucky := -1
    for num, count := range freq {
        if num == count && num > maxLucky {
            maxLucky = num
        }
    }
    
    return maxLucky
}
```

#### C++ 实现
```cpp
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

class Solution {
public:
    int findLucky(vector<int>& arr) {
        // 统计每个数字出现的次数
        unordered_map<int, int> freq;
        for (int num : arr) {
            freq[num]++;
        }
        
        // 寻找最大的幸运数
        int maxLucky = -1;
        for (auto& [num, count] : freq) {
            if (num == count && num > maxLucky) {
                maxLucky = num;
            }
        }
        
        return maxLucky;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，其中 n 是数组长度。需要遍历数组统计频率，然后遍历哈希表检查条件。
- **空间复杂度**：O(k)，其中 k 是数组中不同数字的个数，最坏情况为 O(n)。

## 解法二：数组计数（利用数值范围限制）

### 解题思路
由于题目提示 `1 <= arr[i] <= 500`，我们可以使用固定大小的数组来计数，避免哈希表的开销。

### 代码实现

#### Go 实现
```go
func findLucky(arr []int) int {
    // 因为 arr[i] <= 500，所以创建大小为 501 的数组
    freq := make([]int, 501)
    
    // 统计每个数字出现的次数
    for _, num := range arr {
        freq[num]++
    }
    
    // 从大到小遍历，找到第一个幸运数就是最大的
    for i := 500; i >= 1; i-- {
        if freq[i] == i {
            return i
        }
    }
    
    return -1
}
```

#### C++ 实现
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int findLucky(vector<int>& arr) {
        // 因为 arr[i] <= 500，所以创建大小为 501 的数组
        vector<int> freq(501, 0);
        
        // 统计每个数字出现的次数
        for (int num : arr) {
            freq[num]++;
        }
        
        // 从大到小遍历，找到第一个幸运数就是最大的
        for (int i = 500; i >= 1; i--) {
            if (freq[i] == i) {
                return i;
            }
        }
        
        return -1;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n + 500) = O(n)，其中 n 是数组长度。遍历数组统计频率 O(n)，遍历计数数组 O(500)。
- **空间复杂度**：O(500) = O(1)，使用固定大小的数组。

## 解法三：排序 + 计数

### 解题思路
1. 先对数组排序
2. 遍历排序后的数组，统计连续相同数字的个数
3. 检查是否满足幸运数条件

### 代码实现

#### Go 实现
```go
func findLucky(arr []int) int {
    // 排序
    sort.Ints(arr)
    
    maxLucky := -1
    count := 1
    
    // 遍历数组
    for i := 1; i <= len(arr); i++ {
        if i < len(arr) && arr[i] == arr[i-1] {
            count++
        } else {
            // 检查前一个数字是否是幸运数
            if arr[i-1] == count && count > maxLucky {
                maxLucky = count
            }
            count = 1
        }
    }
    
    return maxLucky
}
```

#### C++ 实现
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int findLucky(vector<int>& arr) {
        // 排序
        sort(arr.begin(), arr.end());
        
        int maxLucky = -1;
        int count = 1;
        
        // 遍历数组
        for (int i = 1; i <= arr.size(); i++) {
            if (i < arr.size() && arr[i] == arr[i-1]) {
                count++;
            } else {
                // 检查前一个数字是否是幸运数
                if (arr[i-1] == count && count > maxLucky) {
                    maxLucky = count;
                }
                count = 1;
            }
        }
        
        return maxLucky;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n log n)，主要是排序的时间复杂度。
- **空间复杂度**：O(1) 或 O(log n)，取决于排序算法的空间复杂度。

## 解法对比

| 解法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 哈希表 | 通用性强，不依赖数值范围 | 有哈希表开销 | 通用情况，数值范围未知 |
| 数组计数 | 效率高，空间固定 | 依赖数值范围限制 | 数值范围已知且不大 |
| 排序+计数 | 不需要额外空间（原地排序） | 时间复杂度较高 | 对空间要求严格，时间要求不高 |

## 推荐解法

对于本题，**解法二（数组计数）是最优的**，因为：
1. 题目明确给出了数值范围限制（1 ≤ arr[i] ≤ 500）
2. 时间复杂度 O(n)，空间复杂度 O(1)（固定大小数组）
3. 实现简单，效率高

在实际面试中，可以先提出哈希表解法，然后根据数值范围优化为数组计数解法，展示对问题的深入思考。

---

*获取时间: 2026-02-26 19:53:18*
