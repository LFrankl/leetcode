# LCR 031. LRU 缓存

**难度**: Medium

**标签**: 设计, 哈希表, 链表, 双向链表

**链接**: https://leetcode.cn/problems/OrIXps/

---

## 题目描述

<div class="title__3Vvk">
<p>运用所掌握的数据结构，设计和实现一个&nbsp; <a href="https://baike.baidu.com/item/LRU" target="_blank">LRU (Least Recently Used，最近最少使用) 缓存机制</a> 。</p>

<p>实现 <code>LRUCache</code> 类：</p>

<ul>
	<li><code>LRUCache(int capacity)</code> 以正整数作为容量&nbsp;<code>capacity</code> 初始化 LRU 缓存</li>
	<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
	<li><code>void put(int key, int value)</code>&nbsp;如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入</strong>
[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>输出</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>解释</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= capacity &lt;= 3000</code></li>
	<li><code>0 &lt;= key &lt;= 10000</code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
	<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
</div>

<p>&nbsp;</p>

<p><strong>进阶</strong>：是否可以在&nbsp;<code>O(1)</code> 时间复杂度内完成这两种操作？</p>

<p>&nbsp;</p>

<p><meta charset="UTF-8" />注意：本题与主站 146&nbsp;题相同：<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a>&nbsp;</p>


---

## 代码模板


### C++

```cpp
class LRUCache {
public:
    LRUCache(int capacity) {

    }
    
    int get(int key) {

    }
    
    void put(int key, int value) {

    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### Java

```java
class LRUCache {

    public LRUCache(int capacity) {

    }
    
    public int get(int key) {

    }
    
    public void put(int key, int value) {

    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

### Python3

```python3
class LRUCache:

    def __init__(self, capacity: int):


    def get(self, key: int) -> int:


    def put(self, key: int, value: int) -> None:



# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

### JavaScript

```javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {

};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {

};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {

};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### Go

```golang
type LRUCache struct {

}


func Constructor(capacity int) LRUCache {

}


func (this *LRUCache) Get(key int) int {

}


func (this *LRUCache) Put(key int, value int)  {

}


/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```

---

## 示例测试用例

```
["LRUCache","put","put","get","put","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
```

---

## AI 解答 (DeepSeek)

## 题目分析

LRU（Least Recently Used）缓存是一种常见的缓存淘汰策略，要求：
1. **快速查找**：通过 key 快速找到对应的 value
2. **快速插入/删除**：插入新数据或删除最久未使用的数据
3. **维护访问顺序**：需要知道哪个数据是最近使用的，哪个是最久未使用的

**核心需求**：
- `get(key)`：如果 key 存在，返回 value，并将该 key 标记为最近使用
- `put(key, value)`：
  - 如果 key 存在，更新 value，并标记为最近使用
  - 如果 key 不存在，插入新数据
    - 如果缓存已满，删除最久未使用的数据
    - 插入新数据并标记为最近使用

**时间复杂度要求**：O(1) 完成 get 和 put 操作

---

## 解题思路

### 关键数据结构选择
1. **哈希表**：提供 O(1) 的查找能力
2. **双向链表**：维护访问顺序，头部是最近使用的，尾部是最久未使用的
   - 在链表头部插入新节点或移动节点
   - 从链表尾部删除节点
   - 移动节点到头部需要 O(1) 时间

### 数据结构组合
- **哈希表**：`map[key] -> 链表节点指针`
- **双向链表**：节点包含 `key, value, prev, next`
- 操作：
  - `get(key)`：通过哈希表找到节点，将节点移到链表头部
  - `put(key, value)`：
    - 如果 key 存在：更新 value，节点移到头部
    - 如果 key 不存在：
      - 如果容量已满：删除链表尾部节点，从哈希表中删除对应 key
      - 创建新节点，插入链表头部，加入哈希表

---

## 解法一：哈希表 + 自定义双向链表

### 思路
手动实现双向链表，明确控制节点的插入、删除和移动操作。

### 代码实现

#### Go 实现
```go
type LRUCache struct {
    capacity int
    cache    map[int]*DLinkedNode
    head     *DLinkedNode
    tail     *DLinkedNode
}

type DLinkedNode struct {
    key   int
    value int
    prev  *DLinkedNode
    next  *DLinkedNode
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*DLinkedNode),
        head:     &DLinkedNode{key: 0, value: 0},
        tail:     &DLinkedNode{key: 0, value: 0},
    }
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
        return
    }
    
    if len(this.cache) >= this.capacity {
        removed := this.removeTail()
        delete(this.cache, removed.key)
    }
    
    newNode := &DLinkedNode{key: key, value: value}
    this.cache[key] = newNode
    this.addToHead(newNode)
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
    node := this.tail.prev
    this.removeNode(node)
    return node
}
```

#### C++ 实现
```cpp
class LRUCache {
private:
    struct DLinkedNode {
        int key, value;
        DLinkedNode* prev;
        DLinkedNode* next;
        DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
        DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
    };
    
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int capacity;
    int size;
    
    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }
    
    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
    
public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) return -1;
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (cache.count(key)) {
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
            return;
        }
        
        if (size == capacity) {
            DLinkedNode* removed = removeTail();
            cache.erase(removed->key);
            delete removed;
            size--;
        }
        
        DLinkedNode* newNode = new DLinkedNode(key, value);
        cache[key] = newNode;
        addToHead(newNode);
        size++;
    }
    
    ~LRUCache() {
        for (auto& pair : cache) {
            delete pair.second;
        }
        delete head;
        delete tail;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(1)
  - get 和 put 操作都是常数时间
  - 哈希表操作 O(1)，链表操作 O(1)
- **空间复杂度**：O(capacity)
  - 哈希表和链表存储 capacity 个元素

---

## 解法二：使用 STL（C++）或 container/list（Go）

### 思路
利用语言标准库中的双向链表和哈希表，减少手动链表操作。

### 代码实现

#### Go 实现（使用 container/list）
```go
import "container/list"

type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
}

type entry struct {
    key   int
    value int
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (this *LRUCache) Get(key int) int {
    if elem, ok := this.cache[key]; ok {
        this.list.MoveToFront(elem)
        return elem.Value.(*entry).value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if elem, ok := this.cache[key]; ok {
        elem.Value.(*entry).value = value
        this.list.MoveToFront(elem)
        return
    }
    
    if this.list.Len() >= this.capacity {
        back := this.list.Back()
        delete(this.cache, back.Value.(*entry).key)
        this.list.Remove(back)
    }
    
    newEntry := &entry{key: key, value: value}
    elem := this.list.PushFront(newEntry)
    this.cache[key] = elem
}
```

#### C++ 实现（使用 STL）
```cpp
class LRUCache {
private:
    int capacity;
    list<pair<int, int>> cacheList;
    unordered_map<int, list<pair<int, int>>::iterator> cacheMap;
    
public:
    LRUCache(int _capacity): capacity(_capacity) {}
    
    int get(int key) {
        if (cacheMap.find(key) == cacheMap.end()) return -1;
        
        auto it = cacheMap[key];
        int value = it->second;
        
        cacheList.erase(it);
        cacheList.push_front({key, value});
        cacheMap[key] = cacheList.begin();
        
        return value;
    }
    
    void put(int key, int value) {
        if (cacheMap.find(key) != cacheMap.end()) {
            cacheList.erase(cacheMap[key]);
        } else if (cacheList.size() == capacity) {
            auto last = cacheList.back();
            cacheMap.erase(last.first);
            cacheList.pop_back();
        }
        
        cacheList.push_front({key, value});
        cacheMap[key] = cacheList.begin();
    }
};
```

### 复杂度分析
- **时间复杂度**：O(1)
  - 所有操作都是常数时间
- **空间复杂度**：O(capacity)
  - 存储 capacity 个元素

---

## 解法三：使用 LinkedHashMap（Java 风格思路）

### 思路
某些语言（如 Java）有内置的 LinkedHashMap 可以直接实现 LRU。这里用 Go 模拟类似结构。

### Go 实现（简化版）
```go
type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
    mu       sync.RWMutex // 如果考虑并发
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (lru *LRUCache) Get(key int) int {
    lru.mu.RLock()
    elem, ok := lru.cache[key]
    lru.mu.RUnlock()
    
    if !ok {
        return -1
    }
    
    lru.mu.Lock()
    lru.list.MoveToFront(elem)
    value := elem.Value.(*entry).value
    lru.mu.Unlock()
    
    return value
}

func (lru *LRUCache) Put(key int, value int) {
    lru.mu.Lock()
    defer lru.mu.Unlock()
    
    if elem, ok := lru.cache[key]; ok {
        elem.Value.(*entry).value = value
        lru.list.MoveToFront(elem)
        return
    }
    
    if lru.list.Len() >= lru.capacity {
        back := lru.list.Back()
        delete(lru.cache, back.Value.(*entry).key)
        lru.list.Remove(back)
    }
    
    newEntry := &entry{key: key, value: value}
    elem := lru.list.PushFront(newEntry)
    lru.cache[key] = elem
}
```

### 复杂度分析
- **时间复杂度**：O(1)
- **空间复杂度**：O(capacity)

---

## 解法对比

| 特性 | 解法一（自定义链表） | 解法二（标准库） | 解法三（并发安全） |
|------|-------------------|----------------|------------------|
| **实现复杂度** | 较高，需要手动管理链表 | 较低，利用标准库 | 中等，添加锁机制 |
| **性能** | 最优，无额外开销 | 稍慢，有接口调用开销 | 最慢，有锁开销 |
| **可读性** | 较低，代码量大 | 较高，代码简洁 | 中等 |
| **扩展性** | 高，完全可控 | 低，受限于库功能 | 高，可扩展并发 |
| **适用场景** | 性能要求极高 | 快速实现，代码简洁 | 并发环境 |

### 推荐方案
1. **面试/竞赛**：解法一，展示对数据结构的深入理解
2. **生产环境**：解法二，代码简洁易维护
3. **并发环境**：解法三，添加适当的同步机制

### 关键点总结
1. **核心思想**：哈希表 + 双向链表
2. **O(1) 操作**：哈希表查找 O(1)，链表插入/删除 O(1)
3. **维护顺序**：最近使用的放头部，最久未使用的在尾部
4. **容量管理**：插入时检查容量，满则删除尾部节点

所有解法都能满足 O(1) 时间复杂度要求，选择哪种取决于具体需求和环境。

---

*获取时间: 2026-02-26 15:50:14*
