# 1399. 统计最大组的数目

**难度**: Easy

**标签**: 哈希表, 数学, 计数

**链接**: https://leetcode.cn/problems/count-largest-group/

---

## 题目描述

<p>给定一个整数 <code>n</code>&nbsp;。</p>

<p>我们需要根据数字的数位和将 <code>1</code> 到 <code>n</code> 的数字分组。例如，数字 14 和 5 属于 <strong>同一</strong>&nbsp;组，而数字 13 和 3 属于 <strong>不同</strong>&nbsp;组。</p>

<p>返回最大组的数字数量，即元素数量 <strong>最多</strong> 的组。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 13
<strong>输出：</strong>4
<strong>解释：</strong>总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：
[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 2
<strong>输出：</strong>2
<strong>解释：</strong>总共有 2 个大小为 1 的组 [1]，[2]。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    int countLargestGroup(int n) {
        
    }
};
```

### Java

```java
class Solution {
    public int countLargestGroup(int n) {
        
    }
}
```

### Python3

```python3
class Solution:
    def countLargestGroup(self, n: int) -> int:
        
```

### JavaScript

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var countLargestGroup = function(n) {
    
};
```

### Go

```golang
func countLargestGroup(n int) int {
    
}
```

---

## 提示

1. Count the digit sum for each integer in the range and find out the largest groups.

---

## 示例测试用例

```
13
```

---

## AI 解答 (DeepSeek)

## 题目分析

我们需要将 1 到 n 的数字按照**数位和**分组，然后找出**元素数量最多**的组，最后返回**拥有最多元素数量的组的个数**。

例如 n=13：
- 数位和为 1 的数字：1,10 → 组大小=2
- 数位和为 2 的数字：2,11 → 组大小=2
- 数位和为 3 的数字：3,12 → 组大小=2
- 数位和为 4 的数字：4,13 → 组大小=2
- 数位和为 5 的数字：5 → 组大小=1
- ...
- 数位和为 9 的数字：9 → 组大小=1

最大组大小 = 2，有 4 个组大小都为 2，所以返回 4。

---

## 解题思路

1. **计算每个数字的数位和**：遍历 1 到 n，对每个数字计算其各位数字之和。
2. **统计每个数位和出现的次数**：用哈希表或数组记录每个数位和对应的数字个数。
3. **找出最大出现次数**：遍历统计结果，找到最大的组大小。
4. **统计最大出现次数的组数**：再次遍历，统计有多少个组的大小等于最大值。

---

## 解法一：哈希表统计

### 思路
使用哈希表（map）记录每个数位和对应的数字个数，然后找出最大值并统计个数。

### 复杂度
- 时间复杂度：O(n log n)（因为每个数字计算数位和需要 O(log n) 时间）
- 空间复杂度：O(n)（哈希表存储）

### 代码实现

#### Go
```go
func countLargestGroup(n int) int {
    count := make(map[int]int)
    maxSize := 0
    
    for i := 1; i <= n; i++ {
        sum := 0
        num := i
        for num > 0 {
            sum += num % 10
            num /= 10
        }
        count[sum]++
        if count[sum] > maxSize {
            maxSize = count[sum]
        }
    }
    
    result := 0
    for _, v := range count {
        if v == maxSize {
            result++
        }
    }
    return result
}
```

#### C++
```cpp
class Solution {
public:
    int countLargestGroup(int n) {
        unordered_map<int, int> count;
        int maxSize = 0;
        
        for (int i = 1; i <= n; i++) {
            int sum = 0, num = i;
            while (num > 0) {
                sum += num % 10;
                num /= 10;
            }
            count[sum]++;
            if (count[sum] > maxSize) {
                maxSize = count[sum];
            }
        }
        
        int result = 0;
        for (auto& [_, v] : count) {
            if (v == maxSize) {
                result++;
            }
        }
        return result;
    }
};
```

---

## 解法二：数组统计（优化空间）

### 思路
由于 n ≤ 10^4，最大数位和 = 9+9+9+9 = 36（对于 9999），所以可以用长度为 37 的数组代替哈希表。

### 复杂度
- 时间复杂度：O(n log n)
- 空间复杂度：O(1)（固定大小数组）

### 代码实现

#### Go
```go
func countLargestGroup(n int) int {
    count := make([]int, 37) // 最大数位和 9+9+9+9=36
    maxSize := 0
    
    for i := 1; i <= n; i++ {
        sum := 0
        num := i
        for num > 0 {
            sum += num % 10
            num /= 10
        }
        count[sum]++
        if count[sum] > maxSize {
            maxSize = count[sum]
        }
    }
    
    result := 0
    for _, v := range count {
        if v == maxSize {
            result++
        }
    }
    return result
}
```

#### C++
```cpp
class Solution {
public:
    int countLargestGroup(int n) {
        int count[37] = {0}; // 最大数位和 36
        int maxSize = 0;
        
        for (int i = 1; i <= n; i++) {
            int sum = 0, num = i;
            while (num > 0) {
                sum += num % 10;
                num /= 10;
            }
            count[sum]++;
            if (count[sum] > maxSize) {
                maxSize = count[sum];
            }
        }
        
        int result = 0;
        for (int i = 0; i < 37; i++) {
            if (count[i] == maxSize) {
                result++;
            }
        }
        return result;
    }
};
```

---

## 解法三：预计算数位和（优化时间）

### 思路
利用数位和的递推关系：`digitSum[i] = digitSum[i/10] + i%10`，可以 O(1) 计算每个数的数位和。

### 复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)（存储数位和数组）

### 代码实现

#### Go
```go
func countLargestGroup(n int) int {
    digitSum := make([]int, n+1)
    count := make([]int, 37)
    maxSize := 0
    
    for i := 1; i <= n; i++ {
        digitSum[i] = digitSum[i/10] + i%10
        sum := digitSum[i]
        count[sum]++
        if count[sum] > maxSize {
            maxSize = count[sum]
        }
    }
    
    result := 0
    for _, v := range count {
        if v == maxSize {
            result++
        }
    }
    return result
}
```

#### C++
```cpp
class Solution {
public:
    int countLargestGroup(int n) {
        vector<int> digitSum(n+1, 0);
        int count[37] = {0};
        int maxSize = 0;
        
        for (int i = 1; i <= n; i++) {
            digitSum[i] = digitSum[i/10] + i%10;
            int sum = digitSum[i];
            count[sum]++;
            if (count[sum] > maxSize) {
                maxSize = count[sum];
            }
        }
        
        int result = 0;
        for (int i = 0; i < 37; i++) {
            if (count[i] == maxSize) {
                result++;
            }
        }
        return result;
    }
};
```

---

## 解法对比

| 解法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| 哈希表 | O(n log n) | O(n) | 通用，适用于数位和范围未知 | 哈希表开销大 |
| 数组统计 | O(n log n) | O(1) | 空间效率高 | 仅适用于数位和范围小的情况 |
| 预计算数位和 | O(n) | O(n) | 时间最优 | 需要额外 O(n) 空间存储数位和 |

**推荐解法**：**解法二（数组统计）**，因为：
1. n ≤ 10^4，数位和范围固定为 0~36，数组大小固定。
2. 空间复杂度 O(1)，时间复杂度 O(n log n) 在 n=10^4 时足够快。
3. 代码简洁，无需复杂数据结构。

---

## 总结
本题关键在于：
1. 理解分组规则（按数位和分组）
2. 选择合适的统计数据结构（数组优于哈希表，因为数位和范围小）
3. 注意最终要求的是**最大组的数量**，而不是最大组的大小

对于本题约束，解法二是最佳选择。

---

*获取时间: 2026-02-27 10:32:36*
