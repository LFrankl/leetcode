# 1616. 分割两个字符串得到回文串

**难度**: Medium

**标签**: 双指针, 字符串

**链接**: https://leetcode.cn/problems/split-two-strings-to-make-palindrome/

---

## 题目描述

<p>给你两个字符串&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;，它们长度相同。请你选择一个下标，将两个字符串都在&nbsp;<strong>相同的下标 </strong>分割开。由&nbsp;<code>a</code>&nbsp;可以得到两个字符串：&nbsp;<code>a<sub>prefix</sub></code>&nbsp;和&nbsp;<code>a<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub>&nbsp;</sub>，同理，由&nbsp;<code>b</code> 可以得到两个字符串&nbsp;<code>b<sub>prefix</sub></code> 和&nbsp;<code>b<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>&nbsp;。请你判断&nbsp;<code>a<sub>prefix</sub> + b<sub>suffix</sub></code> 或者&nbsp;<code>b<sub>prefix</sub> + a<sub>suffix</sub></code>&nbsp;能否构成回文串。</p>

<p>当你将一个字符串&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>s<sub>prefix</sub></code> 和&nbsp;<code>s<sub>suffix</sub></code>&nbsp;时，&nbsp;<code>s<sub>suffix</sub></code> 或者&nbsp;<code>s<sub>prefix</sub></code> 可以为空。比方说，&nbsp;<code>s = "abc"</code>&nbsp;那么&nbsp;<code>"" + "abc"</code>&nbsp;，&nbsp;<code>"a" + "bc"&nbsp;</code>，&nbsp;<code>"ab" + "c"</code>&nbsp;和&nbsp;<code>"abc" + ""</code>&nbsp;都是合法分割。</p>

<p>如果 <strong>能构成回文字符串</strong> ，那么请返回&nbsp;<code>true</code>，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>

<p><strong>注意</strong>，&nbsp;<code>x + y</code>&nbsp;表示连接字符串&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<b>输入：</b>a = "x", b = "y"
<b>输出：</b>true
<b>解释：</b>如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：
a<sub>prefix</sub> = "", a<sub>suffix</sub> = "x"
b<sub>prefix</sub> = "", b<sub>suffix</sub> = "y"
那么 a<sub>prefix</sub> + b<sub>suffix</sub> = "" + "y" = "y" 是回文串。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>a = "xbdef", b = "xecab"
<strong>输出：</strong>false
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<b>输入：</b>a = "ulacfd", b = "jizalu"
<b>输出：</b>true
<b>解释：</b>在下标为 3 处分割：
a<sub>prefix</sub> = "ula", a<sub>suffix</sub> = "cfd"
b<sub>prefix</sub> = "jiz", b<sub>suffix</sub> = "alu"
那么 a<sub>prefix</sub> + b<sub>suffix</sub> = "ula" + "alu" = "ulaalu" 是回文串。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>
	<li><code>a.length == b.length</code></li>
	<li><code>a</code> 和&nbsp;<code>b</code>&nbsp;都只包含小写英文字母</li>
</ul>


---

## 代码模板


### C++

```cpp
class Solution {
public:
    bool checkPalindromeFormation(string a, string b) {
        
    }
};
```

### Java

```java
class Solution {
    public boolean checkPalindromeFormation(String a, String b) {
        
    }
}
```

### Python3

```python3
class Solution:
    def checkPalindromeFormation(self, a: str, b: str) -> bool:
        
```

### JavaScript

```javascript
/**
 * @param {string} a
 * @param {string} b
 * @return {boolean}
 */
var checkPalindromeFormation = function(a, b) {
    
};
```

### Go

```golang
func checkPalindromeFormation(a string, b string) bool {
    
}
```

---

## 提示

1. Try finding the largest prefix from a that matches a suffix in b
2. Try string matching

---

## 示例测试用例

```
"x"
"y"
```

---

## AI 解答 (DeepSeek)

## 题目分析

题目要求：给定两个长度相同的字符串 `a` 和 `b`，选择一个相同的分割点，将两个字符串分别分割为前后两部分，然后交换前后部分组合成两个新字符串：
- `aprefix + bsuffix`
- `bprefix + asuffix`

判断这两个新字符串中是否至少有一个是回文串。

**关键点**：
1. 分割点可以在任意位置（包括两端，即前后部分可以为空）
2. 需要检查两种组合方式
3. 字符串长度可达 10^5，需要 O(n) 或 O(n log n) 的算法

## 解题思路

### 核心观察
当我们组合 `aprefix + bsuffix` 时：
- `aprefix` 来自 `a` 的前缀
- `bsuffix` 来自 `b` 的后缀
- 组合后的字符串长度为原字符串长度

设字符串长度为 `n`，分割点为 `i`（0 ≤ i ≤ n）：
- `aprefix = a[0:i]`, `asuffix = a[i:n]`
- `bprefix = b[0:i]`, `bsuffix = b[i:n]`
- 组合1：`a[0:i] + b[i:n]`
- 组合2：`b[0:i] + a[i:n]`

### 思路一：双指针检查法（最优解）
我们可以从两端向中间检查，找到第一个不匹配的位置，然后尝试用另一个字符串的对应部分来弥补。

具体步骤：
1. 检查 `aprefix + bsuffix` 是否可能为回文：
   - 从两端向中间比较 `a` 的前缀和 `b` 的后缀
   - 当遇到字符不匹配时，有两种可能：
     a) 使用 `a` 的剩余部分作为中间段
     b) 使用 `b` 的剩余部分作为中间段
   - 检查这两种情况的中间段是否为回文

2. 同理检查 `bprefix + asuffix`

时间复杂度：O(n)，空间复杂度：O(1)

### 思路二：中心扩展法
对于每个可能的分割点，检查组合后的字符串是否为回文。但直接检查所有分割点会达到 O(n²) 复杂度，需要优化。

优化方法：
- 预处理字符串，找到最长的前后匹配部分
- 然后检查剩余部分是否为回文

时间复杂度：O(n)，空间复杂度：O(1)

### 思路三：字符串哈希（Rabin-Karp）
使用字符串哈希可以在 O(1) 时间内判断子串是否回文，但需要预处理前缀哈希和后缀哈希。

步骤：
1. 计算 `a` 和 `b` 的前缀哈希和后缀哈希
2. 对于每个分割点，可以快速计算组合字符串的哈希值
3. 判断是否为回文

时间复杂度：O(n)，空间复杂度：O(n)

---

## 解法实现

### 解法一：双指针检查法（最优解）

#### 思路
1. 定义辅助函数 `checkPalindrome(a, b)`，检查 `aprefix + bsuffix` 是否可能为回文
2. 在函数中，从两端向中间比较：
   - 如果所有字符都匹配，直接返回 true
   - 当遇到不匹配时，检查 `a[left:right+1]` 或 `b[left:right+1]` 是否为回文
3. 分别检查两种组合方式

```go
// Go 实现
func checkPalindromeFormation(a string, b string) bool {
    // 检查子串是否为回文
    isPalindrome := func(s string, left, right int) bool {
        for left < right {
            if s[left] != s[right] {
                return false
            }
            left++
            right--
        }
        return true
    }
    
    // 检查 a 的前缀和 b 的后缀组合
    check := func(a, b string) bool {
        left, right := 0, len(a)-1
        // 从两端向中间找到第一个不匹配的位置
        for left < right && a[left] == b[right] {
            left++
            right--
        }
        // 如果全部匹配，或者剩余部分是回文，则成功
        if left >= right {
            return true
        }
        // 尝试用 a 的剩余部分或 b 的剩余部分作为中间段
        return isPalindrome(a, left, right) || isPalindrome(b, left, right)
    }
    
    return check(a, b) || check(b, a)
}
```

```cpp
// C++ 实现
class Solution {
private:
    // 检查子串是否为回文
    bool isPalindrome(const string& s, int left, int right) {
        while (left < right) {
            if (s[left] != s[right]) return false;
            left++;
            right--;
        }
        return true;
    }
    
    // 检查 a 的前缀和 b 的后缀组合
    bool check(const string& a, const string& b) {
        int left = 0, right = a.length() - 1;
        // 从两端向中间找到第一个不匹配的位置
        while (left < right && a[left] == b[right]) {
            left++;
            right--;
        }
        // 如果全部匹配，或者剩余部分是回文，则成功
        if (left >= right) return true;
        // 尝试用 a 的剩余部分或 b 的剩余部分作为中间段
        return isPalindrome(a, left, right) || isPalindrome(b, left, right);
    }
    
public:
    bool checkPalindromeFormation(string a, string b) {
        return check(a, b) || check(b, a);
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，每个字符串最多遍历两次
- 空间复杂度：O(1)，只使用了常数空间

---

### 解法二：中心扩展法

#### 思路
1. 先找到 `a` 和 `b` 的最长公共前后缀
2. 然后检查剩余部分是否为回文
3. 需要考虑四种情况：
   - `a` 的前缀 + `b` 的后缀
   - `b` 的前缀 + `a` 的后缀
   - 以及它们对称的情况

```go
// Go 实现
func checkPalindromeFormation(a string, b string) bool {
    n := len(a)
    
    // 检查字符串是否为回文
    isPalindrome := func(s string) bool {
        left, right := 0, len(s)-1
        for left < right {
            if s[left] != s[right] {
                return false
            }
            left++
            right--
        }
        return true
    }
    
    // 如果 a 或 b 本身就是回文，直接返回 true
    if isPalindrome(a) || isPalindrome(b) {
        return true
    }
    
    // 检查四种情况
    check := func(s1, s2 string) bool {
        // 找到从两端开始匹配的位置
        left, right := 0, n-1
        for left < right && s1[left] == s2[right] {
            left++
            right--
        }
        
        if left >= right {
            return true
        }
        
        // 检查 s1[left:right+1] 是否为回文
        i, j := left, right
        for i < j && s1[i] == s1[j] {
            i++
            j--
        }
        if i >= j {
            return true
        }
        
        // 检查 s2[left:right+1] 是否为回文
        i, j = left, right
        for i < j && s2[i] == s2[j] {
            i++
            j--
        }
        return i >= j
    }
    
    return check(a, b) || check(b, a)
}
```

```cpp
// C++ 实现
class Solution {
private:
    bool isPalindrome(const string& s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s[left] != s[right]) return false;
            left++;
            right--;
        }
        return true;
    }
    
    bool check(const string& s1, const string& s2) {
        int n = s1.length();
        int left = 0, right = n - 1;
        
        // 找到从两端开始匹配的位置
        while (left < right && s1[left] == s2[right]) {
            left++;
            right--;
        }
        
        if (left >= right) return true;
        
        // 检查 s1[left:right+1] 是否为回文
        int i = left, j = right;
        while (i < j && s1[i] == s1[j]) {
            i++;
            j--;
        }
        if (i >= j) return true;
        
        // 检查 s2[left:right+1] 是否为回文
        i = left, j = right;
        while (i < j && s2[i] == s2[j]) {
            i++;
            j--;
        }
        return i >= j;
    }
    
public:
    bool checkPalindromeFormation(string a, string b) {
        if (isPalindrome(a) || isPalindrome(b)) return true;
        return check(a, b) || check(b, a);
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，每个字符串最多遍历三次
- 空间复杂度：O(1)

---

### 解法三：字符串哈希法

#### 思路
使用 Rabin-Karp 哈希算法，预处理字符串的前缀哈希和后缀哈希，可以在 O(1) 时间内判断任意子串是否为回文。

```go
// Go 实现
func checkPalindromeFormation(a string, b string) bool {
    n := len(a)
    if n == 0 {
        return true
    }
    
    // 计算字符串的哈希
    computeHashes := func(s string) ([]uint64, []uint64) {
        base := uint64(131)
        prefix := make([]uint64, n+1)
        suffix := make([]uint64, n+1)
        pow := make([]uint64, n+1)
        pow[0] = 1
        
        for i := 1; i <= n; i++ {
            prefix[i] = prefix[i-1]*base + uint64(s[i-1])
            pow[i] = pow[i-1] * base
        }
        
        for i := n - 1; i >= 0; i-- {
            suffix[i] = suffix[i+1]*base + uint64(s[i])
        }
        
        return prefix, suffix
    }
    
    // 检查子串是否为回文
    isPalindrome := func(prefix, suffix []uint64, pow []uint64, left, right int) bool {
        if left >= right {
            return true
        }
        // 正序哈希
        hash1 := prefix[right+1] - prefix[left]*pow[right-left+1]
        // 逆序哈希
        hash2 := suffix[left] - suffix[right+1]*pow[right-left+1]
        return hash1 == hash2
    }
    
    // 预处理哈希
    aPrefix, aSuffix := computeHashes(a)
    bPrefix, bSuffix := computeHashes(b)
    
    // 计算 pow 数组
    pow := make([]uint64, n+1)
    pow[0] = 1
    base := uint64(131)
    for i := 1; i <= n; i++ {
        pow[i] = pow[i-1] * base
    }
    
    // 检查函数
    check := func(prefix1, suffix1, prefix2, suffix2 []uint64) bool {
        left, right := 0, n-1
        for left < right {
            if isPalindrome(prefix1, suffix1, pow, left, right) || 
               isPalindrome(prefix2, suffix2, pow, left, right) {
                return true
            }
            // 检查当前字符是否匹配
            hash1 := prefix1[right+1] - prefix1[left]*pow[right-left+1]
            hash2 := suffix2[left] - suffix2[right+1]*pow[right-left+1]
            if hash1 != hash2 {
                break
            }
            left++
            right--
        }
        return left >= right
    }
    
    // 检查两种情况
    return check(aPrefix, aSuffix, bPrefix, bSuffix) || 
           check(bPrefix, bSuffix, aPrefix, aSuffix)
}
```

```cpp
// C++ 实现
class Solution {
private:
    using ULL = unsigned long long;
    const ULL BASE = 131;
    
    vector<ULL> computePrefixHash(const string& s) {
        int n = s.length();
        vector<ULL> prefix(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix[i] = prefix[i-1] * BASE + s[i-1];
        }
        return prefix;
    }
    
    vector<ULL> computeSuffixHash(const string& s) {
        int n = s.length();
        vector<ULL> suffix(n + 1, 0);
        for (int i = n - 1; i >= 0; i--) {
            suffix[i] = suffix[i+1] * BASE + s[i];
        }
        return suffix;
    }
    
    bool isPalindrome(const vector<ULL>& prefix, const vector<ULL>& suffix, 
                     const vector<ULL>& pow, int left, int right) {
        if (left >= right) return true;
        ULL hash1 = prefix[right+1] - prefix[left] * pow[right-left+1];
        ULL hash2 = suffix[left] - suffix[right+1] * pow[right-left+1];
        return hash1 == hash2;
    }
    
public:
    bool checkPalindromeFormation(string a, string b) {
        int n = a.length();
        
        // 预处理哈希
        auto aPrefix = computePrefixHash(a);
        auto aSuffix = computeSuffixHash(a);
        auto bPrefix = computePrefixHash(b);
        auto bSuffix = computeSuffixHash(b);
        
        // 预处理幂
        vector<ULL> pow(n + 1, 1);
        for (int i = 1; i <= n; i++) {
            pow[i] = pow[i-1] * BASE;
        }
        
        // 检查函数
        auto check = [&](const vector<ULL>& p1, const vector<ULL>& s1,
                        const vector<ULL>& p2, const vector<ULL>& s2) -> bool {
            int left = 0, right = n - 1;
            while (left < right) {
                if (isPalindrome(p1, s1, pow, left, right) || 
                    isPalindrome(p2, s2, pow, left, right)) {
                    return true;
                }
                ULL hash1 = p1[right+1] - p1[left] * pow[right-left+1];
                ULL hash2 = s2[left] - s2[right+1] * pow[right-left+1];
                if (hash1 != hash2) break;
                left++;
                right--;
            }
            return left >= right;
        };
        
        return check(aPrefix, aSuffix, bPrefix, bSuffix) || 
               check(bPrefix, bSuffix, aPrefix, aSuffix);
    }
};
```

**复杂度分析**：
- 时间复杂度：O(n)，需要预处理哈希
- 空间复杂度：O(n)，需要存储哈希数组

---

## 解法对比

| 特性 | 解法一：双指针检查法 | 解法二：中心扩展法 | 解法三：字符串哈希法 |
|------|-------------------|------------------|-------------------|
| 时间复杂度 | O(n) | O(n) | O(n) |
| 空间复杂度 | O(1) | O(1) | O(n) |
| 实现难度 | 简单 | 中等 | 复杂 |
| 运行效率 | 高 | 高 | 中等 |
| 适用场景 | 通用 | 通用 | 需要多次查询时 |

**总结**：
1. **解法一（双指针检查法）** 是最优解，代码简洁，效率高，空间复杂度低，推荐使用
2. **解法二（中心扩展法）** 思路清晰，实现相对简单，也是很好的选择
3. **解法三（字符串哈希法）** 虽然理论时间复杂度相同，但实现复杂，常数因子大，且需要额外空间，在本题中不是最佳选择

在实际面试或竞赛中，推荐使用**解法一**，它直观且高效，容易理解和实现。

---

*获取时间: 2026-02-26 16:17:38*
